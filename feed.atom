<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ibert.me/</id>
    <title>Herbert He</title>
    <updated>2024-03-27T02:25:14.594Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>Herbert He</name>
        <email>hi@ibert.me</email>
        <uri>https://ibert.me</uri>
    </author>
    <link rel="alternate" href="https://ibert.me/"/>
    <link rel="self" href="https://ibert.me/feed.atom"/>
    <subtitle>Herbert He's Blog</subtitle>
    <logo>https://ibert.me/avatar.jpeg</logo>
    <icon>https://ibert.me/avatar.jpeg</icon>
    <rights>CC BY-NC-SA 4.0</rights>
    <entry>
        <title type="html"><![CDATA[markdown自定义的思考 📌]]></title>
        <id>https://ibert.me/posts/zh/markdown自定义的思考.html</id>
        <link href="https://ibert.me/posts/zh/markdown自定义的思考.html"/>
        <updated>2021-02-07T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>已经记不清什么时候开始接触的markdown了，好像是从我的一个学长做了我们学校的大数据协会论坛开始的。如果我没记错的话用的还是b3log的开源项目，应该是使用的<a href="https://github.com/88250/symphony">Symphony</a>。后来听学长说太复杂了，维护无从下手然后删库跑路了😂</p>
<p>也正是他画的这个饼，让我从零开始设计一个社区给不同学科、不同专业的同学来使用，之前实现过的版本并不是很满意（应该在我的链滴帖子里还能找到），然后又开始了重构之路。也正是不断的与markdown不同的编辑器接触，也让我对marked.js、markdown-it、for-editor、lute、vditor等等的编辑器、编译器、渲染器有了很多的接触，对于markdown及其拓展语法有了各种奇奇怪怪的想法</p>
<!-- more -->
<h2>for-editor-herb</h2>
<p>for-editor是一个UI设计非常不错的编辑器，它的底层解析引擎为marked.js。marked.js对于markdown的解析渲染在前端非常有名，并且在很多的编辑器上面也得到了应用。for-editor很轻、很小、很美，但是也避免不了出现了不少的bug，也不支持很多的features。当时只算是个开源项目的萌新，给作者提PR没有得到回复，然后给作者发邮件还是没有回复23333我明显感觉到作者好像无意再继续维护下去了，在issues里面也帮助了一些老哥解决了一些问题。</p>
<p>直到有个老哥建议我不如去自己新开一个仓库，然后自己来打包发布2333 其实吧，当时做前端顶多算个页面仔，也就是自己写写页面这个样子，压根也没接触过npm的库咋发布，然后就试错硬着头皮来呗。修复了很多的bug，一度怀疑人生😑尤其是那个编辑器-简直是噩梦，有兴趣的同学可以了解一下前端如何实现一个富文本编辑器🤣我当时一度怀疑我是不是在试图写一个word！！在编辑器开发里其实说问题吧，多也不多，也就是怎么撑开textarea、怎么控制焦点、怎么获取选区这点问题😈当然这只是开个玩笑，实操起来真的是怀疑人生。</p>
<p>for-editor计算行号就明显有个问题，它的行号是基于 <code>\n</code> 来计算的，这根本是不准确的。在打开和关闭渲染的时候由于textarea的宽度会发生改变。这就直接会导致，其实字它会换行，其实这跟行号就完全不匹配了。后来我的改进方案是获取容器的实际高度，然后根据字高来算实际的行数。一般默认的字体大小 <code>font-size: 16px;</code> ，然后明面上解决了这个问题，但是还是没能解决开关渲染导致的不准确，因为根本不会触发height发生改变。。。这个很大程度上跟设计机制有关系（随便看一看HTML就知道问题了），不过整体体验影响还可以，虽然一度让我想重构整个编辑器。愚以为vscode的体验真的是神仙，vscode其实知道的都知道是基于electron开发的，叹为观止。。。</p>
<p>上面就是举个例子，在for-editor里面也就实现了下面的一些功能，好像有老哥还把这个用于项目了😨</p>
<ul>
<li>更多的工具栏按钮</li>
<li>支持数学公式的渲染</li>
<li>支持响应式布局</li>
<li>支持大纲跳转锚点</li>
<li>支持大纲直接生成插入</li>
<li>内置简繁体中文、英文和日文的支持</li>
<li>支持自定义支持编辑器国际化</li>
<li>支持GitHub Diff语法渲染（这个vditor好像并没有完全支持）</li>
<li>支持自定义注册代码高亮的语言类型</li>
<li>支持emoji短码渲染绘文字emoji</li>
<li>支持<code>==markdown==</code> 语法行内高亮</li>
</ul>
<p>其实我之前还准备支持mermaid的，但是之前我一直没有解决渲染的问题，没找到渲染的时机，后来放弃支持了。到后来我其实比较抗拒维护这个项目了，因为我能明显感觉到渲染越来越慢。在这个项目的issue里，也有老哥给我安利过vditor，但是他貌似不会在React里面用emmm。这个项目我几乎调整了80%的代码结构，有一些问题不是很好修复，只能寄希望于重构😭 但是当时又在同步写着pyvm，没有想法继续重构下去。后来业务代码越来越多就没有继续了，被我Achieved了，有4个fork，应该还有老哥还在维护，项目可以在 <a href="https://goer.icu/for-editor-herb/">for-editor-herb</a> 体验。</p>
<p>在这个项目的开发中，我为了实现一些解析语法去阅读了marked.js的源码。marked.js整个项目的灵魂在于正则表达式，里面的正则表达式写的非常非常厉害。在部分features实现的时候也参考了，marked.js一直到高级使用部分都非常非常熟悉。但是，性能和维护永远是最大的问题。</p>
<h2>lute</h2>
<p>先写lute的原因是vditor我一直在不断地关注着，并且一直发现问题和提feature疯狂“作妖”😁希望 @Vanessa V姐不会觉得我超级烦😥</p>
<p>接触lute的原因是有一些feature依靠vditor没办法实现。举个例子，在React Native中如何实现markdown渲染？难道是套一个WebView加载H5？虽然在某些场景不得不去这么实现，比如依赖KaTeX做数学公式渲染、abcjs做五线谱渲染，要不就自己再写一个库？emmm WebView会有很多的限制，而且其实在移动端做markdown即时渲染的体验不会很好。即使是GitHub官方的APP也没有实现，然后我的眼光就放到了lute的身上23333</p>
<p>lute是基于编译原理使用go开发的，刚好一不小心之前自学过golang，然后开始研究lute。看的很浅显，并没有关注生成AST的部分，自己关注的主要是在渲染的处理上。lute关于内部实现方面没有文档，只能自己去看源码。lute的代码结构设计很优秀，很容易上手去阅读定位具体的问题和实现的位置。</p>
<p>分析需求和具体实现：基于lute直接实现组件渲染其实是不实际的，即使后来vditor支持了自定义渲染器，但是其实仍然是string类型的。而React Native的组件是JSX，所以我需要一棵树，自己根据这棵树来遍历递归渲染。很遗憾，lute其实并没有提供这个方法，lute并不是一个纯粹的解析器，而是同时是一个渲染器，直接生成了DOM！如果你尝试在js里面调用lute暴露的某些在godoc有的方法，会直接报错。</p>
<p>其实，lute的节点细分比vditor多很多，好像是有一百四十多个。并且随着特性的不断增加，这个数量还在增加。最后还是实现了“这棵树”的输出，自lute v1.7.1之后支持，是 <code>lute.RenderJSON()</code> 这个方法。这棵树实现了vditor绝大多数支持的语法输出，但其实vditor有很多很多的渲染都是在前端完成的。其实依靠这个方法，是可以自行实现与vditor兼容的一个纯粹的渲染器，可以自行看lute的文档 <a href="https://github.com/88250/lute#%E5%85%B3%E4%BA%8E-luterenderjson-%E7%9A%84%E4%BD%BF%E7%94%A8">如何使用</a></p>
<p>当我开始基于lute写npm包的时候，发现了一个很严重的问题。lute的包太大了，打包失败。lute是通过gopherjs打包成js的，没办法拆包。上文提到lute其实并不是一个纯粹的解析器，包含了渲染的部分，不知道 @88250 D哥有没有计划把解析的部分单独分离出去，新成立一个极高效率的markdown解析器的项目emmm</p>
<p>如果你想要使用lute自定义渲染器，或者写个库什么的，这并不影响你在web端的使用。可以参考rollup外部依赖的这部分，通过CDN外部引入问题不大的，只是把lute打包会出现问题而已。</p>
<h2>vditor</h2>
<p>刚刚查了一下，在vditor总共提过9个issues，开始提的问题是极蠢的，对8起，浪费V姐的时间了。不过好像我提的好几个issue后来的版本实现了2333。比如这个 <a href="https://github.com/Vanessa219/vditor/issues/592">使用hint at方法报错</a> ，我希望通过拓展 <code>@</code> 这个方法，实现at的并不只是一个用户，甚至是可以引用一篇文章等。</p>
<p>不过有一说一，我回顾了一下我的issue还是觉得有一些是真的low😥vditor的源码看了一部分，有的部分还是很有意思的，我也知道了vditor为什么有的方法那么实现。vditor的features更新速度总是比文档快很多，如果想尝鲜之类的话，建议去阅读源码（手动滑稽）</p>
<p>不过，这几天发现vditor有一个问题我还是感觉挺严重的。当vditor和SSR一起使用的时候，可能会导致页面崩溃，甚至是浏览器崩溃。当你在sv模式下输入iframe这个HTML标签，可能会导致一些问题。具体讨论可以看这个issue <a href="https://github.com/Vanessa219/vditor/issues/918">#918</a> ，需求是在这个issue <a href="https://github.com/Vanessa219/vditor/issues/906">#906</a> 提出的。</p>
<p><strong>需要提醒把vditor当作编辑器的项目，markdown原生支持HTML标签，所以除了开启vditor的安全过滤规避XSS攻击（默认打开的）之外，还需要过滤iframe这个标签！如果是论坛等交互式网站的话，可能无法控制用户通过iframe植入广告甚至是非法网站！</strong></p>
<p>iframe渲染这个需求，其实实现起来并不简单，需要尤其注意过滤iframe的domain和减少iframe导致的GET请求，有的引用网站不排除有访问的风控。在上面issue的讨论里我提供了两种思路，目的就是为了iframe的请求和过滤非法域名，我已经自行实现了第一种思路，依赖下面介绍的库实现起来其实非常简单。其实就是延时渲染或者防抖，这些其实在前端优化里面都有实际的应用，每个人都有不同的实现方式，不赘述了。</p>
<h2>codeblock-iframe语法</h2>
<p>这是我在上面的思考中提出的一种语法，也许之前可能有人提也能不一定的。方法特别简单，即把iframe当作代码块处理，遵循TOML的语法，这样对代码侵入很小。</p>
<p>基于这个思想，我写了两个库分别支持了webpack等打包工具的调用和web端直接通过script进行引用，并且为docsify写了插件支持这种语法。</p>
<p>转化过程可以在这个demo里体验 <a href="https://goer.icu/codeblock-iframe/demo/">demo</a></p>
<p>docsify的使用在这个demo里体验 <a href="https://goer.icu/docsify-codeblock-iframe/demo/#/">demo</a></p>
<p>仓库地址如下</p>
<ul>
<li><a href="https://github.com/HerbertHe/toml2iframe">toml2iframe</a> 支持webpack等打包工具</li>
<li><a href="https://github.com/HerbertHe/codeblock-iframe">codeblock-iframe</a> 支持web端通过CDN导入</li>
<li><a href="https://github.com/HerbertHe/docsify-codeblock-iframe">docsify-codeblock-iframe</a> 为docsify提供的支持插件</li>
</ul>
<h2>Todos</h2>
<p>在我的脑子里，还有很多很多的feature提供给markdown进行支持，比如最近对markdown支持化学结构式很感兴趣。看了现存的极少的实现方案，感觉不怎么样，可能的话只能自己去研究了，比如zrender</p>
<p>因为自己是物理系的，对公式输入很敏感所以早都基于KaTeX尝试实现了Tex</p>
<p>更多的想法的话，可能会为飞书写应用或者单独开发一个PC端为协同办公提供服务。虽然飞书的云文档很好用，但是还是避免不了它还是不能支撑很多的协同文档问题。所以，为团队的项目开发的话，可能会基于vditor实现一个协同文档的服务，有想法是借鉴slack实现。目标跟思源笔记的方向完全不一样，主要协同文档、文档安全、权限控制等，实现起来的架构设计和算法还是挺难的。</p>
<p>因为idea太多了，导致自己写代码的速度跟不上哈哈哈哈哈</p>
<h2>我的其他开源项目</h2>
<p>就写我认为好用的吧，其他的小插件都在我的仓库里很好找的</p>
<ul>
<li><a href="https://github.com/NucoTech/nuco-backend-cli">nbc</a> 全称<strong>nuco-backend-cli</strong> 是我针对限制团队commit风格和开发有的常用需求写的命令行工具，基于golang开发，支持MacOS、Linux和Windows三端，已经投入平时的开发之中使用了，并且提供了详细的文档<a href="https://nucotech.github.io/nuco-backend-cli">使用文档</a></li>
<li><a href="https://github.com/NucoTech/nuco-docsify">nuco-docsify</a> 这是为了团队项目生成文档模板的工具，支持很多feature。这样我们就不必要每一次都配置文档了，<code>nbc</code> 也提供了<code>nbc docs</code> 直接生成文档，并且可以通过<code>nbc serve</code> 直接启动静态预览！</li>
</ul>
<p>还有一些文档翻译什么的，如果你觉得好用的话给个Star嗷~哈哈哈哈</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用TypeScript操作语法树]]></title>
        <id>https://ibert.me/posts/zh/如何使用TypeScript操作语法树.html</id>
        <link href="https://ibert.me/posts/zh/如何使用TypeScript操作语法树.html"/>
        <updated>2024-03-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://unifiedjs.com/learn/guide/syntax-trees-typescript/">https://unifiedjs.com/learn/guide/syntax-trees-typescript/</a></p>
</blockquote>
<p>本教程将向你介绍 TypeScript 使用 <a href="https://github.com/syntax-tree/unist">unist</a> 和 <a href="https://unifiedjs.com/explore/package/unified/">unified</a>。</p>
<h2>基础</h2>
<p>所有的 <a href="https://unifiedjs.com/explore/package/unified/">unified</a> 语法树都是基于 <a href="https://github.com/syntax-tree/unist">unist</a>(<strong>uni</strong>versal <strong>s</strong>yntax <strong>t</strong>ree)。可用的核心类型包只包含类型：<a href="https://www.npmjs.com/package/@types/unist"><code>@types/unist</code></a>。主要的类型是 <code>节点(Node)</code>，其他的都继承于此。<code>字面量(Literal)</code> 和 <code>父节点(Parent)</code> 这些更具体的类型也是继承于 <code>节点(Node)</code>。</p>
<p>由 <a href="https://github.com/syntax-tree/unist">unist</a> 提供的类型为抽象接口(Abstract Interfaces)，通常情况下，你需要根据所使用的语言来选择更加实用的接口。<a href="https://unifiedjs.com/explore/package/unified/">unified</a> 所支持的每种语言，例如：markdown、HTML 和 XML 都有他们自己继承于 <code>unist</code> 的语法树标准。</p>
<p>让我们一起来看看。</p>
<h2>unist</h2>
<h3><code>节点(Node)</code></h3>
<p><code>节点(Node)</code> 是语法树的句法单位。每个节点都继承于 <code>节点(Node)</code>（有时候是 <code>字面量(Literal)</code> 或者 <code>父节点(Parent)</code>）。并且设置 <code>type</code> 为一个 <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">字符串字面量(string literal)</a>。这个类型字段用于告诉我们节点内容的类型是什么。这个字段唯一标识一种内容，在 TypeScript 中，被称为 <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions">可辨识联合/可区分联合(discriminated union)</a>。举个在 ，markdown(<a href="https://github.com/syntax-tree/mdast">mdast</a>) 中的例子：<code>Node</code> 被继承用于一些节点 <code>Heading</code> 或 <code>Link</code>，以取代使用 <code>type</code> 字段设置为 <code>heading</code> 和 <code>link</code>。</p>
<p>一个节点可以可选地包含一个 <code>Data</code> 接口于 <code>data</code> 字段。这是一个对象用于存储额外的原始数据，并不是节点的标准，但在生态中被定义（工具类(utilities)和插件(plugins)）。</p>
<p>当从文件中解析语法树时，会包含坐标信息：一个 <code>Position</code> 接口于 <code>position</code> 字段，这用于描述节点在源文件中的位置。</p>
<pre><code class="language-typescript">/**
 * Syntactic units in unist syntax trees are called nodes.
 */
interface Node {
  /**
   * The variant of a node.
   */
  type: string

  /**
   * Information from the ecosystem.
   */
  data?: Data | undefined

  /**
   * Location of a node in a source document.
   * Must not be present if a node is generated.
   */
  position?: Position | undefined
}

/**
 * Information associated by the ecosystem with the node.
 * Space is guaranteed to never be specified by unist or specifications
 * implementing unist.
 */
export interface Data {
  [key: string]: unknown
}

/**
 * Location of a node in a source file.
 */
export interface Position {
  /**
   * Place of the first character of the parsed source region.
   */
  start: Point

  /**
   * Place of the first character after the parsed source region.
   */
  end: Point

  /**
   * Start column at each index (plus start line) in the source region,
   * for elements that span multiple lines.
   */
  indent?: number[] | undefined
}

</code></pre>
<h3><code>字面量(Literal)</code></h3>
<p><code>字面量(Literal)</code> 继承于 <code>节点(Node)</code>，并添加了一个 <code>value</code> 属性。举个例子，一个 markdown <code>Code</code> 节点继承 <code>Literal</code>，并设置 <code>value</code> 为 <code>string</code>。</p>
<pre><code class="language-typescript">/**
 * Nodes containing a value.
 */
export interface Literal extends Node {
  value: unknown
}
</code></pre>
<h3><code>父节点(Parent)</code></h3>
<p><code>父节点(Parent)</code> 继承于 <code>节点(Node)</code>，并添加了一个 <code>子节点(children)</code> 属性。子节点代表其他内容在 <code>父节点(Parent)</code> 内部，或者就是这个节点的一部分。</p>
<pre><code class="language-typescript">/**
 * Nodes containing other nodes.
 */
export interface Parent extends Node {
  /**
   * List representing the children of a node.
   */
  children: Node[];
}
</code></pre>
<h3>在项目中拉取 unist</h3>
<p>安装：</p>
<pre><code class="language-bash">npm install --save-dev @types/unist
</code></pre>
<p>在一个 TypeScript 文件中导入类型，如下：</p>
<pre><code class="language-typescript">import type { Node, Literal, Parent } from 'unist'
</code></pre>
<p>在 <a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html">JSDoc TypeScript</a> 导入类型，如下：</p>
<pre><code class="language-typescript">/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Literal} Literal
 * @typedef {import('unist').Parent} Parent
 */
</code></pre>
<h2>mdast(markdown)</h2>
<p><a href="https://github.com/syntax-tree/mdast">mdast</a> (<strong>m</strong>arkdown <strong>a</strong>bstract <strong>s</strong>yntax <strong>t</strong>ree) 继承于 <a href="https://github.com/syntax-tree/unist">unist</a>，并且为 markdown 具像化类型，例如 <code>Heading</code> <code>Code</code> <code>Link</code> 等。这些具像化的类型包含了一个完整的节点列表。这些类型可以通过一个类型包进行使用。<a href="https://www.npmjs.com/package/@types/mdast"><code>@types/mdast</code></a>。</p>
<p>安装：</p>
<pre><code class="language-bash">npm install --save-dev @types/mdast
</code></pre>
<p>在一个 TypeScript 文件中导入类型，如下：</p>
<pre><code class="language-typescript">import type { Heading, Code, Link } from 'mdast'
</code></pre>
<p>在 <a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html">JSDoc TypeScript</a> 导入类型，如下：</p>
<pre><code class="language-typescript">/**
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('mdast').Code} Code
 * @typedef {import('mdast').Link} Link
 */
</code></pre>
<h2>hast(HTML)</h2>
<p><a href="https://github.com/syntax-tree/hast">hast</a> (<strong>h</strong>ypertext <strong>a</strong>bstract <strong>s</strong>yntax <strong>t</strong>ree) 继承于 <a href="https://github.com/syntax-tree/unist">unist</a>，并且为 HTML 具像化类型，例如 <code>Element</code> <code>Comment</code> <code>DocType</code> 等。这些具像化的类型包含了一个完整的节点列表。这些类型可以通过一个类型包进行使用。<a href="https://www.npmjs.com/package/@types/hast"><code>@types/hast</code></a>。</p>
<p>安装：</p>
<pre><code class="language-bash">npm install --save-dev @types/hast
</code></pre>
<p>在一个 TypeScript 文件中导入类型，如下：</p>
<pre><code class="language-typescript">import type { Element, Comment, DocType } from 'hast'
</code></pre>
<p>在 <a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html">JSDoc TypeScript</a> 导入类型，如下：</p>
<pre><code class="language-typescript">/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Comment} Comment
 * @typedef {import('hast').DocType} DocType
 */
</code></pre>
<h2>xast(XML)</h2>
<p><a href="https://github.com/syntax-tree/xast#readme">xast</a> (e<strong>x</strong>tensible <strong>a</strong>bstract <strong>s</strong>yntax <strong>t</strong>ree) 继承于 <a href="https://github.com/syntax-tree/unist">unist</a>，并且为 XML 具像化类型，例如 <code>Element</code> <code>CData</code> <code>Instruction</code> 等。这些具像化的类型包含了一个完整的节点列表。这些类型可以通过一个类型包进行使用。<a href="https://www.npmjs.com/package/@types/xast"><code>@types/xast</code></a>。</p>
<p>安装：</p>
<pre><code class="language-bash">npm install --save-dev @types/xast
</code></pre>
<p>在一个 TypeScript 文件中导入类型，如下：</p>
<pre><code class="language-typescript">import type { Element, CData, Instruction } from 'xast'
</code></pre>
<p>在 <a href="https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html">JSDoc TypeScript</a> 导入类型，如下：</p>
<pre><code class="language-typescript">/**
 * @typedef {import('xast').Element} Element
 * @typedef {import('xast').CData} CData
 * @typedef {import('xast').Instruction} Instruction
 */
</code></pre>
<h2>总结</h2>
<ul>
<li><a href="https://unifiedjs.com/explore/package/unified/">unified</a> 提供了不同语言的语法树类型</li>
<li>这些类型可以被 TypeScript 和 JSDoc 项目导入</li>
</ul>
<h2>进一步</h2>
<ul>
<li><a href="https://unifiedjs.com/learn/recipe/tree-traversal-typescript/">学习使用 TypeScript 遍历语法树</a></li>
<li><a href="https://unifiedjs.com/learn/recipe/narrow-node-typescript/">学习压缩节点</a></li>
<li><a href="https://unifiedjs.com/learn/recipe/build-a-syntax-tree/">学习构建语法树</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何构建一颗语法树]]></title>
        <id>https://ibert.me/posts/zh/如何构建一颗语法树.html</id>
        <link href="https://ibert.me/posts/zh/如何构建一颗语法树.html"/>
        <updated>2024-03-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://unifiedjs.com/learn/recipe/build-a-syntax-tree/">https://unifiedjs.com/learn/recipe/build-a-syntax-tree/</a></p>
</blockquote>
<p>当添加或者替换内容时，构建一颗新的语法树往往非常实用。使用纯对象和数组字面量(JSON) 或者用一个小工具编程来创建树，是可行的方案。甚至可以使用 JSX 来构建树。</p>
<h2>JSON</h2>
<p>创建树最基本的方法是使用纯对象和数组。为了避免类型问题，可以使用给定语法树语言的类型进行检查，在 <a href="https://github.com/syntax-tree/mdast">mdast</a> 的案例：</p>
<pre><code class="language-typescript">import type { Root } from 'mdast'

// Note the `: Root` is a TypeScript annotation. Remove it (and the import) for plain JavaScript.
const mdast: Root = {
  type: 'root',
  children: [
    {
      type: 'paragraph',
      children: [
        {
          type: 'text',
          value: 'example'
        }
      ]
    }
  ]
}
</code></pre>
<h2><code>unist-builder</code></h2>
<p>也可以使用 <a href="https://unifiedjs.com/explore/package/unist-builder/"><code>unist-builder</code></a> 来构建树。它会使之更加简洁，类 &quot;hyperscript&quot; 的语法(也同样与 <code>React.createElement</code> 类似)：</p>
<pre><code class="language-typescript">import { u } from 'unist-builder'

const mdast = u('root', [
  u('paragraph', [
    u('text', 'example')
  ])
])
</code></pre>
<h2><code>hastscript</code></h2>
<p>当使用 <a href="https://github.com/syntax-tree/hast">hast</a> (HTML) 时，可以使用 <a href="https://unifiedjs.com/explore/package/hastscript/"><code>hastscript</code></a>。</p>
<pre><code class="language-typescript">import { h, s } from 'hastscript'

console.log(
  h('div#some-id.foo', [
    h('span', 'some text'),
    h('input', {type: 'text', value: 'foo'}),
    h('a.alpha.bravo.charlie', {download: true}, 'delta')
  ])
)

// SVG:
console.log(
  s('svg', {xmlns: 'http://www.w3.org/2000/svg', viewbox: '0 0 500 500'}, [
    s('title', 'SVG `&lt;circle&gt;` element'),
    s('circle', {cx: 120, cy: 120, r: 100})
  ])
)
</code></pre>
<p><code>hastscript</code> 也可以用作 JSX 配置注释：</p>
<pre><code class="language-jsx">/** @jsx h @jsxFrag null */
import { h } from 'hastscript'

console.log(
  &lt;form method=&quot;POST&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;foo&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;bar&quot; /&gt;
    &lt;input type=&quot;submit&quot; name=&quot;send&quot; /&gt;
  &lt;/form&gt;
)
</code></pre>
<h2><code>xastscript</code></h2>
<p>当使用 <a href="https://github.com/syntax-tree/xast">xast</a> (XML) 时，可以使用 <a href="https://unifiedjs.com/explore/package/xastscript/"><code>xastscript</code></a>。</p>
<pre><code class="language-typescript">import { x } from 'xastscript'

console.log(
  x('album', {id: 123}, [
    x('name', 'Exile in Guyville'),
    x('artist', 'Liz Phair'),
    x('releasedate', '1993-06-22')
  ])
)
</code></pre>
<p><code>xastscript</code> 也可以用作 JSX 配置注释：</p>
<pre><code class="language-jsx">/** @jsx x @jsxFrag null */
import { x } from 'xastscript'

console.log(
  &lt;album id={123}&gt;
    &lt;name&gt;Born in the U.S.A.&lt;/name&gt;
    &lt;artist&gt;Bruce Springsteen&lt;/artist&gt;
    &lt;releasedate&gt;1984-04-06&lt;/releasedate&gt;
  &lt;/album&gt;
)
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[为HomeAssistant创建一个自定义组件]]></title>
        <id>https://ibert.me/posts/zh/为HomeAssistant创建一个自定义组件.html</id>
        <link href="https://ibert.me/posts/zh/为HomeAssistant创建一个自定义组件.html"/>
        <updated>2024-03-24T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>前言</h2>
<p>关于 Home Assistant 的顶级玩法，可以去看看我的b站视频合集 <a href="https://space.bilibili.com/137683614/channel/collectiondetail?sid=2050382">Home Assistant顶级玩法</a></p>
<blockquote>
<p>本教程为 Home Assistant 社区的文章翻译，原文链接为：<a href="https://community.home-assistant.io/t/tutorial-for-creating-a-custom-component/204793">https://community.home-assistant.io/t/tutorial-for-creating-a-custom-component/204793</a>，作者：Aaron Godfrey。</p>
</blockquote>
<p>下面是原作者的帖子内容：</p>
<blockquote>
<p>我开始了一个如何为 HomeAssistant 创建自定义组件的教程。<a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_1/">https://aarongodfrey.dev/home automation/building_a_home_assistant_custom_component_part_1/</a><br>
想要获得一些反馈，看看其中的一些内容是否有用，或者我是否忽略了一些显而易见的东西。</p>
</blockquote>
<ul>
<li><a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_1/">第一部分 如何创建一个基础集成(integration)</a></li>
<li><a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_2/">第二部分 讨论单元测试和持续集成</a></li>
<li><a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_3/">第三部分 重点添加一个配置流(Config Flow)</a></li>
<li><a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_4/">第四部分 重点添加一个选项流(Options Flow)</a></li>
<li><a href="https://aarongodfrey.dev/home%20automation/building_a_home_assistant_custom_component_part_5/">第五部分 讨论使用 devcontainer 进行调试</a></li>
</ul>
<h2>构建一个 Home Assistant 自定义组件</h2>
<h2>第一部分：项目结构和基础</h2>
<h3>介绍</h3>
<p>这个系列的文章为一个教程，旨在教会我们为 Home Assistant 创建一个自定义组件。我们将从一个组件骨架开始，然后在每篇教程里添加内容。在本系列教程文章的最后，你将会拥有一个完整的功能组件，至少可以在 <a href="https://developers.home-assistant.io/docs/integration_quality_scale_index/">集成质量衡量(Integration Quality Scale)</a> 中拿到 Sliver 级别的分数。</p>
<p>在这个项目中，我们将使用 <a href="https://developer.github.com/v3/">GitHub API</a> 来为我们的组件提供数据。这已经有一个存在的 <a href="https://www.home-assistant.io/integrations/github/">GitHub 集成</a>，但我们将自己去实现并尝试去通过单元测试去提升这个已有的组件质量。可以通过 UI 来进行配置，并添加一些实用的功能。</p>
<p>每篇文章都是 <a href="https://github.com/boralyl/github-custom-component-tutorial">GitHub 仓库</a> 的不同分支。所以你可以在自己的编辑器中跟随学习，或者浏览适当分支中的代码。此部分的更改都可以在 <a href="https://github.com/boralyl/github-custom-component-tutorial/compare/feature/bare-repo...feature/part1?expand=1">feature/part1 分支</a> 中查阅。</p>
<p>我建议去查阅官方的 <a href="https://developers.home-assistant.io/">开发者文档</a>，从 Home Assistant 架构中的概念获得一些灵感。</p>
<h3>项目结构</h3>
<p>一开始，我们需要为自定义组件生成基础的文件。幸运的是，通过 <a href="https://github.com/boralyl/cookiecutter-homeassistant-component">cookiecutter project template</a> 项目做这件事很容易。</p>
<p>让我们安装 <a href="https://github.com/cookiecutter/cookiecutter">cokkiecutter</a>，并且通过问答的方式创建我们的工程。</p>
<pre><code class="language-text">$ pip install cookiecutter
$ cookiecutter https://github.com/boralyl/cookiecutter-homeassistant-component
domain [my_component]: github_custom
name [My Component]: Github Custom
docs_url [https://github.com/user/my_component/]: https://github.com/boralyl/github-custom-component-tutorial
owner [@user]: @boralyl
Select config_flow:
1 - yes
2 - no
Choose from 1, 2 [1]: 2
Select iot_class:
1 - Assumed State
2 - Cloud Polling
3 - Cloud Push
4 - Local Polling
5 - Local Push
Choose from 1, 2, 3, 4, 5 [1]: 2
</code></pre>
<blockquote>
<p>注意：一开始我们跳过了使用配置流(Config Flow)。我们将在教程的后续文章中添加这部分功能。</p>
</blockquote>
<p><img src="https://aarongodfrey.dev/assets/images/0012_project_tree.png" alt="项目结构树"></p>
<p>现在我们忽略根目录文件夹下的文件和测试文件夹。让我们关注 <code>custom_components</code> 和<code>github_custom</code> 文件夹。<a href="https://developers.home-assistant.io/docs/creating_integration_manifest">manifest.json</a> 包含了一些我们这个组件的基础信息，Home Assistant 在加载的时候会用到。<code>const.py</code> 只包含了我们的常量，在这个案例中，我们只有组件的 <a href="https://developers.home-assistant.io/docs/creating_integration_manifest#domain">DOMAIN</a>。<code>__init__.py</code> 包含了 <code>async_setup</code> 方法，用于 Home Assistant 加载我们的组件。</p>
<p>此时自定义组件是合法的，如果你放在自己的 Home Assistant <code>config</code> 目录下，Home Assistant 会正常加载，并不会实际创建任何实体(entities)。</p>
<h3>实现组件</h3>
<p>现在，是时候开始编写我们的组件了。有四个基本部分去实现。</p>
<ol>
<li>在 <code>manifest.json</code> 添加我们的 requrements。如果我们需要添加额外的 python 依赖，就需要在这添加。</li>
<li>添加我们自己的配置规则。将用于定义我们希望用户添加进他们的 <code>configuration.yaml</code> 文件的值。</li>
<li>在 Home Assistant 中注册我们所有的传感器。将在 <code>async_setuo_platform</code> 函数中进行实现。</li>
<li>创建一个实体，用于代表我们希望手收集关于 GitHub 仓库的状态和数据。这个实体也应该实现 <code>async_update</code> 方法，从 GitHub 来更新数据。</li>
</ol>
<p>这四处的最终实现，可以看这个 <a href="https://github.com/boralyl/github-custom-component-tutorial/compare/feature/bare-repo...feature/part1?expand=1">diff</a>。在这个 diff 中需要注意的是，我从 <code>__init__.py</code> 中移除了 <code>async_setup</code> 函数。因为我们集成使用了 platform，所以我们可以移除这部分的代码。这些 platforms 允许你在集成中拥有多个实例，而不是仅一个。如果你正在同时监控公共仓库和一些使用 GitHub Enterprise 服务的私有仓库，是非常有用的。</p>
<h3>向 manifest.json 添加 requirements</h3>
<p>我们将使用 <a href="https://github.com/brettcannon/gidgethub">gidgethub</a> 库来与 GitHub API 进行交互。它支持开箱即用的异步通信，可以非常简单直接使用。</p>
<pre><code class="language-diff">  &quot;documentation&quot;: &quot;https://github.com/boralyl/github-custom-component-tutorial&quot;,
  &quot;domain&quot;: &quot;github_custom&quot;,
  &quot;name&quot;: &quot;Github Custom&quot;,
-  &quot;requirements&quot;: []
+  &quot;requirements&quot;: [&quot;gidgethub[aiohttp]==4.1.1&quot;]
}
</code></pre>
<p>我们向 <code>requirements</code> 数组添加了指定版本的依赖。值得注意的是，指定一个异步库是可选的。为了保证这些依赖被正确安装，我们需要额外在 requirement 中额外指定 <code>aiohttp</code>。</p>
<h3>platform 配置方案</h3>
<p>对于我们的 platform 配置方案来说，我们需要根据官方的 <a href="https://www.home-assistant.io/integrations/github/">GitHub 集成</a> 来实现。下面是一个基础的示例：</p>
<pre><code class="language-yaml"># Example configuration.yaml entry
sensor:
  - platform: github_custom
    access_token: !secret github_access_token
    repositories:
      - path: &quot;home-assistant/core&quot;
        name: &quot;Home Assistant Core&quot;
      - path: &quot;boralyl/steam-wishlist&quot;

  - platform: github_custom
    url: https://my.enterprisegithubserver.com
    access_token: !secret github_access_token
    repositories:
      - path: &quot;company/some-repo&quot;
</code></pre>
<p>我们不需要去修改任何内容，所以配置方案与官方集成的完全一致：</p>
<pre><code class="language-text">REPO_SCHEMA = vol.Schema(
    {vol.Required(CONF_PATH): cv.string, vol.Optional(CONF_NAME): cv.string}
)

PLATFORM_SCHEMA = PLATFORM_SCHEMA.extend(
    {
        vol.Required(CONF_ACCESS_TOKEN): cv.string,
        vol.Required(CONF_REPOS): vol.All(cv.ensure_list, [REPO_SCHEMA]),
        vol.Optional(CONF_URL): cv.url,
    }
)
</code></pre>
<p>上面的内容非常直观。我们需要一个 access token和一个仓库列表。每个仓库必须拥有 <code>path</code> 键，并且可以可选有一个 <code>name</code> 键。我们也可选地允许 <code>url</code> 键，用于指定 GitHub Enterprise 服务器的 URL。</p>
<p>上面的代码本质上扩展了 Home Assistant platform 配置方案，添加了我们自己的域名 <code>github_custom</code>。它将为我们处理认证和展示适当的错误。</p>
<h3>注册传感器(sensors)</h3>
<p>下一步注册我们所有的传感器。将为在 platform 配置中的每一个仓库创建一个传感器。习惯上，Home Assistant 会查看你 <code>sensor.py</code> 文件中的 <code>setup_platform</code> 或者 <code>async_setup_platform</code> 函数。如果你的数据通过库来更新，使用 <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> 来异步获取数据，那就需要使用 <code>async_setup_platform</code> 函数，否则应该创建 <code>setup_platform</code> 函数。自我们使用 <a href="https://github.com/brettcannon/gidgethub/">gidgethub</a> 库，他就支持异步，所以我们使用 <code>async_setup_platform</code> 函数。</p>
<pre><code class="language-python">async def async_setup_platform(
    hass: HomeAssistantType,
    config: ConfigType,
    async_add_entities: Callable,
    discovery_info: Optional[DiscoveryInfoType] = None,
) -&gt; None:
    &quot;&quot;&quot;Set up the sensor platform.&quot;&quot;&quot;
    session = async_get_clientsession(hass)
    github = GitHubAPI(session, &quot;requester&quot;, oauth_token=config[CONF_ACCESS_TOKEN])
    sensors = [GitHubRepoSensor(github, repo) for repo in config[CONF_REPOS]]
    async_add_entities(sensors, update_before_add=True)
</code></pre>
<p>在这个函数中，我们首先恢复了一个 aiohttp 客户端会话。这个帮助函数关注于为我们恢复和关闭会话（少了一件需要考虑的事情）。我们初始化了 GitHub API 客户端，并为在我们的 <code>configuration.yaml</code> 中指定的每个仓库创建了一个 <code>GitHubRepoSensor</code>。</p>
<p><code>async_add_entities</code> 函数将会处理在 Home Assistant 中添加和注册这些传感器。第二个参数也值得注意。将它设置为 <code>True</code> 的时候，是告诉 Home Assistant 应该在集成完成加载之后进行数据更新。没有这项配置（或者将它设置为 <code>False</code>），它将等待直到 <code>SCAN_INTERVAL</code> 的时候再从 GitHub 获取数据。这个常量被设置为 10 分钟，意味着在 Home Assistant 重启之后的十分钟，我们的传感器是没有数据的。（或者，它将在恢复重新启动之前的上一次更新的数据）</p>
<h3>GitHub 仓库传感器实体和 async_update</h3>
<p>上一部分我们定义了组件的实体和指定了一个更新方法。简而言之，并没有包含完整的类（的代码），但你可以在 <a href="https://github.com/boralyl/github-custom-component-tutorial/blob/3ee4d35f4bb08ec92098e7932fd4ae29ef59591f/custom_components/github_custom/sensor.py#L98-L212">GitHub</a> 中查看。</p>
<p>最主要的部分是它继承了 <code>homeassistant.helpers.entity.Entity</code>，这个类为你实现了必要的逻辑。我们定义自己的返回传感器的 <code>状态(state)</code> 属性。这个传感器，我们将使用 commit sha 的前7个字符。我们也定义了一个返回和状态相关的 <code>device_state_attributes</code> 的属性，可以被自动化(automations) 和 lovelace UI 所使用。</p>
<p>我们的自定义传感器类必须指定一个 <code>update</code> 或者 <code>async_update</code> 方法，为了从 GitHub 获取数据用于更新 state 和 device_state_attributes。再者，我们的组件使用了一个支持异步的库，包含了 <code>async_update</code> 方法，用于从 GitHub 获取需要的数据。Home Assistant 将基于我们定义的间隔调用这个方法，习惯上去寻找一个叫做 <code>SCAN_INTERVAL</code> 的常量。如果你在自己的文件中定义了它，它的值是一个 <code>datetime.timedelta</code> 实例。我们为自己的组件使用10分钟作为更新的间隔。</p>
<pre><code class="language-python">SCAN_INTERVAL = timedelta(minutes=10)
</code></pre>
<h3>结语</h3>
<p>我们现在有了一个完整功能的异步自定义组件，是官方集成的提升版。</p>
<p>在后面的文章中，我们将简单的讨论如何去为帮助提升自定义组件，来添加单元测试和捕获 bugs。我们也会使用 <a href="https://github.com/features/actions">GitHub Actions</a> 来为自定义组件添加持续集成。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建一个unified插件]]></title>
        <id>https://ibert.me/posts/zh/创建一个unified插件.html</id>
        <link href="https://ibert.me/posts/zh/创建一个unified插件.html"/>
        <updated>2024-03-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>原文 <a href="https://unifiedjs.com/learn/guide/create-a-plugin/">Creating a plugin with unified</a></p>
</blockquote>
<p>本教程展示了如何为 <a href="https://unifiedjs.com/explore/project/retextjs/retext/">retext</a> 创建一个插件用于检测句子之间的空格数量。这里的概念也适用于 <a href="https://unifiedjs.com/explore/package/unified/">unified</a> 的其他语法。</p>
<blockquote>
<p>在这卡住了？想去看看其他的教程吗？参阅 <a href="https://github.com/unifiedjs/.github/blob/main/support.md">support.md</a></p>
</blockquote>
<h2>插件基础</h2>
<p><a href="https://unifiedjs.com/explore/package/unified/">unified</a> 插件在几个方面改变了应用处理器(processor) 的工作方式。在这篇教程中，我们将检阅(review) 如何检查语法树。</p>
<p>插件包含两部分： attacher，一个被 <code>.use</code> 方法调用的函数；transformer，一个当每次文件被通过语法树和虚拟文件处理时调用的可选函数。</p>
<p>在这个案例中，我们想检查每个被处理文件的语法树，所以我们确实需要指定一个 transformer。</p>
<p>现在你知道了 <a href="https://unifiedjs.com/explore/package/unified/">unified</a> 插件的基础组成。开始我们的案例吧！</p>
<h2>案例</h2>
<p>在开始之前，先明确我们需要实现什么样的效果。有以下的文本文件：</p>
<pre><code class="language-text">One sentence. Two sentences.

One sentence.  Two sentences.
</code></pre>
<p>我们想在第二段获得一个警告，说明句子之间应该用一个空格，而不是两个。</p>
<p>下一步，将编写代码来使用我们的插件。</p>
<h2>配置</h2>
<p>让我们配置一个工程。创建文件夹 <code>example</code>，进入它，并创建一个新的工程。</p>
<pre><code class="language-bash">mkdir example
cd example
npm init -y
</code></pre>
<p>然后，确保这个工程是一个 module，以保证 <code>import</code> 和 <code>export</code> 的正常工作。通过修改 <code>package.json</code> 实现：</p>
<pre><code class="language-diff">--- a/package.json
+++ b/package.json
@@ -2,6 +2,7 @@
   &quot;name&quot;: &quot;example&quot;,
   &quot;version&quot;: &quot;1.0.0&quot;,
   &quot;description&quot;: &quot;&quot;,
+  &quot;type&quot;: &quot;module&quot;,
   &quot;main&quot;: &quot;index.js&quot;,
   &quot;scripts&quot;: {
     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
</code></pre>
<p>确保 <code>example.md</code> 文件存在，并且内容如下：</p>
<pre><code class="language-text">One sentence. Two sentences.

One sentence.  Two sentences.
</code></pre>
<p>现在，我们创建一个 <code>example.js</code> 文件，将用于处理我们的文本文件，并报告一些发现的问题.</p>
<pre><code class="language-js">import fs from 'fs'
import {retext} from 'retext'
import {reporter} from 'vfile-reporter'
import retextSentenceSpacing from './index.js'

const buffer = fs.readFileSync('example.md')

retext()
  .use(retextSentenceSpacing)
  .process(buffer)
  .then((file) =&gt; {
    console.error(reporter(file))
  })
</code></pre>
<blockquote>
<p>不要忘记去 <code>npm install</code> 依赖 (<code>retext</code>, <code>vfile-reporter</code>)！</p>
</blockquote>
<p>如果你阅读 <a href="https://unifiedjs.com/learn/guide/using-unified/">使用 unified</a> 教程，将会发现一些类似的语句。首先，我们加载了依赖项，然后读取了文件。我们使用了将在第二步创建的插件对文件进行处理，最后报告一个致命错误，或者被发现的一些规范化消息。</p>
<p>注意我们直接依赖 <a href="https://unifiedjs.com/explore/project/retextjs/retext/">retext</a>。这个包暴露了一个 <a href="https://unifiedjs.com/explore/package/unified/">unified</a> 处理器，并附带了解析器(parser) 和编译器(compiler)。</p>
<p>当运行我们的示例之时（它现在还不能工作）我们希望看到第二段的一条消息，告诉应该用一个空格取代两个空格。</p>
<p>现在我们配置完成了除了插件本身的所有部分。我们将在下一章节进行实现。</p>
<h2>插件</h2>
<p>当我们阅读了插件基础的部分，我们知道了需要一个插件，并且我们的案例需要一个 transformer。让我们开始在插件文件 <code>index.js</code> 中创建他们吧：</p>
<pre><code class="language-js">export default function retextSentenceSpacing() {
  return (tree, file) =&gt; {
  }
}
</code></pre>
<p>首先要做的事情是，我们需要检查 <code>tree</code> 的数据样式。可以使用名为 <a href="https://unifiedjs.com/explore/package/unist-util-visit/">unist-util-visit</a> 的工具帮助我们递归树结构。现在让我们添加它。</p>
<pre><code class="language-diff">--- a/index.js
+++ b/index.js
@@ -1,4 +1,9 @@
+import {visit} from 'unist-util-visit'
+
 export default function retextSentenceSpacing() {
   return (tree, file) =&gt; {
+    visit(tree, 'ParagraphNode', (node) =&gt; {
+      console.log(node)
+    })
   }
 }
</code></pre>
<blockquote>
<p>不要忘了去 <code>npm install</code> 这个工具！</p>
</blockquote>
<p>如果我们现在使用 Node.js 运行我们的示例，正如下面展示的，将看见在我们的示例中的两个段落调用了观察者(visitor)：</p>
<pre><code class="language-bash">node expample.js
</code></pre>
<pre><code class="language-text">{
  type: 'ParagraphNode',
  children: [
    { type: 'SentenceNode', children: [Array], position: [Object] },
    { type: 'WhiteSpaceNode', value: ' ', position: [Position] },
    { type: 'SentenceNode', children: [Array], position: [Object] }
  ],
  position: {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 29, offset: 28 }
  }
}
{
  type: 'ParagraphNode',
  children: [
    { type: 'SentenceNode', children: [Array], position: [Object] },
    { type: 'WhiteSpaceNode', value: '  ', position: [Position] },
    { type: 'SentenceNode', children: [Array], position: [Object] }
  ],
  position: {
    start: { line: 3, column: 1, offset: 30 },
    end: { line: 3, column: 30, offset: 59 }
  }
}
no issues found
</code></pre>
<p>输出内容展示了段落包含两种类型的节点(nodes)：<code>SentenceNode</code> 和 <code>WhiteSpaceNode</code>。后者是我们想要去检查的，但是前者是重要的，因为在这个插件中我们只想在句子之间的地方警告空白空格。（不过，这可能是另一个可以实现的插件）</p>
<p>现在循环每个段落的子节点。只检查句子之间的空白空格。我们使用一个小工具来检查节点的类型：<a href="https://unifiedjs.com/explore/package/unist-util-is/"><code>unist-util-is/</code></a>。</p>
<pre><code class="language-diff">--- a/index.js
+++ b/index.js
@@ -1,9 +1,20 @@
 import {visit} from 'unist-util-visit'
+import {is} from 'unist-util-is'

 export default function retextSentenceSpacing() {
   return (tree, file) =&gt; {
     visit(tree, 'ParagraphNode', (node) =&gt; {
-      console.log(node)
+      const children = node.children
+
+      children.forEach((child, index) =&gt; {
+        if (
+          is(children[index - 1], 'SentenceNode') &amp;&amp;
+          is(child, 'WhiteSpaceNode') &amp;&amp;
+          is(children[index + 1], 'SentenceNode')
+        ) {
+          console.log(child)
+        }
+      })
     })
   }
 }
</code></pre>
<blockquote>
<p>不要忘记去 <code>npm install</code> 这个工具！</p>
</blockquote>
<p>如果现在运行我们的示例，我们将会看到仅句子之间的空白空格被记录。</p>
<pre><code class="language-bash">node example.js
</code></pre>
<pre><code class="language-text">{
  type: 'WhiteSpaceNode',
  value: ' ',
  position: Position {
    start: { line: 1, column: 14, offset: 13 },
    end: { line: 1, column: 15, offset: 14 }
  }
}
{
  type: 'WhiteSpaceNode',
  value: '  ',
  position: Position {
    start: { line: 3, column: 14, offset: 43 },
    end: { line: 3, column: 16, offset: 45 }
  }
}
no issues found
</code></pre>
<p>最后，我们在为第二个空白空格添加警告，表示它实际拥有字符超过了所需的。我们使用 <a href="https://unifiedjs.com/explore/package/vfile/#vfilemessagereason-position-origin"><code>file.message()</code></a> 方法将文件和消息联系在一起。</p>
<pre><code class="language-diff">--- a/index.js
+++ b/index.js
@@ -12,7 +12,12 @@ export default function retextSentenceSpacing() {
           is(child, 'WhiteSpaceNode') &amp;&amp;
           is(children[index + 1], 'SentenceNode')
         ) {
-          console.log(child)
+          if (child.value.length !== 1) {
+            file.message(
+              'Expected 1 space between sentences, not ' + child.value.length,
+              child
+            )
+          }
         }
       })
     })
</code></pre>
<p>如果我们现在最后一次运行示例，我们将看见问题的一条警告消息。</p>
<pre><code class="language-text">$ node example.js
3:14-3:16  warning  Expected 1 space between sentences, not 2

⚠ 1 warning
</code></pre>
<h2>进一步练习</h2>
<p>在句子之间的一个空格并不适用于所有人。这个插件接收想要的空格数量，来替代硬编码 <code>1</code>。</p>
<p>如果你想要警告句子之间的缩进或者新行，也可以创建一个插件？</p>
<p>如果你还没准备好，可以看看 <a href="https://unifiedjs.com/learn/">学习章节</a> 的其他文章。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于 canvas-editor RTL 实现的挑战]]></title>
        <id>https://ibert.me/posts/zh/基于canvas-editor的RTL实现的挑战.html</id>
        <link href="https://ibert.me/posts/zh/基于canvas-editor的RTL实现的挑战.html"/>
        <updated>2024-03-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>前言</h2>
<p>众所周知，在前端领域实现富文本编辑器是一个深坑，是非常复杂的问题，markdown 编辑器在一定程度上也是富文本编辑器。简要介绍一下，富文本编辑器的实现方式上，一般有以下的实现方案：</p>
<ul>
<li>纯文本：textarea 标签</li>
<li>富文本：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable">contenteditable</a></li>
<li>富文本：利用 canvas、svg 进行渲染</li>
</ul>
<p>本篇不讨论这种方案的实现差异，只讨论基于 canvas 的 canvas-editor 的 RTL 实现挑战，内容主要与 canvas 的实操有关。</p>
<h2>RTL 实现的挑战</h2>
<h3>预置概念</h3>
<p>由于 canvas 是依赖 <code>[x, y]</code> 坐标来绘制图形或文字，但在 <code>ctx.direction='rtl'</code> 的模式下，canvas 对于图形和文字的处理并不一致，所以为了简化绘制流程的原理解释，这里定义一些预置概念：</p>
<table>
<thead>
<tr>
<th>概念名称</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>基点坐标</td>
<td>指的是绘制 canvas 内容的绝对原点坐标，此坐标决定了 canvas 结构内容绘制的 x, y 轴的基线</td>
</tr>
<tr>
<td>偏移坐标</td>
<td>指的是相对于基点的偏移量，根据基点坐标和偏移情况，即可计算出图形和文字的实际坐标</td>
</tr>
<tr>
<td>对称坐标</td>
<td>指的是在 RTL 情况下，<code>ctx.direction='rtl'</code> 相对的是从基点反方向绘制文字，因此需要更改基点位置，从而实现从行初到行尾的坐标转换 ，其关于基点 y 轴与偏移坐标轴对称</td>
</tr>
<tr>
<td>镜像坐标</td>
<td>指的是在 RTL 情况下，<code>ctx.direction='rtl'</code> 并不会反方向绘制图形，因此相对于对称坐标需要进行镜像处理，即 <strong>在对称坐标的基础上减去绘制元素的宽度</strong></td>
</tr>
</tbody>
</table>
<h3>canvas-editor 的绘制原理</h3>
<p>canvas-editor 的绘制原理，总的来说，即:</p>
<ul>
<li>计算画布大小</li>
<li>计算减去内边距得到可绘制区域大小</li>
<li>计算每行承载元素和元素坐标</li>
<li>根据元素坐标逐个绘制文字</li>
<li>根据 underline、strikeout 等特殊属性绘制图形</li>
</ul>
<p>按照现阶段的 canvas-editor 绘制来说，除了文本做了合并优化绘制处理之外，完全可以视为逐个元素绘制</p>
<h3>RTL 的挑战</h3>
<p>为 canvas-editor 支持 RTL，是因为目前完全没见过做前端富文本编辑器的可以完美支持 RTL（尤其是基于 canvas 的）。</p>
<p>富文本编辑器无疑是开发里的深坑，即使是相当成熟的商业软件对于 RTL 的支持也很差。在适配上，html dom 可以通过 attribute 的 <code>dir</code> 进行适配实现，但是在 canvas 中，无异于是需要自己实现一遍浏览器的 reflow、repaint 机制。</p>
<p>关于 RTL 实现碰到的各种问题，可以参考 <a href="https://github.com/Hufe921/canvas-editor/issues/451">编辑器支持rtl渲染 #451</a></p>
<p>目前在 forked 仓库的 <a href="https://github.com/HerbertHe/canvas-editor/tree/feature/rtl">feature/rtl</a> 分支进行实现。</p>
<p>下面是发现和解决的一些问题：</p>
<ul>
<li>文字样式改变渲染的绘制逻辑造成不正确的排列</li>
</ul>
<blockquote>
<p><a href="https://github.com/Hufe921/canvas-editor/issues/457">Date 渲染存在缺陷 #457</a></p>
</blockquote>
<p>在 Date 渲染和 hyperlink 的渲染中都存在这个问题。源码在 <code>dateParticle.render</code> 和 <code>hyperlinkParticle.render</code> 的实现中，文本的绘制没有交给 <code>textParticle.render</code> 进行完成，而是直接使用 <code>ctx.fillText</code> 进行绘制。导致在 RTL 情况下，文本的绘制并没有 LTR 字符连续绘制，而是单个文字绘制；也同样会导致 RTL 和 LTR 混排字符出现问题。</p>
<p>具体的示例和原理，可以参考我的这个PR <a href="https://github.com/Hufe921/canvas-editor/pull/460">refactor: date renderer</a></p>
<p>涉及到文本的渲染，在原则上应该全部交给 <code>textParticle.render</code> 进行处理，才可以保证对文本内容绘制顺序的可控性。</p>
<p>但这对于实现 Date、hyperlink 等格式文本的合并绘制是远远不够的，这涉及到了 RTL 的绘制位置排序问题。</p>
<ul>
<li>RTL 默认绘制的排序</li>
</ul>
<p>在 <code>ctx.direction='rtl'</code> 的情况下，canvas 的绘制顺序是：<strong>总体保持 RTL 顺序，LTR 连续绘制，而标点符号的绘制受下一个字符的类型影响，绘制起始坐标为新的基点坐标。</strong></p>
<p>但上面的合并文本绘制策略，并不能解决合并后的文本字符串的排序问题。目前 <code>ctx.fillText</code> 的样式会因为文本样式的不同而打断文本绘制的进程，不同样式格式的文本是分步绘制的，需要依赖正确的坐标顺序。</p>
<p>因此，在借助 <code>ctx.direction='rtl'</code> 进行文本绘制之前，还需要对文本进行重新排序。实现原理为：<strong>将文本按照格式打断分割完成之后，再对绘制的起始点坐标进行重新计算交换，以实现正确的绘制坐标点，从而混合 canvas 的自身绘制顺序进行绘制。</strong></p>
<ul>
<li>RTL 的坐标计算</li>
</ul>
<p>正如之前所说的，因为 <code>ctx.direction='rtl'</code> 根本无法影响图形的绘制，所以文本和非文本的绘制坐标计算是不一致的。<strong>文本的实际坐标</strong>，即之前所说的偏移坐标，通过更改基点坐标的位置实现重置起始点。<strong>但绘制坐标为对称坐标</strong>，为 canvas 自行处理之后的实际绘制位置，是关于基点坐标的 y 轴对称的。</p>
<p>非文本的坐标为 <code>文本对称坐标 - 文本实际宽度</code>， canvas 的图形绘制只能通过 LT (Left Top) 点进行绘制。其绘制坐标的位置与文本的位置在 LTR 时存在实际的偏移，需要被纠正计算。</p>
<p>highlight、underline、strikeout 的计算，都是通过这个来进行实现的。</p>
<p>因此也导致了新的问题产生：mousedown 和 command 等的默认操作存在偏差。</p>
<ul>
<li>mousedown 等事件的处理</li>
</ul>
<p>canvas-editor 默认的 mousedown 等鼠标监听事件是通过偏移坐标实现的，但在 RTL 下带来了新的问题。当判断鼠标与文本元素的碰撞检测之时，用的应该是文本的对称坐标，而不是偏移坐标。文本是反向进行绘制的，计算 RTL 下的实际坐标才能精确定位光标的位置，从而进行操作。</p>
<ul>
<li>range 的修正</li>
</ul>
<p>由于在 RTL 下需要对文本进行重新排队绘制，因此原本的 range 记录的方式不再适用。canvas-editor 的 range 通过元素的索引进行实现，在 LTR 的情况下不存在问题；但 RTL 下进行重新排队之后，range 的记录应该为实际的元素及坐标，而非索引，通过索引进行计算会导致错误的元素选区问题。</p>
<p>而 range 的错误选区，会导致后面一系列的绘制问题，依赖 range 的二次操作非常多。</p>
<ul>
<li>上下角标的绘制问题</li>
</ul>
<p>上下角标应该是强制 LTR 的，需要在文本排序的时候，强制实现 LTR 的绘制渲染。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于 AC+AP 打造安全的家庭 WiFi 网络]]></title>
        <id>https://ibert.me/posts/zh/基于AC+AP打造安全的家庭WiFi网络.html</id>
        <link href="https://ibert.me/posts/zh/基于AC+AP打造安全的家庭WiFi网络.html"/>
        <updated>2023-11-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>在家使用 WiFi，并且在此基础上搭建智能家居，已变得越来越潮流化。但打造一个稳定的智能家居环境，并不是一个十分容易的事情，靠谱的网络环境决定了整套系统是否可以稳定运行。</p>
<p>本篇着重讲解基于 <strong>锐捷 ac+ap</strong> 组合的家庭网络设计思路，并且在此基础上介绍家庭网络的网络安全策略。本篇使用的 <strong>锐捷 ac+ap</strong> 方案只是刚好采用了锐捷的设备，非带货广告。还有其他的解决方案，比如：基于 TP-LINK、华为、小米的 Mesh 组网方案。</p>
<p>本篇采用的设备为：</p>
<ul>
<li>AC：锐捷 EG110G-P</li>
<li>AP：锐捷 EAP162（E）</li>
</ul>
<blockquote>
<p>如果网络布线提前考虑到了天花板吸顶 AP，可以选择锐捷的 EAP262（E）。视家庭所需进行更高性能、更贵设备的选择，本方案可以支持最大 1000Mbps 的带宽接入。</p>
</blockquote>
<h2>为什么选择 AC+AP 的方案</h2>
<p>在家装进行布线的时候，就需要考虑整个网络情况的规划。针对于不同小区的建筑材料实际情况，WiFi 的穿墙能力是很不一定的，其信号强度也严重影响到了传输速率（俗称网速）。</p>
<p>一般家庭网络的拓扑，即 <code>运营商光纤 -&gt; 运营商光猫 -&gt; 家庭各路由</code>。<strong>还可能直接把路由器直接塞到弱电箱内，甚至直接用的运营商光猫的 WiFi 信号，这对于充分发挥宽带的性能是非常不利的。</strong> 因此，我更倾向于在使用 WiFi 的情况下，也要跑满宽带的极限速率。</p>
<p>对于智能家居来说，全家庭网络单一 <strong>SSID（可以理解为：WiFi的名称）</strong> 对于网络体验上会非常的好，尤其是将 <strong>米家、华为、美的等家庭智能设备</strong> 接入到 WiFi，这一点更是格外重要。因为网络一旦发生改动，比如：更换路由器、路由器信号差等问题。智能家居设备很可能要重新配置所有的网络侧信息，然后一个个重置后加入控制系统，又麻烦、又费精力。</p>
<p>上面的 <code>单一SSID</code> 的问题，在常规上我们可以使用多个路由器的 <strong>无线桥接</strong> 进行实现，但是始终无法解决 WiFi 网速达不到实际的宽带素质。</p>
<ul>
<li>Mesh：家庭最简单的组网方案，比如：各大厂家的 Mesh 路由器，华为 Q6 子母套装。</li>
<li>AC+AP：更加通用、高阶的组网方案，属于企业级解决方案。</li>
</ul>
<p>如果不想折腾，也没有什么特别的需求。Mesh 可以视为简化版的 AC+AP，这两种方式都可以进行 <strong>统一的SSID、WiFi 无感漫游</strong>，可以选择 Mesh 组网进行家庭网络的部署；但是，如果对网络稳定性、扩展性、带机量、信号覆盖等有更高的需求，最终的选择还是 <strong>AC+AP</strong> 的方案。</p>
<p>针对家庭网络的选择问题，前面铺垫了很多，比较不同方案的区别还是很大的。</p>
<p>Mesh vs AC+AP：</p>
<p>优点：</p>
<ul>
<li>容易部署</li>
<li>价格更低</li>
</ul>
<p>缺点：</p>
<ul>
<li>带机量少</li>
<li>价格并没有太低</li>
<li>不可以隐藏式部署</li>
<li>稳定性不如 AC+AP</li>
<li>无法解决进阶的玩法</li>
<li>对于面积过大的场景受限</li>
</ul>
<h2>家庭网络部署</h2>
<p>选择 <strong>ac+ap</strong> 方案的绝大多数消费者，可能都会考虑到 <strong>隐藏式部署</strong> 的问题，因为 ac 可以直接塞到信息箱中（ac 不发射 WiFi 信号），ap 可以直接塞到预留的86面板中，只需要一根网线进行 PoE 供电，就可以同时解决数据传输和供电需求的问题。对于家装来说，不仅布线简单，而且十分美观。</p>
<p>相比于 Mesh 组网，其实 AC+AP 并没有复杂很多，下面是自己使用的网络部署流程。</p>
<ul>
<li>硬件连接：</li>
</ul>
<p>将所有的 ap 面板安装到对应的位置，需要提前将预埋网线的水晶头做好，直接插上就可以了。</p>
<p>将 ac 的 WAN0 口网线接上光猫的 千兆/2.5G LAN 口。如果家庭有多条宽带入户，可以将 WAN1（LAN8）口网线接上另一个光猫的对应接口，做双线入网（更多的宽带接入，不适用 锐捷 EG110G-P 这个 ac，需要更换 ac 设备）。</p>
<p>将 ac 的 LAN 口从 0 开始，依次插上 ap 的预埋线。通电之后，指示灯亮起，就解决了所有的 <strong>ac+ap 硬件连接问题</strong>。</p>
<ul>
<li>网络部署：</li>
</ul>
<p>因为是企业级的解决方案，所以也可以让网络工程师进行部署操作。</p>
<ol>
<li>下载 <strong>锐捷睿易 APP</strong>，并注册账号</li>
<li>快速添加，创建新项目</li>
<li>扫码、输入 SN 添加</li>
</ol>
<p>然后，可以进行网络部署。</p>
<p><code>工作台 -&gt; 基础 -&gt; Wi-Fi设置 -&gt; 添加新Wi-Fi</code>，输入 Wi-Fi名称、Wi-Fi密码（不建议使用弱口令，建议混合输入大小写字母、数字和特殊符号组合，不然会有很严重的网络安全隐患）；</p>
<p>频段选择 2.4G 和 5G，锐捷会自动做多频融合，智能家居设备绝大多数目前只支持 2.4G 频段的 WiFi 信号；安全基本上选择 加密，加密类型 WPA/WPA2-PSK 就可以了，目的是兼容绝大多数的设备，现阶段不推荐使用 WPA3-SAE 加密类型。</p>
<blockquote>
<p>2.4G 和 5G 指的是 WiFi 信号频段，不是运营商所说的 5G 网络</p>
</blockquote>
<p>点击 <strong>高级设置</strong>（不需要太理解，一步步操作就可以了）：</p>
<p>无线模式默认去选择：802.11ax（Wi-Fi6），如果家庭存在 <strong>设备连不上</strong> 再考虑兼容模式。</p>
<p>VLAN ID 默认为 1，表示与 AP 同 VLAN。下面在 <strong>安全性策略</strong> 的部分，会设置 VLAN ID 不填 1 的情况，默认 WiFi 保持为 1 即可。</p>
<p>打开 5G 优先。</p>
<p>至此，基本的家庭网络已经设置完毕。</p>
<h2>网络调优</h2>
<p>为优化网络连接，进行下面的操作：</p>
<p>1、进入<code>高级 -&gt; 无线 -&gt; 无线网优</code> 进行 AP 的信号调优，减少 WiFi 信号的相互干扰。</p>
<p>2、进入 <code>高级 -&gt; 无线 -&gt; AI 漫游</code> 进行 AP 漫游优化，打开 <strong>KV漫游</strong> 和 <strong>AI漫游</strong> ，提高 AP 切换体验。</p>
<p>3、进入 <code>高级 -&gt; 无线 -&gt; 5G优先</code> ，打开。</p>
<p>4、进入 <code>高级 -&gt; 网关&amp;交换 -&gt; 极速模式</code>，打开（如果没有流量审计，联网控制等特殊需求的话）。</p>
<p>5、对于多宽带入户的用户，可以选择 <code>高级 -&gt; 网关&amp;交换</code> 下面的 <strong>WAN配置</strong> 和 <strong>出口选路</strong> 进行个性化配置。</p>
<h2>安全性策略</h2>
<p>家庭网络同时存在客人来访的问题，针对于家庭网络的安全性，不建议直接分享 WiFi 密码，不排除可能造成整个网络的安全隐患；对于蹭网的处理，同样是如此。</p>
<p>搭建 <strong>访客网络</strong> 是最好的解决方案。</p>
<p>跟上面添加无线网的方式略有不同，这里会涉及到上面 VLAN ID 的问题，本篇只介绍添加 <strong>无线业务网</strong>，<strong>有线业务网</strong> 的情况同理。</p>
<ul>
<li>选择最上面 tab 栏 <code>网络</code></li>
<li>任意点击一个 无线网 方块</li>
<li>进入 <code>业务地图</code> 之后，点击 <strong>添加业务网</strong>，选择 <strong>无线业务网</strong></li>
<li>无线接入设置，跟上面步骤是一样的，设置基本参数，比如名称为 <strong>来访WiFi</strong></li>
<li>业务参数，填写 <strong>业务备注（自己知道干啥的就行）</strong>、<strong>VLAN ID</strong>（VLAN ID 影响分配的 IP 段，不要填写 0 或者 1，以防与运营商宽带冲突）</li>
</ul>
<blockquote>
<p>填写 <strong>VLAN ID</strong> 为 60，则 <strong>默认网关/掩码</strong> 为 192.168.60.1/24，不需要更改本步骤的高级配置部分。不要填写 0 或 1，是因为很可能会导致 DHCP 的 ip 段冲突；<strong>同理，如果家庭在宽带和 ac 之间还有路由设备的话，VLAN ID 也不能填该 ip 段。</strong></p>
</blockquote>
<p>其实，锐捷的 <strong>诺克云 MACC 的 eWeb</strong> 可以更容易配置 <strong>访客网络</strong>，但是 <strong>锐捷睿易APP</strong> 只是给了一个更通用的方案，不涉及太多高级的操作。</p>
<p>在完成上面的 <strong>访客网络</strong> 创建之后，需要进行 <strong>ACL 业务访问控制</strong>，本配置用于 VLAN 的安全隔离，主要应用场景为：不允许访客控制家庭智能设备、不允许外来可能的网络攻击、不允许网络嗅探等。</p>
<p><code>工作台 -&gt; 高级 -&gt; 整网 -&gt; 业务访问控制</code>，将上面设置的 <strong>访客网络业务网</strong> 拖到 <strong>隔离区</strong>，使连接该网络的设备相互隔离，不允许接入家庭网络和彼此隔离。</p>
<p>至此，简单的 <strong>安全性策略</strong> 也完成了。</p>
<h2>付费咨询</h2>
<p>如果你有需求，实在是搞不定网络配置，可以进行付费技术咨询。对于组网方案的选择、设备选择等，不限于家庭 WiFi 方案、企业级 WiFi 部署，也可以进行付费技术咨询。</p>
<p>付费咨询：<code>微信公众号：惒泊小舍 -&gt; 选择菜单 “付费咨询”</code>，选择 知乎 可以进行问答咨询。</p>
<p>网络方案和规划，请直接 <strong>向公众号发消息</strong> 留下联系方式；或者，发送电子邮件 到 <a href="mailto:hi@ibert.me">hi@ibert.me</a>。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于 Kodi 打造家庭 IPTV]]></title>
        <id>https://ibert.me/posts/zh/基于Kodi打造家庭iptv.html</id>
        <link href="https://ibert.me/posts/zh/基于Kodi打造家庭iptv.html"/>
        <updated>2023-11-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>随着智能电视的不断迭代，运行 Android 系统的电视设备越来越变的不纯粹，更像是一个默认为影音app入口的超大号显示设备。面对着无数的广告和数不尽的会员，更纯粹的看电视变得奢求，因此开始了基于 Kodi 的家庭 iptv 改造计划。</p>
<p>如果你还不知道什么是 Kodi，请参阅 <a href="https://kodi.tv/">https://kodi.tv/</a> 了解这个项目</p>
<h2>开始改造</h2>
<p>改造计划分为下面的步骤，网络上有大量的教程，这里只对于关注点提供必要的流程。</p>
<p>本次改造计划使用小米电视，其他的 Android 电视设备大同小异。</p>
<h3>安装 Kodi 至小米电视</h3>
<ul>
<li>打开小米电视 <strong>“开发者模式”</strong></li>
<li>打开小米电视 <strong>“允许安装未知应用”</strong> 和 <strong>“允许 adb 调试”</strong></li>
<li>手机安装 <strong>甲壳虫ADB助手</strong></li>
<li>手机下载 <strong><a href="https://kodi.tv/download/android/">Kodi for Android</a> APK</strong>（根据架构选择 <strong>v20 ARMV7A</strong> 或者 <strong>v20 ARMV8A</strong>，这取决于你的电视指令集架构，在系统设置中进行查看）</li>
<li>打开 <strong>甲壳虫ADB助手</strong> 填写电视 <strong>IP地址</strong> 进行连接（记得电视用遥控器确认允许）</li>
<li>通过 <strong>甲壳虫ADB助手</strong> 向电视安装 <strong>Kodi for Android</strong> APK 应用</li>
</ul>
<p>至此，在电视上安装 Kodi 就完成了。</p>
<blockquote>
<p>需要解释的是：小米虽然在系统上限制了第三方APP的安装，但我们使用了 <strong>甲壳虫ADB助手</strong> 对电视进行操作，因为 <code>adb</code> 本身是 Android 调试桥，便于 Android 开发者对设备应用进行调试，权限比较高，小米在系统层面不对其进行限制。</p>
</blockquote>
<h3>对 Kodi 进行配置</h3>
<p>好看的主题提升用户使用体验，所以我们对 Kodi 进行一些简单的配置。</p>
<blockquote>
<p>需要注意的是：<strong>在稳定使用之前，🙅不要将语言切换到中文！否则，会造成很大的麻烦！</strong> 教程步骤为中文翻译，请注意对应的英文选项</p>
</blockquote>
<ul>
<li>更改下载源</li>
</ul>
<p>Kodi 的插件托管在 GitHub 上，国内能不能连上纯粹是个玄学问题。因此我们需要对 Kodi 的插件仓库软件源进行替换，虽然 清华TUNA 和 中科大USTC 源镜像站都提供了参考文档。但是 Nexus（20）版本，无法找到对应的文件 <code>addons/repository.xbmc.org/addon.xml</code>。在查阅官方仓库源代码后发现，需要首先安装 <code>repository.xbmc.org</code> 仓库插件，这是我之前完全没想到的.</p>
<p>你可以通过 <a href="https://dl.jieec.cn/s/k5h6">https://dl.jieec.cn/s/k5h6</a> 下载 <code>repository.xbmc.org</code> 插件，已经是修改完成了的。</p>
<p>下载完成之后，通过 <strong>ADB助手</strong> 上传文件至电视文件根目录，通过 <code>插件 -&gt; 从 zip 文件安装插件 -&gt; 找到对应的 zip 文件安装</code></p>
<p>电视遥控器按左键，对插件仓库进行更新。</p>
<ul>
<li>更改 Kodi 主题</li>
</ul>
<p>在试错很多次之后，我选择了 Arctic Horizon 2 作为 Kodi 的主题，原因无他，好看罢了。</p>
<p>首先，需要下载安装 <a href="https://jurialmunkey.github.io/repository.jurialmunkey/">repository.jurialmunkey</a> 仓库差价，安装步骤与上面 <code>repository.xbmc.org</code> 插件完全一致。</p>
<p>其次，需要预先按顺序安装 <a href="https://dl.ghpig.top/https://github.com/jurialmunkey/script.module.jurialmunkey/archive/refs/tags/v0.1.17.zip">script.module.jurialmunkey</a>（下载安装）、<code>script.skinvariables</code> 和 <code>plugin.video.themoviedb.helper</code>（电视上的 jurialmunkey 插件仓库搜索安装）插件，不然在下载主题的时候会报错。</p>
<p>然后在 <code>插件 -&gt; 从库里安装 -&gt; jurialmunkey 插件库 -&gt; look and feel -&gt; 皮肤 -&gt; Arctic Horizon 2</code> 安装即可，花费的时间不短，耐心等待。</p>
<ul>
<li>设置中文页面</li>
</ul>
<p>切换字体 <code>右上角小齿轮 -&gt; 系统设置 -&gt; UI -&gt; skin -&gt; font -&gt; CJK - Chinese/Japanese/Korean</code></p>
<blockquote>
<p>默认 CJK 是不被支持的，因此先切换字体才不会导致乱码</p>
</blockquote>
<p>切换区域 <code>regional -&gt; language -&gt; chinese(simple)</code></p>
<blockquote>
<p>设置简体中文</p>
</blockquote>
<p>至此 Kodi 的基础安装全部完成！</p>
<h3>支持 IPTV</h3>
<p>光有 Kodi 是不行的，还需要配置 IPTV 才能收看 Kodi 所说的 <strong>直播电视</strong>。</p>
<p>分为两部分：</p>
<ul>
<li>Kodi 安装客户端插件 <code>IPTV Simple Client</code></li>
<li>添加 <code>IPTV Simple Client</code> 配置文件</li>
</ul>
<p>安装客户端插件的流程与上面一致，通过 <code>插件 -&gt; 从库里安装 -&gt; Kodi 官方库 -&gt; PVR 客户端 -&gt; IPTV Simple Client</code> 安装即可。</p>
<p>配置 <code>IPTV Simple Client</code>：<code>插件的设置 -&gt; 添加附加设置</code> 分别填写 <strong>名称</strong> 、 <strong>位置选择：远程路径（互联网地址）</strong> 和 <strong>M3U播放列表URL</strong></p>
<p>你可以使用 <a href="https://epg.pw/test_channel_page.html">https://epg.pw/test_channel_page.html</a> 提供的 m3u 服务，或者使用我维护的 <a href="https://m3u.ibert.me">https://m3u.ibert.me</a> 服务</p>
<h2>关于 <code>HerbertHe/iptv-sources</code></h2>
<p><a href="https://github.com/HerbertHe/iptv-sources/tree/gh-pages">HerbertHe/iptv-sources</a> 是 <a href="https://m3u.ibert.me">https://m3u.ibert.me</a> 服务的 GitHub 开源项目，对 <a href="https://epg.pw/test_channel_page.html">https://epg.pw/test_channel_page.html</a> 提供的 m3u 服务进行了过滤去重。考虑到了主要面向中国大陆用户，所以没有对所有的服务进行处理，如果有其他需要请 fork 进行二次开发。</p>
<p>本次改造如使用 <a href="https://m3u.ibert.me">https://m3u.ibert.me</a> 服务，请关闭本地缓存，打开自动更新，并且调整更新频率为 120 分钟。</p>
<p>支持的 m3u 源，请参考 <a href="https://m3u.ibert.me">https://m3u.ibert.me</a> 进行查看使用，每 3 个小时自动更新一次。</p>
<p>获取最及时的消息，请加入 Discord <a href="https://discord.gg/EawDmkpd">https://discord.gg/EawDmkpd</a>，这是最及时获取更新消息的地方。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[实用书籍和项目参考]]></title>
        <id>https://ibert.me/posts/zh/实用书籍和项目参考.html</id>
        <link href="https://ibert.me/posts/zh/实用书籍和项目参考.html"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>书籍</h2>
<ul>
<li><a href="https://wangdoc.com/bash">Bash 脚本</a></li>
<li><a href="https://course.rs/">Rust 语言圣经</a></li>
<li><a href="https://zh.practice.rs/">Rust 语言实战</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[环境部署参考]]></title>
        <id>https://ibert.me/posts/zh/环境部署参考.html</id>
        <link href="https://ibert.me/posts/zh/环境部署参考.html"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>Docker</h2>
<ul>
<li><a href="https://www.docker.com/">Website</a></li>
<li><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu</a></li>
</ul>
<h2>Drone</h2>
<ul>
<li><a href="https://github.com/drone">GitHub</a></li>
<li><a href="https://drone.cool/">Chinese Documentation</a></li>
<li><a href="https://docs.drone.io/server/overview/">Overview</a></li>
</ul>
<h2>Gogs</h2>
<ul>
<li><a href="https://github.com/gogs/gogs">GitHub</a></li>
<li><a href="https://gogs.io/">Website</a></li>
<li><a href="https://github.com/gogs/gogs/tree/main/docker">Docker For Gogs</a></li>
</ul>
<h2>Nginxconfig</h2>
<ul>
<li><a href="https://github.com/digitalocean/nginxconfig.io">GitHub</a></li>
<li><a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">Website</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[The TEXbook 知识点总结]]></title>
        <id>https://ibert.me/posts/zh/TheTEXbook知识点总结.html</id>
        <link href="https://ibert.me/posts/zh/TheTEXbook知识点总结.html"/>
        <updated>2021-12-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>阅读背景</h2>
<p>《The TEXbook》是由 TeX 作者 DONALD E. KNUTH 编写的一本关于 TeX 设计的书, 介绍了 TeX 在设计时所考虑到的细节。OLeX 在词法分析和语法部分需要仔细研究此部分的内容, 从而消除对 TeX 的分析差异。(之前都是针对大量模板进行的实现, 多多少少会有兼容性和语法忽略的问题)</p>
<p>TeX 是一门注重排版的语言, 并且让用户不用过度关心于排版本身。本篇博客将注重于对 TeX 令人疑惑的细节探索, 追求在语法上和原理上总结 TeX 这门语言的 “奇异” 之处。</p>
<h2>排版</h2>
<p>书籍与普通的排版并不完全相同, 尤其是在符号的差别上, 计算机的 ASCII 码并不是专门为书籍出版所发明, 比如 <strong>引号</strong> 有左引号、右引号、无方向引号... 因此, TeX 在此方面做了很多的考虑。</p>
<p>比如双引号 <code>“</code> 可以输入为 <code>‘‘</code>, <code>”</code> 可以输入为 <code>’’</code></p>
<p>连字符(-) <code>-</code>、短破折号(-) <code>--</code>、破折号(——) <code>---</code>、减号(-) <code>$-$</code>, 这四个符号其实并不一样。TeX 会完全自己解决这个问题, 而用户并不必要担心。</p>
<p>TeX 可以通过 <code>\lq</code> 和 <code>\rq</code> 键入左右引号。为了键入 <code>’”</code> 并且消除歧义, 使单双引号间距不过大或过小, 可以键入 <code>’\thinspace’’</code> 得到想要的结果。</p>
<h2>TeX 控制系列</h2>
<p>键盘可以输入的字符比较少, 为了解决这个问题 TeX 使用反斜杠 <code>\</code> 进行 “转义”。举个例子：</p>
<pre><code class="language-tex">\input MS
</code></pre>
<p>上面这行命令的意思为: 读取 <code>MS.tex</code> 文件, <code>\input</code> 就是一个控制系列(命令), 再举个例子:</p>
<pre><code class="language-tex">George P\’olya
</code></pre>
<p>渲染为: George Pólya</p>
<p>控制系列类型:</p>
<ul>
<li>第一类: <code>\input</code>; 由 <code>\ + 多个字母 + 空格或非字母字符</code>, TeX 一般把 <code>[a-zA-Z]</code> 看作字母, 数字 <code>[0-9]</code> 并不看作字母 (OLeX 在实现上进行了差异化处理, 未严格按照 TeX 进行实现)</li>
<li>第二类: <code>\’</code>; 由 <code>\ + 一个单个非字母组成</code>, 区别是不必将控制系列与后面的字母分开, <strong>第二类控制系列在转义符后面永远只有一个符号!</strong></li>
</ul>
<p>第一类控制系列后面的空格会被忽略掉, 并不看作为 “实际” 空格。<strong>但是, 出现在第二类控制系列后面会看作是实际空格</strong>。</p>
<p><strong>TeX 把多个连续空格看作单个空格</strong>。键入控制空格解决此问题 <code>\ (控制空格)</code></p>
<p><strong>TeX 把 <code>&lt;return&gt;</code> 看作同 <code>\ (控制空格)</code></strong>, 控制空格属于第二类控制系列。</p>
<blockquote>
<p>TeX 的第二类控制系列的实现在 OLeX 中也没有严格实现, OLeX 借助于 HTML 和一部分的 SVG 进行实现, 所以并没有完全严格按照 TeX 的规范, 为了消除 TeX 本身可能语法带来的歧义导致给用户带来心智负担。</p>
</blockquote>
<p>TeX 大约能执行900个控制系列, 是 TeX 内置语汇的一部分。(OLeX 通过自行设计渲染器结构对内置语汇和宏包进行统一实现)。需要注意的是, TeX 的控制系列是大小写敏感的, 并且是一一对应的映射关系。大约 300 个控制系列为 <em>原始控制系列</em>。</p>
<p>TeX 的高级控制系列可以进行计算 (OLeX 或许在更远期的规划里面, 会对此部分的内容进行实现。)</p>
<p><code>\show\input</code> -&gt; <code>\input=\input</code>, <code>\show\thinspace</code></p>
<p>-&gt;</p>
<pre><code class="language-text">&gt; \thinspace=macro:
-&gt; \kern .16667em .
</code></pre>
<p><code>\show</code> 的结果被保存在 log 文件中。</p>
<p>plain TeX 大约有 600 个基本控制系列, 加上 300 个左右的原始控制系列, 构成了TeX 基本的文本排版控制。</p>
<h2>字体</h2>
<p>默认情况下, 不定义其他字体将使用 <strong>roman</strong> 字体。</p>
<pre><code class="language-text">\rm --&gt; Roman
\sl --&gt; Slanted
\it --&gt; Italic
\tt --&gt; Typewriter
\bf --&gt; Bold
</code></pre>
<p>字体的外形会随着大小而改变, 单位设计使用 points(即pt)。</p>
<pre><code class="language-text">10 points --&gt; \tenrm
9 points --&gt; \ninerm
10 points slanted --&gt; \tensl
</code></pre>
<p>对于字体名称的处理, <code>\font\cs=&lt;external font name&gt;</code> 把一个特殊字体的有关信息载入内存; 在控制系列 <code>\cs</code> 将在排版时选择那个字体。Plain TeX 最初只定义了 16 个字体, 可以使用 <code>\font</code> 把系统字体库中字体为 TeX 所用。</p>
<p>因为对于字体设计来说, 随着字号的不同并不是单纯的放大或缩小, 因此放缩字体还是存在与调整字号大小不同之意义的。通过 <code>\font\cs=&lt;external font name&gt; at &lt;desired size&gt;</code> 命令实现。</p>
<p>另一种方法是, 相对于设计尺寸给出放大因子。规定为整数, 等于放大比例乘上 1000.1200 即是放大 1.2 倍。<code>\font\manifiedfiverm=cmr5 scaled 2000</code>。Plain TeX 提供了缩略命令, <code>\magstep0</code> 放大因子为 1000、<code>\magstep1</code> 放大因子为 1200, <code>\magstep2</code> 为 1440 ... <code>\magstep5</code></p>
<p><code>\magstephalf</code> 放大 $\sqrt{1.2}$ 倍。</p>
<h2>编组</h2>
<p>编组即是使用一对 <code>{}</code> 对内容进行包围的操作, 实现隔绝渲染环境, OLeX 对编组进行了实现。但是为了更好的歧义消除效果, 对于 OLeX 来说, 还是更推荐使用 <code>\CommandName{}</code> 的形式, 会在语法上对非控制系列分组进行<strong>考虑实现</strong>。</p>
<p>类似于 <code>{\it centered}</code> 这种组内语句, <code>\it</code> 对其**后面组内的文本渲染(局部作用域)**都起作用, 这一点需要注意。</p>
<blockquote>
<p>需要注意: TeX 里面有个控制系列 <code>\/</code> 可以作为 unslanted 转化过渡。</p>
</blockquote>
<p><strong>编组还有一个作用: 将文本的多个单词看作一个单一对象!</strong>(OLeX 在词法分析上已经对此部分进行了实现, 需要修改语法分析部分, 并且对不正确编组进行修正)</p>
<p><strong>编组创造了局部作用域的环境。</strong> 有时候为了突破当前局部作用域, 可以通过定义加上前缀 <code>\global</code> 而实现。例如, TeX 把当前页码放在一个叫 <code>\count0</code> 的寄存器中, 输出一页增加页数。放在组中可以避免上下文影响; 但是对于输出来说 <code>\count0</code> 为局部变量, 会产生掩盖, 命令 <code>\global\advance\count0 by 1</code> 可以实现组内生命周期结束, 对寄存器进行保留。<code>\global</code> 使其后紧接的定义适用在所有存在的组, 无所谓深度。</p>
<blockquote>
<p>OLeX 在生命周期通过上下文对此特性进行实现, 并且通过上下文进行传递。</p>
</blockquote>
<p>除了上述模块结构的方法, 另一种方法为原始的 <code>\begingroup</code> <code>\endgroup</code>, 但需要保证实际执行文本必须是嵌套组, 组不能交叉!</p>
<p>定义控制系列 <code>\beginthe&lt;block name&gt;</code> <code>\endthe&lt;block name&gt;</code>, 只有嵌套才是合法的。</p>
<h2>运行 TeX (跳过此部分)</h2>
<p>运行 TeX 程序会生成一个 <code>.dvi</code> 文件, 不依赖于任何设备, 可以在几乎所有的印刷设备打印出来。</p>
<blockquote>
<p><code>~</code> 称为<strong>带子</strong>, (OLeX 暂不对此部分进行实现), 对应书 p17~28。</p>
</blockquote>
<h2>TeX 工作原理 (跳过实现)</h2>
<ul>
<li>一个 <code>&lt;return&gt;</code> 与一个空格类似</li>
<li>一行中的两个空格看作一个 (合并空格操作)</li>
<li>一个空行表示一段的结束</li>
</ul>
<blockquote>
<p>上面的规则并不准确</p>
</blockquote>
<p>TeX 可以见到直接由键盘输入的字符行中字符有 256 个, 可以分为 16 类:</p>
<table>
<thead>
<tr>
<th>类别</th>
<th style="text-align:left">意义</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:left">转义符</td>
<td><code>\</code></td>
</tr>
<tr>
<td>1</td>
<td style="text-align:left">组开始</td>
<td><code>{</code></td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">组结束</td>
<td><code>}</code></td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">数学环境</td>
<td><code>$</code></td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">表格对齐</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">换行</td>
<td><code>&lt;return&gt;</code></td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">参数</td>
<td><code>#</code></td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left">上标</td>
<td><code>^</code></td>
</tr>
<tr>
<td>8</td>
<td style="text-align:left">下标</td>
<td><code>_</code></td>
</tr>
<tr>
<td>9</td>
<td style="text-align:left">可忽略字符</td>
<td><code>&lt;null&gt;</code></td>
</tr>
<tr>
<td>10</td>
<td style="text-align:left">空格</td>
<td><code> </code></td>
</tr>
<tr>
<td>11</td>
<td style="text-align:left">字母</td>
<td><code>[a-zA-Z]</code></td>
</tr>
<tr>
<td>12</td>
<td style="text-align:left">其他字符</td>
<td>不在上下文的其他字符</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:left">活动符</td>
<td><code>~</code></td>
</tr>
<tr>
<td>14</td>
<td style="text-align:left">注释符</td>
<td><code>%</code></td>
</tr>
<tr>
<td>15</td>
<td style="text-align:left">无用符</td>
<td><code>&lt;delete&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>OLeX 支持的字符远超上述所述内容, 换行使用 <code>\n</code> 规范化解决了 CRLF 的问题。</p>
</blockquote>
<h2>字符输入</h2>
<p>TeX 通过 <code>%</code> 对文本进行注释, 通过 <code>\%</code> 键入 <code>%</code>。</p>
<p>TeX 可以通过 <code>\char&lt;number&gt;</code> (number: 0~255) + 空格, 得到相应的字符。比如 <code>\%=\char37</code>, TeX 内部表示字符基于 ASCII 码, 说到底还是通过**“特殊”**的控制系列</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript中的ArrayBuffer]]></title>
        <id>https://ibert.me/posts/zh/JavaScript中的ArrayBuffer.html</id>
        <link href="https://ibert.me/posts/zh/JavaScript中的ArrayBuffer.html"/>
        <updated>2021-11-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>在尝试用国密算法实现 jwt 的时候, 发现可以使用的库很少, 便根据 jwt 的生成规则和国密 SM3 算法自行参考实现。SM3 是国密算法中的哈希散列算法, 生成单向指纹校验数据有着重要的意义。在生成 jwt 的指纹部分, 尝试使用 HMACSM3 替代掉 HMACSHA256算法。</p>
<p>HMACSM3 可用的 JavaScript 库确实没发现, 参考了 Java 版本进行自行实现。其中涉及到了二进制数据的位运算, 并且 <a href="https://github.com/byte-fe/gm-crypto">byte-fe/gm-crypto</a> 中的 SM3 的返回值类型为 <code>ArrayBuffer</code>, 因此觉得研究此 ES6 的新内置对象很有意义。</p>
<h2>关于 ArrayBuffer</h2>
<p>在 MDN 中, 对于 <code>ArrayBuffer</code> 对象表述为表示通用的、固定长度的原市二进制数据缓冲区, <strong>在其他语言中被称为&quot;byte array(字节数组)&quot;</strong></p>
<p>在 golang 中, byte array 和 string 的类型转化很常见。byte array在不同语言中均有用处, 可以提高程序计算的性能。</p>
<p>JavaScript 的 <code>ArrayBuffer</code> 设计目的也同样如此, 需要注意的这又是一个 <em>array-like</em> object, 使用 TypedArray or DataView 对象进行操作。</p>
<h2>语法</h2>
<blockquote>
<p>new ArrayBuffer(length)</p>
</blockquote>
<ul>
<li>参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>length</code></td>
<td>要创建的 <code>ArrayBuffer</code> 的大小, 单位为字节</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>一个指定大小的 <code>ArrayBuffer</code> 对象, 其内容被初始化为 0</p>
<ul>
<li>异常</li>
</ul>
<p>如果 <code>length</code> ＞ <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a> (≥2**53) 或为 负数, 会抛 RangeError 异常。</p>
<h2>属性</h2>
<ul>
<li><code>ArrayBuffer,length</code></li>
</ul>
<p>ArrayBuffer 构造函数的 length 属性, 其值为 1</p>
<ul>
<li><code>ArrayBuffer.prototype.byteLength</code></li>
</ul>
<p>只读, 表示 <code>ArrayBuffer</code> 的 byte 大小, 在 ArrayBuffer 构造完成时生成, 不可更改。</p>
<h2>方法</h2>
<ul>
<li><code>ArrayBuffer.isView(arg)</code></li>
</ul>
<p>如果参数是 ArrayBuffer 的视图实例则返回 <code>true</code>, 例如 TypedArray or DataView 对象；否则返回 <code>false</code></p>
<ul>
<li><code>ArrayBuffer.transfer(oldBuffer [, newByteLength])</code> <em><strong>实验性</strong></em></li>
</ul>
<p>返回一个新的 ArrayBuffer 对象, 其内容取自 <code>oldBuffer</code> 中的数据, 并根据 <code>newByteLength</code> 的大小对数据进行截取或补 0</p>
<h2>兼容性</h2>
<p>就让 IE 消失于世间吧~</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[EBNF]]></title>
        <id>https://ibert.me/posts/zh/EBNF.html</id>
        <link href="https://ibert.me/posts/zh/EBNF.html"/>
        <updated>2021-10-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>扩展巴科斯范式</h2>
<blockquote>
<p>参考来源 <a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">Wikipedia</a></p>
</blockquote>
<p>一种表达形式语言文法的代码, EBNF 定义了把各符号序列分别指派非终结符的<strong>产生规则</strong></p>
<pre><code class="language-ebnf">digit excluding zero = &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;;
digit = &quot;0&quot; | digit excluding zero;
</code></pre>
<p>定义左端非终结符 <em>digit</em>。竖杠表示可供选择, 终结符被 <code>&quot;</code> 包围, 最后跟着 <code>;</code> 作为终止字符。</p>
<p>产生规则还可以包括由逗号分隔的一序列 <em>终结符</em> 或 <em>非终结符</em></p>
<pre><code class="language-ebnf">twelve = &quot;1&quot;, &quot;2&quot;;
two hundred one = &quot;2&quot;, &quot;0&quot;, &quot;1&quot;;
three hundred twelve = &quot;3&quot;, twelve;
twelve thousand two hundred one = twelve, two hundred one;
</code></pre>
<p>可以 <strong>省略</strong> 或 <strong>重复</strong> 的表达式可以通过花括号 <code>{...}</code> 表示: (大概相当于正则表达式的 <code>*</code>)</p>
<pre><code class="language-ebnf">natural number = digit excluding zero, { digit };
</code></pre>
<p>在这种情况下, 字符串 1, 2, ..., 10, 12345, ... 都是正确的表达式。表示这种情况, 于花括号内设立的所有东西 <em>可以重复任意次</em>, 包括根本不出现。</p>
<p>可选项可以通过方括号 <code>[...]</code> 表示: (大概相当于正则表达式的 <code>?</code>)</p>
<pre><code class="language-ebnf">integer = &quot;0&quot; | [&quot;-&quot;], natural number;
</code></pre>
<p>integer 是一个 <em>零(0)</em> 或可能 <em>前导可选的负号</em> 的一个自然数。</p>
<p>EBNF 还包括描述 <strong>指定次数的重复</strong>, 和 <strong>排除产生的某部分</strong> 或向 EBNF 文法 <strong>插入注释</strong> 的语法。</p>
<h2>符号表</h2>
<table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:center">符号表示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义</td>
<td style="text-align:center"><code>=</code></td>
</tr>
<tr>
<td style="text-align:left">串接</td>
<td style="text-align:center"><code>,</code></td>
</tr>
<tr>
<td style="text-align:left">终止</td>
<td style="text-align:center"><code>;</code></td>
</tr>
<tr>
<td style="text-align:left">分隔</td>
<td style="text-align:center"><code>|</code></td>
</tr>
<tr>
<td style="text-align:left">可选</td>
<td style="text-align:center"><code>[...]</code></td>
</tr>
<tr>
<td style="text-align:left">重复</td>
<td style="text-align:center"><code>{...}</code></td>
</tr>
<tr>
<td style="text-align:left">分组</td>
<td style="text-align:center"><code>(...)</code></td>
</tr>
<tr>
<td style="text-align:left">双引号</td>
<td style="text-align:center"><code>&quot;...&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">单引号</td>
<td style="text-align:center"><code>'...'</code></td>
</tr>
<tr>
<td style="text-align:left">注释</td>
<td style="text-align:center"><code>(*...*)</code></td>
</tr>
<tr>
<td style="text-align:left">特殊序列</td>
<td style="text-align:center"><code>?...?</code></td>
</tr>
<tr>
<td style="text-align:left">除外</td>
<td style="text-align:center"><code>-</code></td>
</tr>
</tbody>
</table>
<h2>约定</h2>
<ol>
<li>
<p>使用如下约定:</p>
<ul>
<li>EBNF 的每个元标识符否被写为 <em>连字号</em> 连接起来的一个或多个字；</li>
<li>结束于 &quot;-symbol&quot; 的元标识符是 EBNF 的终结符的名字。</li>
</ul>
</li>
<li>
<p>表示 EBNF 的每个操作符的正常字符和它所蕴涵的 <em><strong>优先级</strong></em>(顶部为<strong>最高</strong>优先级)为:</p>
<pre><code class="language-text">* repetition-symbol
- except-symbol
, concatenate-symbol
| definiton-separator-symbol
= defining-symbol
; terminator-symbol
</code></pre>
</li>
<li>
<p>下列 <em>括号对</em> <strong>超越</strong> 正常优先级:</p>
<pre><code class="language-text">‘first-quote-symbol  first-quote-symbol’
&quot;second-quote-symbol  second-quote-symbol&quot;
(*start-comment-symbol  end-comment-symbol*)
(start-group-symbol  end-group-symbol)
[start-option-symbol  end-option-symbol]
{start-repeat-symbol  end-repeat-symbol}
?special-sequence-symbol  special-sequence-symbol?
</code></pre>
</li>
</ol>
<p>举例:</p>
<pre><code class="language-ebnf">aa = &quot;A&quot;;
bb = 3 * aa, &quot;B&quot;;
cc = 3 * [aa], &quot;C&quot;;
dd = {aa}, &quot;D&quot;;
ee = aa, {aa}, &quot;E&quot;;
ff = 3 * aa, 3 * [aa], &quot;F&quot;;
gg = {3 * aa}, &quot;D&quot;;
</code></pre>
<p>定义的终结字符串:</p>
<pre><code class="language-text">aa: A
bb: AAAB
cc: C AC AAC AAAC
dd: D AD AAD AAAD ...
ee: AE AAE AAAE AAAAE ...
ff: AAAF AAAAF AAAAAF AAAAAAF
gg: D AAAD AAAAAAD ...
</code></pre>
<h2>EBNF &amp; BNF</h2>
<blockquote>
<p>BNF 有 <strong>可选项</strong> 和 <strong>重复</strong> 不能直接表达的问题。</p>
</blockquote>
<p>可选项:</p>
<pre><code class="language-ebnf">signed number = [sign, ] number;
</code></pre>
<p>BNF 风格:</p>
<pre><code class="language-bnf">signed number = sign, number | number;
</code></pre>
<p>or</p>
<pre><code class="language-ebnf">signed number = optional sign, number;
optional sign, = ε | sign, ; (*使用ε来清晰的指示空产生式*)
</code></pre>
<p>重复:</p>
<pre><code class="language-ebnf">number = { digit } digit;
</code></pre>
<p>BNF风格:</p>
<pre><code class="language-bnf">number = digit | number digit;
</code></pre>
<h2>EBNF 较 BNF 的优点</h2>
<p>BNF 的缺陷:</p>
<ul>
<li>BNF 自身使用了符号(<code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code>::=</code>), 定义会产生误解。</li>
<li>BNF 语法在一行只能表示一个规则。</li>
</ul>
<p>EBNF 解决了这些问题:</p>
<ul>
<li>终结符被严格包围在引号 (<code>&quot;...&quot;</code> 或 <code>'...'</code>) 中。给非终结符的尖括号 (<code>&quot;&lt;...&gt;&quot;</code>) 可以省略。</li>
<li>通常使用终止字符 <strong>分号</strong> 结束一个规则。</li>
</ul>
<p>进一步提供了定义 <strong>重复次数</strong>, <strong>排除法选择</strong> 和 <strong>注释</strong> 等增强机制。</p>
<p>原理上, EBNF 任何文法都可以用 BNF 表达。</p>
<p>EBNF 已经被 ISO 以 <em>ISO/IEC 14977:1996(E)</em> 标准化。</p>
<p>在某些场合任何扩展的 BNF 都被称为 EBNF。例如 W3C 使用 <a href="https://web.archive.org/web/20031203082847/http://www.w3c.org/TR/REC-xml#sec-notation">one EBNF</a> 来规定 XML。</p>
<h2>扩展</h2>
<p>根据 ISO 14977 标准, 提供了两个设施来扩展 EBNF。其一, 是指 EBNF 文法部分的特殊序列, 它是问号内包围内的任意文本, <strong>其解释超出了 EBNF 标准的范围</strong>。</p>
<pre><code class="language-ebnf">space = ?US-ASCII character 32?
</code></pre>
<p>其二, <strong>圆括号</strong> 在 EBNF 中不能放置到紧跟标识符之后。</p>
<pre><code class="language-ebnf">something = foo (bar); (*无效*)
</code></pre>
<p>EBNF 的扩展可以使用这种表示法。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[从React视角学习Svelte(一)]]></title>
        <id>https://ibert.me/posts/zh/从React视角学习Svelte(一).html</id>
        <link href="https://ibert.me/posts/zh/从React视角学习Svelte(一).html"/>
        <updated>2021-05-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面</h2>
<p>因为自己做前端最近一直使用的都是React, 所以将以React的视角来学习Svelte。就自己使用Vue、React及其衍生框架的经验来说, 不同的前端框架有着类似的概念, 当熟悉一个框架之时往往更加容易进行其他框架的学习。React宣称自己是一个<code>library</code>, Vue是<code>Framework</code>, 而Svelte是一个<code>compiler</code>。React、Vue和Svelte在实现上还是有很多的差异的, 写法有相似之处也有一些差异的地方。</p>
<p>本篇文章是跟着Svelte的官方教程而来, 官方提供了交互的教程对于学习来说很友好。</p>
<ul>
<li>附上官方教程地址: <a href="https://svelte.dev/tutorial/basics">Svelte Tutorial</a></li>
</ul>
<blockquote>
<p>Svelte涉及到了很多ES6的原生语法, 请在此之前了解ES6常用的基础语法, 比如解构赋值, 展开/剩余参数, ES Module...</p>
</blockquote>
<p>本篇所有的概念基本上全部为自己总结, 与官方表述和第三方翻译可能会有出入, 顺序也跟官方并不太一样。</p>
<h2>基础结构</h2>
<p>Svelte的文件结构跟Vue类似, 但并不太一样, 由标签和Svelte自定义的代码特性块构成。在后面会具体解释Svelte自定义的代码特性块。</p>
<pre><code class="language-html">&lt;script&gt;
    let name = &quot;Hello World!&quot;
    let show = false
&lt;/script&gt;

&lt;style&gt;
    div {
        color: red;
    }
&lt;/style&gt;

&lt;div&gt;{name}&lt;/div&gt;

{#if show}
    &lt;p&gt;哎，我出来了~&lt;/p&gt;
{:else}
    &lt;p&gt;哎，它不见了~&lt;/p&gt;
{/if}
</code></pre>
<p>上面的栗子跟普通HTML并没有什么太大区别。与Vue相比, HTML(布局)的部分不需要写在标签<code>&lt;template&gt;&lt;/template&gt;</code>里面, 直接往下排就好了。</p>
<h2>动态数据</h2>
<p>在上面的栗子也可以看到使用<code>{}</code>包裹变量来渲染的表示方式, 在此称为动态数据。无论是Vue、React还是小程序均存在这类的数据动态渲染的方式。无论是attribute还是props, 都可以以此来赋值数据。</p>
<pre><code class="language-html">&lt;img src={src} /&gt;
</code></pre>
<h2>Svelte自定义的代码特性块</h2>
<p>Svelte通过自定义的特性块实现了原生HTML没有的一些特性, 例如: 条件渲染、遍历之类的。在Vue里可以通过<code>v-if</code>这种自定义属性实现条件渲染, 在React里可以通过<code>{condition &amp;&amp; &lt;p&gt;啦啦啦啦~&lt;/p&gt;}</code>进行条件渲染。在Svelte的条件渲染, 如下面的栗子:</p>
<ul>
<li><code>if</code>块</li>
</ul>
<blockquote>
<p>做条件渲染使用, 其中<code>else-if</code>块和<code>else</code>块均可省略</p>
</blockquote>
<pre><code class="language-html">{#if condition}
    &lt;p&gt;条件一看我~&lt;/p&gt;
{:else if condition1}
    &lt;p&gt;条件二看我~&lt;/p&gt;
{:else}
    &lt;p&gt;不然你看我！&lt;/p&gt;
{/if}
</code></pre>
<p>Svelte的实现类似于<a href="https://github.com/mde/ejs">ejs</a>, 不过有着明显的区别。可以看到不同的块的起始标识符并不一致, 记起来其实比较简单。<code>#</code>表示开始块, <code>:</code>表示持续块, <code>/</code>表示结束块; 持续块可以省略。</p>
<ul>
<li><code>each</code>块</li>
</ul>
<blockquote>
<p>each块用于遍历数据渲染DOM结构</p>
</blockquote>
<pre><code class="language-html">{#each variables as variable, index}
    &lt;p&gt;{variable}&lt;/p&gt;
{/each}
</code></pre>
<blockquote>
<p>第一个参数为数组成员, 第二个参数为索引index</p>
</blockquote>
<p>当然, 在each块里也可以使用解构赋值</p>
<pre><code class="language-html">&lt;script&gt;
    let cats = [
        {name: &quot;黑猫&quot;, id: &quot;black&quot;},
        {name: &quot;白猫&quot;, id: &quot;white&quot;}
    ]
&lt;/script&gt;

{#each cats as {name, id}}
    &lt;p&gt;{name}: {id}&lt;/p&gt;
{/each}
</code></pre>
<ul>
<li><code>await</code>块</li>
</ul>
<blockquote>
<p>await块用于promise数据渲染, 具体可以参考ES6的Promise的部分。用法大同小异, 可以理解为HTML的Promise数据驱动赋能~</p>
</blockquote>
<pre><code class="language-html">{#await promise}
    &lt;p&gt;等待数据中~&lt;/p&gt;
{:then number}
    &lt;p&gt;数字是{number}~&lt;/p&gt;
{:catch error}
    &lt;p&gt;哎呀我出错了~{error.message}&lt;/p&gt;
{/await}
</code></pre>
<blockquote>
<p><code>catch</code>块可以省略</p>
</blockquote>
<pre><code class="language-html">{#await promise then value}
    &lt;p&gt;哎我有值~ {value}&lt;/p&gt;
{/await}
</code></pre>
<h2>Reactivity</h2>
<p>中文文档翻译成了<strong>反应性能力</strong>, 但是在知乎看到很多大V直接用英文来表示。为了减少阅读和理解障碍, 直接就不翻译好了。</p>
<p>其实Reactivity表示的意思, 就是数据驱动页面更新这么个机制, 以官网栗子:</p>
<pre><code class="language-html">&lt;script&gt;
    let count = 0;

    function handleClick() {
        count += 1;
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;
    Clicked {count} {count === 1 ? 'time' : 'times'}
&lt;/button&gt;
</code></pre>
<blockquote>
<p><code>on:click</code>在这跟原生DOM的事件监听没啥区别, 后面再详述Svelte的事件系统。</p>
</blockquote>
<p>当点击事件<code>handleClick()</code>触发, count数据加一发生改变。在HTML中因为有<code>{count}</code>这个数据绑定机制, 则自动更新这部分的视图。这就是所说的<strong>Reactivity</strong>, 数据驱动视图更新。</p>
<p>但是需要注意的是, Svelte<strong>只监听赋值</strong>的过程, 而非数据改变就会触发。</p>
<pre><code class="language-html">&lt;script&gt;
    let array = []
    function append(val) {
        // array.push(val) ❌
        array = [...array, val] // ✔
    }
&lt;/script&gt;
</code></pre>
<blockquote>
<p>此外, <strong>引用类型属性更新</strong>并<strong>不会</strong>触发Reactivity, <code>obj.name</code>赋值不能触发<code>obj</code>这玩意儿监听, 除非来个<code>obj = obj</code></p>
</blockquote>
<h2>Reactivity声明</h2>
<p>因为存在动态数据依赖某更新数据的依赖情况, 所以声明更新<strong>动作</strong>会比较重要。</p>
<pre><code class="language-html">&lt;script&gt;
    let number = 1
    let double
    $: double = number * 2

    function handleClick() {
        number += 1;
    }
&lt;/script&gt;

&lt;button on:click={handleClick}&gt;{number} 数字的两倍是 {double}&lt;/button&gt;
</code></pre>
<blockquote>
<p>当number更改的时候, <code>$: double = number * 2</code>这个Reactivity语句就会执行</p>
</blockquote>
<p>当然可以定义一组动作, 也可以不是赋值操作</p>
<pre><code class="language-html">&lt;script&gt;
    $: {
        console.log(`我数大了! ${number}`)
        alert(`我弹弹弹！${number}`)
    }
&lt;/script&gt;
</code></pre>
<h2>组件化和Props</h2>
<p>跟Vue和React一样, Svelte的一个文件也是一个组件, 以<code>.svelte</code>后缀结尾, 可以导入和封装组件。</p>
<p>为了避免样式污染, Svelte的style样式作用域在组件内。</p>
<pre><code class="language-html">&lt;!-- Nested.svelte --&gt;
&lt;script&gt;
    export let name = &quot;Nested&quot;
&lt;/script&gt;

&lt;p&gt;Hello {name}!&lt;/p&gt;
</code></pre>
<pre><code class="language-html">&lt;!-- App.svelte --&gt;
&lt;script&gt;
    import Nested from &quot;./Nested.svelte&quot;
&lt;/script&gt;

&lt;Nested name=&quot;App&quot; /&gt;
</code></pre>
<p>上面的过程, 熟悉React的看看就懂了。不同的是, Svelte更像是数据驱动的, 只需要<code>export</code>这个操作就可以自定义组件属性了, 而React设计却一直贯彻的是单向数据流(在后面的事件监听部分, 更可以体会与React的设计差别)。组件内部可以赋值默认值, 并且支持类ES6的展开运算(React也支持)<code>&lt;Nested {...props} /&gt;</code>。Svelte官网说可以通过<code>$$props</code>拿到props的数据, 但是因为优化的原因不建议用。</p>
<h2>事件监听</h2>
<p>Svelte通过<code>on:事件名</code>这个API进行事件监听, 跟Vue的<code>v-on:</code>和React的小驼峰命名法事件一样。</p>
<h3>行内事件处理</h3>
<pre><code class="language-html">&lt;div on:mousemove=&quot;{e =&gt; m = { x: e.clientX, y: e.clientY }}&quot;&gt;
    The mouse position is {m.x} x {m.y}
&lt;/div&gt;
</code></pre>
<blockquote>
<p>Svelte官方特别表示, 其他框架都建议不要使用行内事件处理, 因为性能优化的一些原因, <strong>但对于Svelte来说不存在这个问题</strong></p>
</blockquote>
<h3>事件修饰</h3>
<pre><code class="language-html">&lt;script&gt;
    function handleClick() {
        alert('no more alerts')
    }
&lt;/script&gt;

&lt;button on:click|once={handleClick}&gt;
    Click me
&lt;/button&gt;
</code></pre>
<blockquote>
<p>那个<code>once</code>就是事件修饰符, 可用的修饰符如下, 并且事件修饰可以并列</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">preventDefault</td>
</tr>
<tr>
<td style="text-align:center">stopPropagation</td>
</tr>
<tr>
<td style="text-align:center">passive</td>
</tr>
<tr>
<td style="text-align:center">capture</td>
</tr>
<tr>
<td style="text-align:center">once</td>
</tr>
<tr>
<td style="text-align:center">self</td>
</tr>
</tbody>
</table>
<h3>组件事件</h3>
<h3>事件转发</h3>
<h2>绑定</h2>
<blockquote>
<p>未完待续~</p>
</blockquote>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[有趣的JavaScript正则表达式]]></title>
        <id>https://ibert.me/posts/zh/有趣的JavaScript正则表达式.html</id>
        <link href="https://ibert.me/posts/zh/有趣的JavaScript正则表达式.html"/>
        <updated>2021-04-11T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>正则表达式</h2>
<p>正则表达式被广泛用于文本的提取和测试, 相比于编译原理来说它足够的简单; 而相较于字符匹配来说, 又足够的功能强大。著名的markdown解析器 <code>marked.js</code> 即是使用来进行解析的, 然后生成markdown语法树进行渲染。而且正则表达式被绝大多数的高级编程语言支持, 除了实现的程度和实现的方法不太一致之外, 均可以得到很好的通用。</p>
<p>正则表达式上手较为容易而且写法各异, 但想精通比较困难, 如何快速上手和提高正则的执行效率就不赘述了。</p>
<h2>有趣的JavaScript正则表达式</h2>
<p>与匹配相关的JavaScript相关函数主要是 <code>String.prototype.match()</code>、<code>RegExp.prototype.test()</code> 和 <code>RegExp.prototype.exec()</code></p>
<p>相关MDN文档如下:</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match">String.prototype.match()</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">RegExp.prototype.test()</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">RegExp.prototype.exec()</a></li>
</ul>
<h2>一个有趣的&quot;BUG&quot;</h2>
<p>下述代码节选自 <a href="https://github.com/HerbertHe/olex/blob/main/src/core/lex/lexer.ts#L14">OLEX</a></p>
<pre><code class="language-ts">const tex = `\\documnetclass{article}\n\\usepackage{sdfsfsdf}\n\\usepackage{9ubb}\n\\usepackage{example}`

const usepackageRegex = /\\usepackage\s*(\[([a-zA-Z0-9 ]+)\])?\s*\{([a-zA-Z0-9\-]+)\}/g

export const PackageChecker = (
    tex: string,
    packages: PackagesType
): PackageCheckerType =&gt; {
    if (!usepackageRegex.test(tex)) {
        // 没使用额外的包
        return [true, &quot;&quot;, tex]
    }

    // 注意上面会改变lastIndex的位置, 需要进行重置

    // ---- 注意这里 Attention Here ----
    // usepackageRegex.lastIndex = 0

    const packsSet = new Set([...packages.keys()])

    let pack

    while ((pack = usepackageRegex.exec(tex)) !== null) {
        console.log(pack)  // 注意这里的打印值
        if (!packsSet.has(pack[3])) {
            return [false, pack[3], tex]
        }
    }

    return [true, &quot;&quot;, tex.replace(usepackageRegex, &quot;&quot;)]
}
</code></pre>
<blockquote>
<p>上述的注意打印值的部分输出的结果会是什么呢？第一次全局匹配的结果是 <code>\\usepackage{sdfsfsdf}</code> 还是 <code>\\usepackage{9ubb}</code>？这是个问题。</p>
</blockquote>
<p>如果把注意部分注释掉的代码, 取消注释结果又是什么呢？</p>
<p>因此就引出了一个非常值得注意的正则表达式属性 <code>lastIndex</code>, 而 <code>test()</code> 和 <code>exec()</code> 均会改变 <code>lastIndex</code>的值。这个属性可以理解为正则表达式匹配的指针, 下一次的匹配是从 <code>lastIndex</code> 的值开始的。在上述的代码中, 使用了 <code>test()</code> 方法逻辑对函数执行效率进行提高, 因此下面的匹配使用 <code>exec()</code> 的结果中, <strong>匹配从 <code>\\usepackage{9ubb}</code> 开始!</strong></p>
<p>为了得到正确的结果, 则必须对 <code>lastIndex</code> 的值进行重置</p>
<h2>拓展 —— 全局匹配结果的问题</h2>
<p>JavaScript中为了匹配特定字符串的特定匹配分组的值, 只能采取循环 <code>exec()</code> 的方式, 因为匹配不到之时返回的结果为 <strong>null</strong></p>
<p>因此我们可以通过下面的方法, 来全局匹配文本的特定部分</p>
<pre><code class="language-ts">const tex = `\\documnetclass{article}\n\\usepackage{sdfsfsdf}\n\\usepackage{9ubb}\n\\usepackage{example}`

const usepackageRegex = /\\usepackage\s*(\[([a-zA-Z0-9 ]+)\])?\s*\{([a-zA-Z0-9\-]+)\}/g

let pack

while ((pack = usepackageRegex.exec(tex)) !== null) {
    console.log(pack)  // 注意这里的打印值
}
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-160-相交链表]]></title>
        <id>https://ibert.me/posts/zh/Leetcode-160-相交链表.html</id>
        <link href="https://ibert.me/posts/zh/Leetcode-160-相交链表.html"/>
        <updated>2021-03-25T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>相交链表</h2>
<p>题目: <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></p>
<h2>破题</h2>
<p>一开始面对这题, 第一反应就是暴力去解题了。看了一眼题解, 双指针的解法特别的优雅。</p>
<p>如果两个单链表有相同节点的话, 那两个链表的指针必然 <strong>headA --&gt; headB</strong> 和 <strong>headB --&gt; headA</strong> 过程中有相遇, 相遇的时候节点就是交叉的节点。</p>
<p>举个栗子</p>
<pre><code class="language-js">const headA = [4, 1, 8, 4, 5]

const headB = [5, 0, 1, 8, 4, 5]

// pA: 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 -&gt; null -&gt; 5 -&gt; 0 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 -&gt; null
// pB: 5 -&gt; 0 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 -&gt; null -&gt; 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5 -&gt; null
</code></pre>
<h2>题解</h2>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) return null
    let pA = headA, pB = headB
    while(pA !== pB) {
        pA = pA === null ? headB : pA.next
        pB = pB === null ? headA : pB.next
        console.log(&quot;pA&quot;, pA)
        console.log(&quot;pB&quot;, pB)
    }
    return pA
};

// 控制台输出:
// pA [1,8,4,5]
// pB [6,1,8,4,5]
// pA [8,4,5]
// pB [1,8,4,5]
// pA [4,5]
// pB [8,4,5]
// pA [5]
// pB [4,5]
// pA null
// pB [5]
// pA [5,6,1,8,4,5]
// pB null
// pA [6,1,8,4,5]
// pB [4,1,8,4,5]
// pA [1,8,4,5]
// pB [1,8,4,5]
// pA [8,4,5]
// pB [8,4,5]
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-206-反转链表]]></title>
        <id>https://ibert.me/posts/zh/Leetcode-206-反转链表.html</id>
        <link href="https://ibert.me/posts/zh/Leetcode-206-反转链表.html"/>
        <updated>2021-03-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>反转链表</h2>
<p>题见: <a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p>
<h2>破题</h2>
<pre><code class="language-text">输入: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL
输出: 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; NULL
</code></pre>
<!-- more -->
<p>注释给的定义为</p>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
</code></pre>
<p>题解中给的遍历很好理解, 即把<code>next</code>指向上一个, 而当前的节点是下一个的上一个节点, 需要定义一个变量<code>prev</code>储存为下一个节点使用的上一个节点(也就是当前节点), 最后的返回值必定为最后保存的<code>prev</code>(此时迭代已经越界)</p>
<h2>题解</h2>
<pre><code class="language-js">/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null
    let curr = head  // 初始化当前节点
    while(curr) {
        const next = curr.next  // 储存下一个节点, 需要反转
        curr.next = prev  // 反转链表
        prev = curr  // 保存反转之后的链表
        curr = next  // 继续迭代
    }
    // 返回最后的最前
    return prev
}
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-215-数组中的第K个最大元素]]></title>
        <id>https://ibert.me/posts/zh/Leetcode-215-数组中的第K个最大元素.html</id>
        <link href="https://ibert.me/posts/zh/Leetcode-215-数组中的第K个最大元素.html"/>
        <updated>2021-03-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>数组中的第K个最大元素</h2>
<p>题见: <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p>
<h2>破题</h2>
<p>题目意思就是排序之后, 然后找到第几大的数字(不去重)</p>
<!-- more -->
<h2>题解</h2>
<p>其实整个题就两部分, 一个是排序, 另一个是取值</p>
<pre><code class="language-js">/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    const afterSorted = nums.sort((a, b) =&gt; b - a)  // 先从大到小排序(不去重)
    return afterSorted[k - 1]  // 再返回值
}
</code></pre>
<blockquote>
<p>需要注意的是, js的<code>sort()</code>函数排序是首字符的ASCII码, 如果数字超过个位数那排的结果是错的</p>
</blockquote>
<p>从大到小排</p>
<pre><code class="language-js">sort((a, b) =&gt; b - a)
</code></pre>
<p>从小到大排</p>
<pre><code class="language-js">sort((a, b) =&gt; a - b)
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode-3-无重复字符的最长子串]]></title>
        <id>https://ibert.me/posts/zh/Leetcode-3-无重复字符的最长子串.html</id>
        <link href="https://ibert.me/posts/zh/Leetcode-3-无重复字符的最长子串.html"/>
        <updated>2021-03-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>无重复字符的最长子串</h2>
<p>题目: <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<h2>破题</h2>
<h3>自己想的解法</h3>
<p>其实整个流程大概分为两步</p>
<ol>
<li>分割字符, 构成字符集</li>
<li>根据字符集遍历, 然后组合出子串</li>
</ol>
<!-- more -->
<p>处理的临界情况为</p>
<ul>
<li>处理字符串长度为零的情况</li>
</ul>
<pre><code class="language-js">// 在js中下面的处理都可以
if (!s)  // 这是利用了js的 !&quot;&quot; === false的特性

if (s.length === 0)
</code></pre>
<ul>
<li>处理字符串都是相同的字符</li>
</ul>
<pre><code class="language-js">// 这里利用了es6的Set集合这一特性
[...new Set(s.split(&quot;&quot;))].length === 1
// s ---&gt; 字符数组 ---&gt; Set去重 ---&gt; 去重之后的数组长度
</code></pre>
<ul>
<li>
<p><code>strBin</code>为所有字串的&quot;桶&quot;</p>
<ul>
<li>所有的单字符都是子串, 扔到桶里去</li>
<li>遍历越界时, 将之前组合的子串, 扔到桶里去</li>
<li>每次字符桶里已经有字符了, 把之前的组合子串扔到桶里去</li>
<li>遍历当前字符连续个数大于1时, 把之前的子串组合当前字符扔到桶里去</li>
</ul>
</li>
<li>
<p>返回<code>strBin</code>按照子串长度排序, 从而得到最后的答案</p>
</li>
</ul>
<h3>滑动窗口解法</h3>
<p>本质上来说, 跟自己想的解法没太大的区别, 但是滑动窗口把检查重复和遍历这些事情放在一起做了</p>
<p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/">官方题解</a>的分析流程为:</p>
<ul>
<li>以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；</li>
<li>以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；</li>
<li>以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；</li>
<li>以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；</li>
<li>以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；</li>
<li>以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；</li>
<li>以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；</li>
<li>以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。</li>
</ul>
<p>分析流程:</p>
<ul>
<li>遍历字符串</li>
<li>以当前的字符为起始, 向后遍历找到无重复的子串</li>
</ul>
<h2>题解</h2>
<h3>自行实现的版本</h3>
<pre><code class="language-js">/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    // 处理字符串长度为零
    if (s.length === 0) return 0

    // 处理字符串都相同字母的情况
    if ([...new Set(s.split(&quot;&quot;))].length === 1) {
        return 1
    }

    // 存储字符集个数
    let charList = []
    let pos = 0 // 字符集指针
    let sum = 0 // 字符指针
    for (let i = 0; i &lt; s.length; i++) {
        if (i === 0) {
            charList.push([s[i], 1])
        } else if (s[i] === s[i - 1] &amp;&amp; s[i - 1] !== undefined) {
            // 存储
            charList[pos][1] += 1
        } else {
            charList.push([s[i], 1])
            pos += 1
        }
        sum = i + 1
    }

    // 子串收集桶
    let strBin = []
    pos = 0

    // 无法处理单字母emmmm
    while (!!charList[pos]) {
        // 字符桶
        let bin = []
        let strTmp = &quot;&quot;
        for (let i = pos; i &lt;= charList.length; i++) {
            if (i === pos) {
                // 初始化遍历
                strTmp = charList[pos][0]
                bin.push(charList[pos][0])
                strBin.push([charList[pos][0], 1])
            } else if (!charList[i]) {
                strBin.push([strTmp, strTmp.length])
                break
            } else if (bin.includes(charList[i][0])) {
                strBin.push([strTmp, strTmp.length])
                break
            } else if (charList[i][1] &gt; 1) {
                strTmp += charList[i][0]
                strBin.push([strTmp, strTmp.length])
                break
            } else {
                // 记录
                bin.push(charList[i][0])
                strTmp += charList[i][0]
            }
        }
        pos += 1
    }

    return strBin.sort((a, b) =&gt; b[1] - a[1])[0][1]
};
</code></pre>
<h3>滑动窗口</h3>
<p>官方题解的js版本为:</p>
<pre><code class="language-js">var lengthOfLongestSubstring = function(s) {
    // 哈希集合，记录每个字符是否出现过
    const occ = new Set();
    const n = s.length;
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    let rk = -1, ans = 0;
    for (let i = 0; i &lt; n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.delete(s.charAt(i - 1));
        }
        while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) {
            // 不断地移动右指针
            occ.add(s.charAt(rk + 1));
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = Math.max(ans, rk - i + 1);
    }
    return ans;
};
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[写给程序员的MATLAB快速上手教程]]></title>
        <id>https://ibert.me/posts/zh/写给程序员的MATLAB快速上手教程.html</id>
        <link href="https://ibert.me/posts/zh/写给程序员的MATLAB快速上手教程.html"/>
        <updated>2021-03-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>MATLAB更多的是一门面向非程序员的计算机编程语言, 因此其教程往往对于程序员同学来说并不算是很&quot;友好&quot;。因为自己的本科毕业论文是利用MATLAB来研究光的波动性, 之前因为教程的问题一直感觉MATLAB这个语言奇奇怪怪的, 故作为一个程序员的视角自己来写一份教程。本教程会对比其它语言或者编程语言通用的概念来书写, 所以需要至少有一门语言的编程经验。</p>
<h2>基本架构图</h2>
<ul>
<li>参考书籍: 北京航空航天大学出版的由胡章芳老师编写的《matlab仿真及其在光学课程中的应用》（第二版）</li>
</ul>
<p>使用软件:</p>
<ul>
<li>MindLine</li>
<li>Matlab</li>
<li>GNU Octave</li>
<li>Anoc Octave Pro Editor</li>
</ul>
<!-- more -->
<img src="https://ibert.me/img/matlab基础.jpg" />
<h2>变量</h2>
<h3>标识符</h3>
<p>MATLAB的标识符的规则符合下面的正则表达式:</p>
<blockquote>
<p>^[A-Za-z]{1}[A-Za-z0-9_]*</p>
</blockquote>
<ul>
<li>标识符只能以 <strong>英文字母</strong> 开头</li>
<li>标识符只能由 <strong>大小写字母、数字、下划线（_）</strong> 组成</li>
<li>标识符不能与 <strong><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a> 和 预定义量</strong> 重复</li>
<li>长度不超过 <strong>namelengthmax</strong> （不同的MATLAB版本长度也不一样）</li>
</ul>
<blockquote>
<p>那本书把预定义量叫做const, 这个跟我们常规编程语言理解的const（常量）意义不太一样, 因此我翻译为了 <strong>预定义量</strong></p>
</blockquote>
<h4>关键字</h4>
<blockquote>
<p>执行<code>iskeyword</code>输出关键字</p>
</blockquote>
<pre><code class="language-matlab">iskeyword

% ans =

%   20×1 cell 数组

%     {'break'     }
%     {'case'      }
%     {'catch'     }
%     {'classdef'  }
%     {'continue'  }
%     {'else'      }
%     {'elseif'    }
%     {'end'       }
%     {'for'       }
%     {'function'  }
%     {'global'    }
%     {'if'        }
%     {'otherwise' }
%     {'parfor'    }
%     {'persistent'}
%     {'return'    }
%     {'spmd'      }
%     {'switch'    }
%     {'try'       }
%     {'while'     }
</code></pre>
<h3>默认变量</h3>
<p>MATLAB是一门默认支持REPL的语言而且与计算有关, 因此MATLAB定义了一个默认变量 <code>ans</code> 作为未赋值的计算结果的赋值, eg.</p>
<pre><code class="language-matlab">2 * 3

% 输出: ans = 6
</code></pre>
<p>未完待续...</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10体验优化策略]]></title>
        <id>https://ibert.me/posts/zh/Win10体验优化策略.html</id>
        <link href="https://ibert.me/posts/zh/Win10体验优化策略.html"/>
        <updated>2021-02-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>随着代码越写越多，越来越发现自己有很严重的精神洁癖。尤其在对于自己日常使用的软件体验上，无论是手机还是PC。这篇帖子着重讲述，这么多年来对于Win10系统使用的体验优化，还有对于C盘清理的经验。</p>
<p>希望Win10体验不会随着时间而变得更差，首先需要养成一个良好的使用习惯。下面的每一节将从不同的纬度提升PC的使用体验，无论是基础软件、辅助功能还是高级玩法。</p>
<!-- more -->
<h2>使用PC您需要做的事情（含基础软件）</h2>
<p>明确一个观念，PC是你的个人财产，不要被任何第三方厂商所绑架。所以，为了您的PC更好报于您更好的体验，请在每一次安装软件之前谨慎！</p>
<blockquote>
<p>这里所有的优化体验都基于您的电脑是一个素机的情况下（参考<em>素人</em>的释义）。如果您是小白，但凡您的电脑出现了2345、360系、百度系、腾讯系等的任何软件，请优先考虑<strong>重装</strong>，而不是尝试去做清理！</p>
</blockquote>
<h3>对于刚拆封的电脑</h3>
<ul>
<li>
<p>检查您的C盘，看容量是否少于100G（用于开发等应不少于120G）；如果是，建议您在下面检查软件之后，直接重装调整分区；如果您只有一个盘，建议分给C盘不少于120G的空间，其他空间给D盘</p>
</li>
<li>
<p>实现检查您的<strong>程序与功能</strong>，<code>控制面板 ---&gt; 卸载程序</code></p>
</li>
</ul>
<p><img src="https://ibert.me/img/Snipaste_2021-02-02_16-03-42.png" alt="图片"></p>
<blockquote>
<p>因为某些厂商本来就不是什么好东西，自己会自带某些推广的软件，实际点名<strong>联想</strong>。如果您的电脑不是联想的游戏本系列，没有自带电竞版的电脑管家，建议包含您所不必要的软件和联想电脑管家一起干掉。它存在的唯一用处对于非游戏本来说，几乎只有更新驱动，驱动的更新频率极低。如果你对此并不是必要，就直接卸掉，反正用的时候官网可以继续下载。</p>
</blockquote>
<ul>
<li>安装<strong>必要</strong>的软件</li>
</ul>
<p>对于国内绝大部分人来说，日常使用的软件根本没有多少。下面会列举最常用的建议</p>
<ol>
<li>使用正版的<code>Microsoft Office</code>，而不是广告里找功能的<code>WPS</code></li>
<li>使用默认的<code>Win10 自带输入法</code>，而不是第三方输入法（第三方输入法会导致直接广告和个人信息被收集）</li>
<li>使用默认的<code>Windows Defender</code>也要好于任何国内的杀毒软件，您可以外加<code>火绒安全软件</code>来做<strong>防御</strong>。如果自带了送的<code>迈克菲McAFee</code>，白嫖完之后可以卸掉了</li>
<li>如果您需要使用<code>腾讯QQ</code>，请使用<code>Tim</code>而不是<code>QQ</code></li>
<li>浏览器在最新的Win10中已经内置了Chromium版的Edge，如果不是，请<a href="https://www.microsoft.com/zh-cn/edge">官网</a>升级您的Edge。除此之外，您还可以使用Chrome和Firefox，而非包括但不限于 “2345极速浏览器”、“360安全浏览器”、“360极速浏览器”、“QQ浏览器”等，如果您希望您的电脑广告满天飞的话</li>
<li>有些电脑可能会不带压缩软件，或者带了Winrar。如果自带了Winrar，请卸掉，可以使用<strong>无广告版本的</strong>bandzip（bandzip后面的版本出现了广告）和PeaZip</li>
</ol>
<h3>对于使用了一段时间</h3>
<ul>
<li>打开您的<strong>程序与功能</strong>，<code>控制面板 ---&gt; 卸载程序</code></li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_16-03-42.png" alt="图片"></p>
<ul>
<li>卸掉2345系的任何软件</li>
</ul>
<p>包括但不限于2345网址导航、2345看图王、2345加速浏览器、2345安全卫士、2345王牌浏览器、2345王牌输入法等，您随便去搜一下就知道这个东西有多恶心，希望这家公司早日倒闭。您的电脑如果在电脑城购买或线下实体店购买，极有可能携带着这些“病毒”，2345是有推广费的</p>
<blockquote>
<p>如果说360是流氓的话，毫不客气的说2345就是强奸犯，但凡您的电脑里出现弹窗、捆绑下载等，仔细注意这个玩意</p>
</blockquote>
<ul>
<li>卸掉所有除<strong>360杀毒</strong>（如果您迫切需要的话）的360系软件</li>
</ul>
<p>360安全团队在杀毒的领域很厉害，但请记住“免费的永远是最贵的”，<strong>360杀毒</strong>属于调教之后还可用的，其他的碰都不要碰。包括但不限于360安全卫士、鲁大师、360极速浏览器、360安全浏览器等，自带的Windows Defender已经足够满足个人用户的需求</p>
<ul>
<li>卸掉几乎所有的腾讯系和百度系的软件</li>
</ul>
<p>腾讯系所必要使用的受社交的绑架，对于普通用户来说只有QQ和微信，QQ极其臃肿而且充满了大量的不必要营销、广告、捆绑下载等。如果你在电脑上没有这些需求，那建议一个都别装，腾讯系所有的数据缓存都在C盘里</p>
<p>现在除了百度搜索之外，我实在想不到有什么不可以替代百度的使用场景，百度搜索也可以用油猴的脚本直接去掉广告。</p>
<ul>
<li>卸掉所有给您带来不好体验的软件，但凡它们是可替代的</li>
</ul>
<h2>必要的设置和良好的习惯</h2>
<h3>必要的设置</h3>
<ul>
<li>修改<code>Microsoft Store</code>默认的数据位置，<code>设置 ---&gt; 系统 ---&gt; 储存 ---&gt; 更改新内容的保存位置</code></li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_18-06-51.png" alt="图片"></p>
<p><img src="/img/Snipaste_2021-02-02_18-08-20.png" alt="图片"></p>
<ul>
<li>无论是不是新机，请检查浏览器的主页锁定情况，国内流氓尤其喜欢篡改浏览器主页</li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_16-56-17.png" alt="图片"></p>
<ul>
<li>开启弹窗拦截，以免存在漏网之鱼</li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_16-58-11.png" alt="图片"></p>
<ul>
<li>检查启动项，删掉不必要自启动的软件，会显著提高开机速度</li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_16-59-42.png" alt="图片"></p>
<ul>
<li>检查右键管理，以免过多的右键菜单栏占用</li>
</ul>
<p><img src="/img/Snipaste_2021-02-02_17-01-42.png" alt="图片"></p>
<ul>
<li>对于Adobe系的软件(eg. PhotoShop)</li>
</ul>
<p>请修改首先首选项，再去下载软件</p>
<h3>良好的习惯</h3>
<ol>
<li>不要下载来路不明的软件</li>
<li>不要下载不必要的国内大厂软件</li>
<li>仔细使用搜索引擎和知乎等，查看软件评价</li>
<li>去官网下载，而不是所谓的“应用市场”或“软件管家”</li>
<li>使用自定义路径的方式来安装软件，而非默认安装！系统盘和软件安装盘请分离！</li>
<li>使用可替代的开源软件可能会是一个更好的选择</li>
</ol>
<h2>辅助功能</h2>
<p>为了提高PC的体验，可能需要一些辅助的工具，来达到更好的用户体验，下面列举了一些不错的软件</p>
<blockquote>
<p>所有的软件都在 <a href="https://nucotech.github.io/RecommendProjects/#/tools/?id=windows%e5%b9%b3%e5%8f%b0">NucoTech推荐的项目</a> 有所推荐</p>
</blockquote>
<ul>
<li>QuickLook 快速预览文件</li>
<li>Snipaste  极强的截屏软件</li>
<li>PotPlayer  最强的播放器</li>
<li>Wallpaper Engine  保守好评的壁纸软件</li>
<li>Internet Download Manager / XDM  多线程下载工具</li>
<li>Auto Dark Mode  自动切换夜间模式</li>
<li>flu.x  根据时间自动调节色温</li>
<li>utools  Alt+Space快速解锁技能，支持自己开发插件</li>
</ul>
<blockquote>
<p>浏览器优化可以参考 <a href="https://nucotech.github.io/RecommendProjects/#/tools/?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e6%8f%92%e4%bb%b6">浏览器插件</a></p>
</blockquote>
<h2>高级玩法</h2>
<blockquote>
<p>本人强烈不建议小白乱更改电脑设置，此部分及之后的，您需要知晓您的每一步所可能导致的后果</p>
</blockquote>
<h3>使用更专业的杀毒软件</h3>
<p>火绒主要在于防御，杀毒推荐卡巴斯基和小红伞，自己实际使用卡巴斯基感觉有点卡，并且对于网页浏览的侵入特别强</p>
<h3>更改到公共DNS</h3>
<p>前段时间看到火绒安全通报了联通官网被挂马之后，可笑死我了，这些厂商经常污染DNS导致了很多操蛋的事情。我在 <a href="./%E6%8F%90%E5%8D%87%E5%9B%BD%E5%86%85GitHub%E8%AE%BF%E9%97%AE%E4%BD%93%E9%AA%8C.md">提升国内GitHub访问体验</a> 中也提到过</p>
<p>还是建议使用AliDNS，其他的<code>8.8.8.8</code>和<code>114.114.114.114</code>也行</p>
<h3>使用SwitchHosts!更改Hosts</h3>
<p>直接修改Windows系统的hosts文件感觉特别难受，可以使用 <a href="https://github.com/oldj/SwitchHosts">SwitchHosts!</a>，可以订阅自动更新Hosts</p>
<h2>清理C盘</h2>
<p>Windows的目录结构设计让我感到极其难受，我更喜欢类Unix系统的挂载。Windows作为系统盘的C盘，经常会因为使用时间的而变得越来越空间不够，有些方式可能不太适合小白，请谨慎操作</p>
<h3>清理缓存等基础垃圾</h3>
<p>使用垃圾清理可以清理缓存、日志等最基础的垃圾</p>
<p><img src="/img/Snipaste_2021-02-02_17-33-03.png" alt="图片"></p>
<h3>工具清除深层垃圾</h3>
<p>可以使用 <a href="http://www.chuyu.me/zh-Hans/">Dism++</a> 来做更深层次的清理，如果您不知道您对某一项的勾选会导致什么后果，那就使用默认的配置就好了</p>
<h3>手动清理可能并不算是垃圾</h3>
<blockquote>
<p>本部分可能会导致不可逆的后果，请谨慎对待</p>
</blockquote>
<ul>
<li>优化Windows系统导致的占用</li>
</ul>
<p>参考知乎专栏 <a href="https://zhuanlan.zhihu.com/p/87565681">移除pagefile.sys和hiberfil.sys获取C盘空间</a></p>
<blockquote>
<p>需要注意的是如果要删除hiberfil.sys文件，其命令是<code>powercfg -h off</code></p>
</blockquote>
<ul>
<li>手动分析和清理某些数据</li>
</ul>
<p>这里使用的工具是WinDirStat，每个人的文件内容都不完全相同，酌情清理</p>
<p><img src="/img/Snipaste_2021-02-02_18-10-20.png" alt="图片"></p>
<blockquote>
<p>Program Files(x86)、Program Files、ProgramData、User目录下面的部分文件按大小和用途，可以部分清理</p>
</blockquote>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[提升国内GitHub访问体验]]></title>
        <id>https://ibert.me/posts/zh/提升国内GitHub访问体验.html</id>
        <link href="https://ibert.me/posts/zh/提升国内GitHub访问体验.html"/>
        <updated>2021-01-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>概述</h2>
<p>提升GitHub的体验, 主要是下面几个方面的提升</p>
<ul>
<li>无障碍访问<code>github.io</code>域名的网站</li>
<li>无障碍加载GitHub的静态资源, 比如图片</li>
<li>通过cdn快速获取GitHub可获取的资源</li>
</ul>
<!-- more -->
<h2>无障碍访问<code>github.io</code></h2>
<p>之前访问<code>xxx.github.io</code>这类GitHub Pages的网站的时候总出现404的情况, 甚至连挂梯子都没用, 这是非常不合理的。后来在V2EX上面有老哥提到了一个很难被发现的问题, 国内的电信运营商污染DNS。往常我以为它们就喜欢搞一些广告什么的, 结果非常的操蛋。之后就ping了一下<code>herberthe.github.io</code>我自己的GitHub Pages, 非常amazing啊结果是<code>127.0.0.1</code>。关于hosts和DNS这些不了解的话, 建议直接百度, 这里就不解释了。</p>
<p>我们访问<code>github.io</code>这类域名的网站通常需要经历的过程拓扑为: 本地局域网 --- 运营商网络(就不区分各层局域网了) --- 公网 --- 目标的DNS服务 --- 目标服务器</p>
<p>以<code>www.baidu.com</code>为例, 咱们用<code>tracert</code>追踪一下路由跳转情况(使用的Windows cmd), 其中标注的ip路由数据来源于<a href="https://www.ip138.com/">ip318</a>和站长之家的站长工具, 也可能不是很准确</p>
<pre><code class="language-text">通过最多 30 个跃点跟踪
到 www.a.shifen.com [14.215.177.38] 的路由:

  1    &lt;1 毫秒   &lt;1 毫秒   &lt;1 毫秒 OPENWRT [192.168.7.1]   // 路由器
  2     2 ms     1 ms    &lt;1 毫秒 192.168.1.1              // 本地网关
  3     3 ms     4 ms     2 ms  100.100.128.1            // 保留地址 NAT局域网
  4     4 ms     5 ms     4 ms  61.132.183.81            // 安徽省 宣城市 电信
  5     5 ms    12 ms     8 ms  202.102.219.81           // 安徽省 合肥市 电信
  6     *        *        *     请求超时。
  7    38 ms     *        *     113.96.4.90              // 广东省 广州市 电信
  8     *       29 ms    30 ms  113.96.11.78             // 广东省 广州市 电信
  9    26 ms    25 ms    26 ms  121.14.67.146            // 广东省 广州市 电信
 10     *        *        *     请求超时。
 11    25 ms    25 ms    25 ms  14.215.177.38            // 广东省 广州市 电信 idc机房
</code></pre>
<p>以<code>github.com</code>为例</p>
<pre><code class="language-text">通过最多 30 个跃点跟踪
到 github.com [140.82.112.3] 的路由:

  1     1 ms    &lt;1 毫秒    1 ms  OPENWRT [192.168.7.1]                             // 路由器
  2     3 ms     2 ms     1 ms  192.168.1.1                                       // 本地网关
  3     4 ms     3 ms     4 ms  100.100.128.1                                     // 保留地址 NAT局域网
  4     6 ms     3 ms     5 ms  60.173.80.49                                      // 安徽省 宣城市 电信
  5     8 ms     8 ms     7 ms  61.132.190.169                                    // 安徽省 合肥市 电信
  6    20 ms    22 ms    21 ms  202.97.96.181                                     // 上海市 中国电信骨干网接入点
  7    30 ms    29 ms    30 ms  202.97.24.190                                     // 中国 电信骨干网
  8    16 ms    16 ms    15 ms  202.97.12.190                                     // 中国 电信骨干网
  9   227 ms     *      221 ms  202.97.74.98                                      // 中国 电信骨干网
 10   228 ms   239 ms   229 ms  118.85.205.246                                    // 中国 电信骨干网
 11   270 ms   269 ms   269 ms  ae1.cs1.ams17.nl.eth.zayo.com [64.125.29.78]      // 美国 zayo集团骨干网
 12   262 ms     *        *     ae4.cs3.ams10.nl.eth.zayo.com [64.125.28.37]      // 美国 zayo集团骨干网
 13     *      271 ms     *     ae10.cs1.lhr15.uk.eth.zayo.com [64.125.29.17]     // 美国 zayo集团骨干网
 14     *        *        *     请求超时。
 15     *        *        *     请求超时。
 16     *        *        *     请求超时。
 17   271 ms   270 ms     *     ae1.ter1.iad10.us.zip.zayo.com [64.125.25.137]    // 美国 zayo集团骨干网
 18   266 ms   271 ms   268 ms  209.66.120.181.IPYX-243981-004-ZYO.zip.zayo.com [209.66.120.181]  // 美国 纽约州威彻斯特县怀**莱恩市abovenet通信股份有限公司
 19     *        *        *     请求超时。
 20     *        *        *     请求超时。
 21     *        *        *     请求超时。
 22   279 ms   279 ms   278 ms  github.com [140.82.112.3]                         // 美国 华盛顿州西雅图github公司
</code></pre>
<p>如果运营商在中间搞鬼的话, 就算挂梯子也没办法绕过, 因此需要修改映射公网的DNS。类似<code>8.8.8.8</code>和<code>114.114.114.114</code>这些公用DNS大家都比较了解, 但是使用的人并不少, 体验也并没有提升多少。在这里建议使用<a href="https://www.alidns.com/setup">AliDNS的公用DNS</a>做替代, 我寻思阿里不会那么闲去污染GitHub的DNS</p>
<p>遵循AliDNS的教程, 在运营商污染DNS这一块的问题基本上已经解决了, 如果还是访问不了的话, 很可能是被墙了。那一波就在中国电信骨干网的GFW了, 只能各显神通了, 正常的话不会这样的。</p>
<h2>无障碍加载GitHub的静态资源</h2>
<p>经常有这么个情况, GitHub访问没问题, 但是头像还有<code>README.md</code>里面的图片加载不出来, 因为GitHub的静态资源不是<strong><a href="http://github.com">github.com</a></strong>这个域名</p>
<p>而很可能是下面这些</p>
<pre><code class="language-text">github.githubassets.com
camo.githubusercontent.com
github.map.fastly.net
github.global.ssl.fastly.net
gist.github.com
github.io
github.com
api.github.com
raw.githubusercontent.com
user-images.githubusercontent.com
favicons.githubusercontent.com
avatars5.githubusercontent.com
avatars4.githubusercontent.com
avatars3.githubusercontent.com
avatars2.githubusercontent.com
avatars1.githubusercontent.com
avatars0.githubusercontent.com
codeload.github.com
github-cloud.s3.amazonaws.com
github-com.s3.amazonaws.com
github-production-release-asset-2e65be.s3.amazonaws.com
github-production-user-asset-6210df.s3.amazonaws.com
github-production-repository-file-5c1aeb.s3.amazonaws.com
githubstatus.com
github.community
</code></pre>
<p>最简单的方法其实是挂梯子, 不过也可以通过修改<strong>hosts</strong>文件的方法来改。在类Unix平台比较简单, 也就是<code>vim /etc/hosts</code>的事情。但是要一个个找IP是个非常操蛋的事情。。</p>
<p>在此建议参考这个项目 <a href="https://github.com/521xueweihan/GitHub520">GitHub520</a>, 然后参考教程使用 <a href="https://github.com/oldj/SwitchHosts">SwitchHosts!</a> 这个开源软件解决<strong>hosts</strong>修改的问题</p>
<blockquote>
<p>不过GitHub520那个项目是GitHub Action实现的, 可能存在能用但是不是最快的节点的情况, 实在不行就自己部署更新也没啥问题</p>
</blockquote>
<h2>通过cdn快速获取GitHub可获取的资源</h2>
<p>上面那些解决了, 咱们使用GitHub基本上没啥问题了。但是, GitHub Release和GitHub仓库下载的速度非常的难受!!!</p>
<p>在<a href="https://github.com/NucoTech/nuco-backend-cli">nbc</a>这个项目的实践过程中就屡次被这个问题搞得非常恼火, 油猴上面其实有针对GitHub专门写了一些插件, 也专门有一些cdn来提高GitHub下载慢的情况, 下面是一些总结也可以用于开发</p>
<h3>获取分支资源</h3>
<p>正常情况下, GitHub的仓库分支资源其实是不能单独下载的, 那咋办? 很简单, 通过cdn完成</p>
<p>举个例子, 我要下载<code>nuco-backend-cli</code>下面的<code>install.darwin.sh</code>, 可以通过访问下面的cdn获取</p>
<pre><code class="language-text">https://cdn.jsdelivr.net/gh/NucoTech/nuco-backend-cli@main/install.darwin.sh
</code></pre>
<p><a href="https://www.jsdelivr.com/">jsdelivr</a>这个cdn其实前端的小伙伴应该是非常熟悉的, 前端的npm包里面的静态资源都可以通过这个cdn来直接引用</p>
<p>官网也贴心的, 给了下面的使用格式</p>
<pre><code class="language-text">https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;@&lt;分支&gt;/&lt;文件名&gt;
</code></pre>
<h3>获取GitHub Release资源</h3>
<p>这个cdn就比较多了, 列举几个, 所有的都是以<code>nbc.exe</code>资源获取为例的</p>
<pre><code class="language-text">https://gh.con.sh/https://github.com/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe

https://gh.api.99988866.xyz/https://github.com/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe

https://download.fastgit.org/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe

https://github.xiu2.xyz/https://github.com/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe

https://ghproxy.com/https://github.com/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe

https://pd.zwc365.com/seturl/https://github.com/NucoTech/nuco-backend-cli/releases/download/v1.3.0/nbc.exe
</code></pre>
<p>你也可以使用插件<a href="https://greasyfork.org/scripts/412245">GitHub增强 - 高速下载</a> 这个油猴脚本来实现</p>
<p>其中的部分cdn可以传入下面的格式, 实现获取latest release里面的资源</p>
<pre><code class="language-text">https://github.com/&lt;用户名&gt;/latest/releases/download/&lt;资源名&gt;
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端样式优先级的问题]]></title>
        <id>https://ibert.me/posts/zh/前端样式优先级的问题.html</id>
        <link href="https://ibert.me/posts/zh/前端样式优先级的问题.html"/>
        <updated>2020-07-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>选择器类型</h2>
<ul>
<li>ID选择器</li>
<li>类选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>类型选择器</li>
<li>伪元素选择器</li>
<li>!important</li>
</ul>
<h2>参考</h2>
<ul>
<li><a href="https://www.w3.org/TR/selectors/#specificity">W3 Specificity</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端隐藏元素的区别]]></title>
        <id>https://ibert.me/posts/zh/前端隐藏元素的区别.html</id>
        <link href="https://ibert.me/posts/zh/前端隐藏元素的区别.html"/>
        <updated>2020-07-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>隐藏元素的方法</h2>
<p>前端如果设置元素不可见，可以使用<code>display: none</code> <code>visibility:hidden</code> <code>opacity: 0</code></p>
<!-- more -->
<h2>空间占据</h2>
<ul>
<li><code>display: none</code>隐藏是不占用空间的，会产生回流和重绘</li>
<li><code>visibility: hidden</code>和<code>opacity: 0</code>隐藏了元素，但是仍然占据着空间，只会引起页面的重绘</li>
</ul>
<blockquote>
<p>回流(Layout): 根据生成的渲染树进行回流，得到节点的几何信息；<br>
重绘(Painting): 根据渲染树得到的几何信息，得到节点的绝对像素</p>
</blockquote>
<h2>子元素继承</h2>
<ul>
<li><code>display: none</code>这个父元素都不存在了</li>
<li><code>visibility: hidden</code>会被继承，通过对子元素设置<code>visibility: visible</code></li>
<li><code>opacity: 0</code>会被继承，子元素不能设置<code>opacity: 1</code>显示，因为<code>opacity</code>这个本就是设置透明度的！</li>
</ul>
<h2>事件触发</h2>
<ul>
<li><code>display: none</code>元素不存在，无法触发绑定事件</li>
<li><code>visibility: hidden</code>绑定事件无法触发</li>
<li><code>opacity: 0</code>绑定事件是可以触发的</li>
</ul>
<h2>过渡动画</h2>
<p><code>transition</code>只对可数值化的属性有效，因此只有<code>opacity</code>有效</p>
<h2>一个需求</h2>
<p>建立一个搜索框，当<code>hover</code>搜索框的时候，<code>搜索提示元素</code>通过过渡动画展示；当仅<code>focus</code>搜索框时，<code>搜索提示元素</code>不展示，但搜索框长度通过过渡动画使宽度拉长；要求点击搜索提示框的内容时，可以跳转其他页面。</p>
<p>需求分析:</p>
<ul>
<li>定位问题：输入框和搜索提示的节点拥有父节点，并且父节点的<code>position</code>为<code>relative</code>，这样就可以设置<code>搜索提示框</code>的绝对定位来设置位置</li>
<li>事件处理问题：使用父元素的<code>hover</code>伪类控制子元素<code>搜索提示框</code>的<code>opacity</code>和<code>高度</code>；使用输入框的<code>focus</code>伪类撑起父元素的宽度；这样当整体被<code>hover</code>时，<code>搜索提示框</code>可以被展示，并且当点击<code>搜索提示框</code>里面的内容那一瞬间，输入框焦点失去，但事件可以被触发，也不用担心会被误触的情况</li>
</ul>
<blockquote>
<p>示例代码 <a href="https://github.com/NUCOSC/Nucers/blob/dev/site/components/common/NavBar.tsx#L173">NavBar</a>和<a href="https://github.com/NUCOSC/Nucers/blob/dev/site/styles/components/common/NavBar.css#L32">样式</a></p>
</blockquote>
<h2>引用</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></li>
<li><a href="https://blog.csdn.net/github_39673115/article/details/77926351">~之间的区别</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS中的position]]></title>
        <id>https://ibert.me/posts/zh/CSS中的position.html</id>
        <link href="https://ibert.me/posts/zh/CSS中的position.html"/>
        <updated>2020-07-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>position</h2>
<p>CSS的position属性用于元素的定位，可以实现下拉列表、提醒框等样式。分为：<code>absolute</code> <code>fixed</code> <code>relative</code> <code>static</code> 和 <code>sticky</code></p>
<!-- more -->
<h2>static</h2>
<p><code>static</code>为默认值，不脱离文档流，并且<code>TRBL</code>属性不起作用。</p>
<h2>relative</h2>
<p><code>relative</code>相对定位，与<code>static</code>不同。<code>relative</code>的<code>TRBL</code>属性相对于<em>原本元素所在位置</em>进行定位，与<code>absolute</code>不同</p>
<h2>absolute</h2>
<p><code>absolute</code>绝对定位，如果其父组件的position属性为<code>relative</code>，则其<code>top</code> <code>right</code> <code>bottom</code> <code>left</code>属性相对于父组件定位，如果不是则相对于全局定位，脱离文档流。</p>
<h2>fixed</h2>
<p><code>fixed</code>与<code>absolute</code>不同，<code>fixed</code>为相对可视窗口的定位，无论窗口如何滚动，<code>fixed</code>定位的位置不会因此发生改变。但是，最好不用跟<code>&lt;input/&gt;</code>元素放在一起使用，当<code>fixed</code>作为footer元素固定在底部时，会导致移动端阻挡输入框的问题。</p>
<h2>sticky</h2>
<p><code>sticky</code>属性类似于<code>relative</code>和<code>fixed</code>的结合，超出目标区域时与<code>fixed</code>相同。需要指定<code>TRBL</code>属性之一使之生效。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于for-editor的扩展开发及markedjs语法扩展的心得]]></title>
        <id>https://ibert.me/posts/zh/关于for-editor的扩展开发及markedjs语法扩展的心得.html</id>
        <link href="https://ibert.me/posts/zh/关于for-editor的扩展开发及markedjs语法扩展的心得.html"/>
        <updated>2020-04-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>关于<code>for-editor</code></h2>
<p>开始接触<code>for-editor</code>是因为想自己写一个基于Git的支持markdown的笔记本PC应用，常用开发框架是React、在PC端的开发工具的选择上选择了吃内存狂魔electron，就这样抱着能不造轮子就不造轮子的原则开始使用了<code>for-editor</code>（虽然之后没有打算继续开发）。<code>for-editor</code>如果对于语法的支持没有太高的要求的话，是一个非常优秀、简洁的编辑器组件。支持Tex渲染插入、mermaid流程图的支持、高级markdown或者扩展的markdown语法，随着需求的提升就准备了开始自己扩展语法之路，当然其中发现了很多需要优化和修改的地方。</p>
<h2>开发之路</h2>
<h3>通读源码</h3>
<p>源码可以从<a href="https://github.com/kkfor/for-editor">for-editor</a>中查看。</p>
<p>首先，阅读<code>package.json</code>。<code>package.json</code>是所有React组件开发必不可少的环节，在此之前还是需要足够了解工程的<code>README.md</code>的。在<code>package.json</code>里，源工程对于markdown解析所用的引擎为<code>marked.js</code>和<code>highlight.js</code>。在之前了解<code>markdown</code> --&gt; <code>HTML</code>的渲染学习的时候所用的是<code>marked.js</code>，好处是足够简洁，坏处是语法很少并且扩展要求并不低。</p>
<p>其次，对于源码结构的解读。<code>dist</code>为生成产物，<code>doc</code>为相关文档，<code>example</code>为演示文档，<code>src</code>为源码目录，<code>webpack</code>为配置项。在<code>src</code>下有<code>components</code>、<code>lib</code>和<code>index.tsx</code>，<code>components</code>为工具栏的组件，<code>lib</code>是开发的依赖和功能源码，<code>index.tsx</code>为整体的页面结构。</p>
<h3>发现的问题</h3>
<blockquote>
<p>这里提到的问题其实有一些是还没有完全修复的，有些问题真的存在了很多年了，至今我也没能想到比较好的解决办法。</p>
</blockquote>
<h4>响应式布局</h4>
<p>在现代web开发中，响应式布局对于用户体验来说是非常好的，但是在访问速度上相比加载速度会稍微慢一些。针对于高标准的用户体验，我选择了牺牲掉一些访问速度，当然对于纯的通过CSS实现响应式布局在某些时候根本达不到好的效果，是需要JavaScript来加buff的，这也为之后的开发其实还挖了一个坑，对此我不得不做出妥协，完全的响应式目前看来是做不到的。在下面，我也会阐述具体的坑到底是什么。</p>
<p>响应式布局方面我做出的优化是针对<code>900px</code>这个标准进行的分割，随着工具栏功能的拓展，原本工具栏的布局会溢出。因此对于没有二级菜单的工具栏button，我选择写在了more里，并且另开了<code>for-mobile</code>，<code>for-pc</code>，使用了<code>flex</code>布局来处理宽度不够换行处理的优化措施。在下一个坑没有遇到之前，这个方案我觉得解决的还算不错。（当然开了新得分支，还是被提了issue，主要是他遇到的浏览器尺寸在我测试的时候真的没有发现任何问题，很迷惑）</p>
<h4><code>mermaid</code>的引入</h4>
<p>这是我几个月都没有解决的问题，可能是打开方式不太对吧。。。参考了<code>mermaidAPI</code>和与<code>mermaid</code>开发者交流提了<code>issue</code>但是始终没有解决。难道mermaid真的是只能用已存在DOM节点来做渲染的吗？希望能有大佬带我深入了解一下。mermaid的渲染要写在主组件的生命周期里面，但是就我刚刚说的，如果已知存在，在什么时候插进去来触发渲染？最后我选择了原样插入，然后再触发渲染的方式，当我满心欢喜觉得一切都能如愿的时候。我发现真的能不能渲染出来都是薛定谔的猫:(然后不得不放弃，想想也真的可能跟后面那个深坑有关系，总有办法能解决这个问题，然后参考过CSDN的HTML代码，也就是我后来的考虑的深坑。对此，我移除了<code>mermaid</code>的渲染支持。</p>
<h4>修复js对于二级菜单的控制</h4>
<p>感谢<a href="https://github.com/ivanandonov">@ivanandonov</a>的issue，之前我并不太觉得点击关掉二级菜单很重要，其实也就是添加个关掉二级菜单的事件，问题不大。</p>
<h4>拓展<code>marked.js</code>的语法</h4>
<p>这是本部分最核心的内容了。如何去扩展<code>marked.js</code>的语法？？？我看到网上有很多小伙伴尝试去扩展语法，但是也有不少选择了放弃。</p>
<p>如果你想尝试去扩展语法，熟读<code>marked.js</code>的<a href="https://marked.js.org/#/README.md#README.md">使用指南</a>、<code>marked.js</code>的<a href="https://github.com/markedjs/marked">源码</a>和实现逻辑，当然还需要写正则表达式:)</p>
<p><code>marked.js</code>最牛逼的部分就在于正则表达式，就不重复匹配的问题，如何去用正则表达式去表示？因此重写renderer的时候我参考了很多源码部分的内容，这里就不针对<code>marked.js</code>详细展开介绍了，我只写一写我到底做了哪些事。</p>
<ul>
<li>抽离<code>highlight.js</code>。在原项目发现的问题之一就是——我如何去让使用者自行决定高亮的代码类型？我总不能把所有的语言都注册一遍吧？！不但增加了代码量，还需求不是很大，所以我选择了把<code>highlight.js</code>依赖给移除掉。让使用者传入<code>Hljs.highlightAuto</code>这个函数，其他的自己引入<code>highlight.js</code>然后自己注册就完事了。</li>
<li>引入<code>emoji</code>、<code>Tex</code>、<code>diff</code>语法、<code>mark</code>做行内高亮。这就涉及了不少的正则表达式，尤其是在<code>mark</code>这个渲染上，你总不能把每一句都拿正则循环跑吧，根本不实际。所以得先把高亮块抽离出来然后再排回去，并且不能涉及需要使用的非特殊字符。感兴趣的小伙伴可以参考<a href="https://github.com/HerbertHe/for-editor-herb/blob/master/src/lib/helpers/marked.ts">marked.ts</a>这个部分的源码。对于类似```这种就是对于code块的解析，如果是行内嵌入或者自定义渲染块呢就在<code>paragraph</code>的部分进行重写renderer就好了，但是记得一定要看源码对应的<code>html</code>的标签。</li>
</ul>
<h4>扩展渲染的锚点和大纲</h4>
<p>渲染的锚点就是重写<code>heading</code>部分的HTML，不赘述了就是添加一个a标签就能解决的事情。大纲、目录、TOC，一个东西需要用到<code>marked.js</code>提供的解析器<code>lexer</code>，提取heading部分和深度，然后来写样式部分。</p>
<h4>深坑——如何去调整<code>textarea</code>的高度</h4>
<p>这一切的问题还是来源于，当我使用分栏的功能。我发现记行号并不正确，并且<code>textarea</code>的部分并不能很好的解决高度问题，因为高度不足以显示全部的内容。为什么<code>overflow: hidden</code>其实我在不断优化这个问题的时候也能体会到，因为外部的滚动条需要与行号对齐。</p>
<ul>
<li>修改一：换掉计算行号的方式。源代码的计算方式是通过计算<code>\n</code>来实现的，貌似<code>vscode</code>的markdown也是这么实现的，但是就优化而言<code>textarea</code>对于行号样式能有<code>vscode</code>这样的调整我是没有发现能有什么办法可以做到的。因此我也考虑了很多办法去优化这个问题，甚至重构编辑器。在目前<code>2.x.x</code>的版本中，我已经换成了根据textarea的高度来计算行号了。</li>
<li>修改二：自适应调整textarea的高度。认真地说，这个坑都坑了多少年了，不知道坑过多少人，知乎还有很多的讨论。其实改起来也不算难，就是把<code>height: auto</code>，然后动态调整高度等于<code>scrollHeight</code>。然后我选择了把计算行号在重新计算高度的函数中进行了调用。看起来，<code>everything is ok</code>了是吧？：）惊喜的是当分栏激活的时候<code>scrollHeight</code>并不是会增大，是会减小的，没想到吧。然后我只能选择目前来说我能提供的最优的解决方案，仅当分栏关掉的时候计算高度，然后通过修改值就可以做到精确计算。原作者还提供了fontSize这个可选项，为此我去了解了<code>line-height</code>和<code>font-size</code>之间的关系，具体的源码请参考<code>index.tsx</code>的<code>reHeight</code>部分的源码。其实我还考虑过，根据上一时刻的面积除当前时刻的宽度来计算高度的，听起来是真的很美好。实际情况是，当你切换过快的时候，读取到的面积并不准确，因此这个方法就是<code>理想很丰满，现实很骨感</code>的问题。</li>
<li>为什么不考虑去用可编辑div重写？下次一定，我是准备在<code>3.x.x</code>的版本重构的，但是我目前没有这么多时间去考虑这个问题了，是真的很麻烦。</li>
</ul>
<h2>心得感悟</h2>
<p>小小的富文本编辑器竟然如此复杂，我突然发现我是想慢慢尝试去实现word的最基础的功能。在拓展<code>for-editor</code>的过程中我学到了很多根据教程根本是不可能学到的实际开发问题，为此我付出了很长的事件去研究源码，当然也去开始适应TypeScript来做开发。使用开源项目不是减少工作量，很大程度上其实增加了不少学习成本。</p>
<p>如果喜欢<a href="https://github.com/HerbertHe/for-editor-herb">for-editor-herb</a>我这个分支呢，请给<a href="https://github.com/kkfor/for-editor">原项目</a>一个star。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[对已过去三年来大学生活的总结与建议]]></title>
        <id>https://ibert.me/posts/zh/对已过去三年来大学生活的总结与建议.html</id>
        <link href="https://ibert.me/posts/zh/对已过去三年来大学生活的总结与建议.html"/>
        <updated>2020-03-29T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>大三都已经过了一大半了，从第一个个人博客到第一个个人网站开始，对于自己的总结写博客什么的一直断断续续，但是没有放弃过。总是一个感性的人，很多很多次晚睡总是会夜来非，想想过去再想想当下与未来，我是否真的已经改变了很多？或者很多时候我是否做的不够好？或者我是否曾经伤害过某些人？或者我的思想在如何发展？已经过去的三年大学生活让我认识到了很多的事情，也经历了很多事情，那我该怎么再去做更好呢？我又能给信任我的人或者看到我的博客的后来人带来些什么呢？我真的得好好想想了。</p>
<h2>三年来的经历篇</h2>
<p>志愿是我自己填的，专业也是我自己选的。说是机缘巧合，或者又是命中注定呢？（唯物主义的世界观建立，有点违心了真的是罪过。）如果不是大学被录取，我可能一辈子都不会去山西，也不会思考很多很多事情。就如同如果我中考没有填二中，也没有我高中一连串的思想斗争如此。</p>
<h3>远离家乡的生活</h3>
<p>我其实并不太算恋家，因为自从初中我就住校了，同时其实我并不太愿意在家待着，因为各种家庭内部的原因。远离家乡究竟给我带来了什么？这就让我想到了填大学要不要出省这个问题？</p>
<p>我不认为出省是一件坏事，同样不认为是一件好事。</p>
<p>“不识庐山真面目，只缘身在此山中”是我认为的不是一件好事，不走出舒适圈你永远都不会知道原来人和人的生活习惯和经历的差距会那么大，很多人菜的理所应当就如同很多人强的理所应当一样。其实我在大学之前一直都认为我的高中并不怎么样，在我大学之前所处的环境之中都这么认为，并且觉得省级示范高中的名号不过是徒有虚名。但是，当我进入大学之后才发现，我所接受的教育资源在我大学所接触到的别人的经历之中并不算差，甚至于我所认为理所应当的事情在别人的经历之中是根本不存在甚至不可能的事情。我对于地区发展不平衡和关注地区经济趋势的习惯，就是从这开始形成的。</p>
<p>在外的这几年，我深切的感受到了人才的外溢对于地区的发展有多深远的影响，也深刻的感受到了教育带来的思想差距究竟是有多大，也让我真正从校园开始认识到这个社会，这是我所认为的“出省并不是一件坏事”。我所接触的绝大多数的同一个时代的人，无论是仍然受教育、还是已经工作的，仍然未曾关注过地区或者说政策对于一个人的发展的影响究竟是有多大。</p>
<p>“出省并不是一件好事”，其实出省也是要分多远的。到邻近省份、文化相近甚至相同，我都觉得不能以地理来算是出省的概念。对于我来说，大学所接触到的政治、经济、文化、生活都是和之前完全不同的，我从没那么大的饭量到入乡随俗、从性格软弱到越来越直、从干燥到过敏到想念暖气并不太能适应江南地区的冬天，确确实实已经改变了我的生活习惯甚至是方言。</p>
<p>那么，出省为什么不是一件好事呢？最主要的，你的人际圈会受到很大的影响。对我而言，我是不可能在毕业之后定居在太原的，不管是经济发展也好，还是生活习性也罢，还是家庭原因也罢，几乎是不可能的。这就直接导致了大学所建立起来的人际圈，会因为地理隔阂的原因逐渐失去优势，而重新建立会花费更多的时间。因此我也开始意识到，为什么不管是父母也好，还是部分同学也好，都觉得我的大学志愿是很惋惜的。（但是，我仍然会为了我的选择而负责）</p>
<p>大学这过去的三年来的生活是很圆满的，言外之意也是很不好过的。虽然很多次也曾想过<code>provided</code>，但是我也清醒认识到面对未来才是最应该做的事情。</p>
<h3>放下偏见与发现</h3>
<p>其实到了学校，我的偏见就已经形成了，我一度是认为高三的努力都是喂了狗，我相信很多很多的同学同样是这种想法。（不要在所谓的上帝视角充当圣母或者理性人）直到现在这种想法仍然挥之不去说真的，而恰巧专业又是我极其头疼和不喜欢的，真的是祸不单行，这几年来我真的就觉得生活就是喂了狗。</p>
<p>其实对于高考录取这件事，我算是多多少少放下了，但是带来的冲击是我要花费更多的精力和时间追回来的，我真的很清楚我和高中的同学或者校友的差距在越来越大，有些东西是一个决定就真的改变了很多的事情。所以，大学我除了不喜欢物理之外，努力干过很多事情，成了一些同学眼中所谓的大佬，虽然我从不认为是这样。</p>
<p>大学我一直都在寻找和追随我喜欢的，喜欢做的事情也好，喜欢的人也罢。我也真的认识到很多时候很多事情不过是一厢情愿，老天就喜欢跟我开玩笑，因此我的心理其实发生了很大的根本改变。而上一次这种情况，已经是在四、五年前了，我真的很多时候已然不是个善良的少年了。很多的喜欢不过是虚假，很多时候的放弃其实也算是成全，是我这些年来最大的感悟，同时我也经常容易自闭和抑郁，并且有多次<code>suicide</code>的想法，“生而为人，我很遗憾”。</p>
<p>不能再渲染情绪了，我怕我真的一冲动就深陷其中了，我真的算是很害怕吧，同样很多时候也不愿意再去无事生非，我祝愿我生命中的过客都能过得很好。我最不希望的就是，“我最大的遗憾，就是你的遗憾与我有关”。请原谅我的自私和无关，因为我之前都是因为别人才活着，我已经累了不喜欢被无趣地打扰。</p>
<p>不过终归学了些东西，也不算浪费了我已经度过的生命。我同时谢谢一些同学能看得起我，让我发现自己原来可以做很多事情。</p>
<h2>三年来的感悟与经验篇</h2>
<h3>社团话题</h3>
<p>参加社团是需要的，但是不能以此为中心，爱好终究不能影响生活。参加社团能结识很多的人，就像我形成的圈子大都与我的专业无关一样。在社团中，能学到的东西不比正常学习生活要少，尤其是人际交往和人脉扩张方面，很必要。</p>
<h3>始终高要求</h3>
<p>我就真的觉得高中老师说出大学就轻松这句话用来激励学生就该拉出去枪毙，因为很不利于学生形成正确的对于大学的正确看法。在我准备考研的这段时间，我深刻意识到高中语文老师一直以来说的那句话，“出来混总归是要还的”，真的为自己之前没有形成的习惯和已经放弃的好的习惯而后悔。在知乎上回答了这样的一个问题<code>初一数学考77分还有救吗？</code>我就想到了原来我可是以做数学题为乐的啊！我当年对于难题的追逐有多么的执着！？我还能想起来跟小黑、涛哥、聪哥辩论问题是多好玩，大学我怎么会混成这个diao样？？？</p>
<p>所以从根本来说，如果有建议的话，尤其是理工科。建议把刷题当作快乐，因为做题其实也算是解谜游戏，每天做几题你总会发现自己强的理所当然。除此之外，在备考考研的这段时间，我也发现英语同样是习惯，我在b站同时也看到了很多让我很惊奇的一些事情。觉得英语不重要的，我还是想送这句话“出来混总是要还的”。</p>
<p>在英语这方面，我很感激初中让我现在仍然有能力啃老本。同时呢也有一些由衷的建议，英语在任何时候都没有终点，其实任何一门语言或者学科同样是这样。在有时间的情况下，不要再去计较<code>四六级</code>这个标准了，我真的就觉得大学来纠结这个我都嫌丢人了。在Facebook交流还有认识一些很优秀的同学中，我真的是觉得任何人的差距不仅仅在能力上，而更多的是在思想与认知上。大学伊始，就应该多背单词是我最大的感受，很多次词没必要全会写，你只要认识其实很多就足够了。还有很多人不重视口语，说真的，正确的英语发音对于学好英语的重要性我真的深深体会，因为语言终究是用来交流的工具。</p>
<p>背单词最低要求从四级开始、到六级、到雅思、到GRE，阅读可以读《卫报》、《经济学人》、《华盛顿邮报》什么的等等，别总什么政治不正确有关的，如果明辨是非能力都没有，你还读什么大学我就很好奇了。听力无非是BBC、VOA、TED什么的，其实早在初中高中就已经听过这些了；高三一度听的CGTN，高考英语的听力我真的觉得不能再简单了，包括四级也是如此，六级过不了完全是单词量不够。但是在我做题和得到反馈所知晓的，为什么雅思和考研英语会被认为难？这个问题我真的是觉得因为对于西方国家，或者说是西方文化不够了解，因而影响对于很多事情仍然是中式思维。看似是英语考试，实际上是对于西方社会的根本性了解。</p>
<p>因为，我深有体会的是大学应当始终对于自己是高要求的。冒犯到某些人地说，很多时候你的菜本来就是应该的，就如同失业一般，这句话也同样是对我自己说的。</p>
<h3>关于恋爱观</h3>
<p>首先，我原来是一个极其感性的人，双鱼座往往一直期待浪漫的爱情，并总是深陷其中当舔狗。说真的，我是越来越没有兴趣了，毕竟不要你觉得、我都觉得我不好看还矮。说得不好听，我都放弃了。在投入产出比上，我明显感觉这是不平衡的，并且是低效、高风险、低回报的。一定会有人说我是直男，非得以理性来思考感性的问题。其实不然，我现在多理性，我原来就有多感性，最终我又得到了什么呢？好人卡收集成就达成能召唤神兽？这也是个现象，为什么越来越多男生不会去追女生了？为什么游戏会更有诱惑力？为什么渣男频出，男生第一感觉竟然是我为什么不是渣男？为什么一提到恋爱这种话题，引得无数汉子哽咽？为什么“我很羡慕渣男可以拥有很多女生的青春，而我努力到最后也只能得到他们所伤害的”这句话能引起那么多共鸣？所以说，现实的生活是并不是谁离开谁就活不了，而是究竟能给你带来什么？难道不应该是三观的契合？只为了发泄去造ren？另外，人和狗的地位是不一样的，很多时候不过是一厢情愿，跟谁都没关系。而我更明白，男生到24岁之后没钱什么都不是。只要你没有结婚，所谓的“戴绿帽子”不过是别人在追逐更好的你给不了，所以在这件事上，我始终觉得无可厚非。随随便便换来换去我同样是看不起的，在恋爱观上我始终坚守要有责任心，因此我总是好人。</p>
<h2>后记</h2>
<p>其实我能想到的目前大抵也就是这么多，我本也可以过的更舒服。经济在发展，社会在发展，我知道我现在有多努力，多去追求更高，我的后辈就会相对起点更高，同样也会更轻松。一代的缺失，差距就只会越来越大，而生物界却总是遵守“物竞天择，适者生存”。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速用electron生成一个PC端应用]]></title>
        <id>https://ibert.me/posts/zh/快速用electron生成一个PC端应用.html</id>
        <link href="https://ibert.me/posts/zh/快速用electron生成一个PC端应用.html"/>
        <updated>2020-03-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>在使用Electron开发应用的过程中遇到了很多小的bug，这些bug有的解决方案尚且有用，有的bug已经过时了。网上的帖子有很多，质量层次不齐，如何去引入解决问题云云，很多的bug是框架自身的问题甚至还活在issues里。为了便于开发electron应用，我整理了三个模板仓库便于直接应用于开发，因为本地没有OSX的环境，所以都是在Win10完成的开发，这也是解决起来最麻烦的。</p>
<p>仓库地址: <a href="https://gitee.com/HerbertHe">Gitee</a>, <a href="https://github.com/HerbertHe">GitHub</a></p>
<h2>为什么是React</h2>
<p>针对于Vue的帖子有很多，也很多人使用，我也曾用过。因为自己学过和用过很多开发语言，而React更适用于我的编程逻辑和习惯，Vue面向设计师我感觉是很合适的(～﹃～)~zZ。</p>
<h2>关于<code>Eraac</code>、<code>Eraasc</code>和<code>Eraatc</code></h2>
<p><code>Eraac</code>全名为<code>electron-react-antd-antv-cli</code>，另外的两个<code>s</code>和<code>t</code>分别代表<code>sqlite3</code>的版本和<code>typescript</code>的版本。<code>Eraac</code>和<code>Eraasc</code>的类型检查都是用的<code>prop-types</code>，根据react官方的建议和发展趋势<code>ts</code>版本会越来越流行，<code>js</code>版本降低了开发难度和考虑因素同时存在类型安全的问题，<code>ts</code>版本更适合大型应用的开发。</p>
<blockquote>
<p><code>sqlite3</code>的版本本质就是<code>Eraac</code>引入了<code>sqlites3</code>，但是由于<code>sqlite3</code>并不能直接使用。构建同样是一个大坑，因此整理为了一个独立的仓库。<strong>同时需要说明的是：框架限制了electron的版本更新，因为electron版本更新也存在不兼容的问题，如果有需要请自行更新！模板的master分支会尽快跟着electron进行更新的兼容性测试，新项目无需担心。</strong></p>
</blockquote>
<h3>为什么引入了antd和antv</h3>
<p>antd是阿里蚂蚁提供的可视化开源组件，跟饿了么提供的<code>element-ui</code>面向vue一样都是组件。antv是蚂蚁提供的数据可视化组件，在一个应用开发中往往数据可视化也能带来更好的用户体验。antv使用的是<code>BizCharts</code>，为阿里面向react的商业级数据可视化组件，能够保证足够的开发质量。</p>
<h2>如何快速生成一个electron应用</h2>
<p>第一次使用我建议使用<code>Eraac</code>模板，因为足够便捷。根据<code>README.md</code>的使用指南，很快就会启动成功一个electron应用，根据自己的需要可以清掉所有的demo和test文件直接构建。</p>
<h3>基本使用</h3>
<p>主进程位于: <code>/public/electron.js</code></p>
<p>渲染进程可以位于任何组件中，只需要使用<code>window.electron</code>即可使用<code>electron</code>提供的所有API。</p>
<h3>进阶使用</h3>
<p>参考<code>REAME.md</code>引用的文档，配置好<code>package.json</code>和<code>.yml</code>文件，遵循使用说明，即可实现直接构建带有自动升级的PC端应用！</p>
<h2>使用demo: <code>EdeverClient</code></h2>
<p><code>EdeverClient</code>仓库位于<a href="https://github.com/HerbertHe/EdeverClient">GitHub</a>和<a href="https://gitee.com/HerbertHe/EdeverClient">Gitee</a>，它是基于<code>Eraac</code>和<code>Gitee OpenAPI</code>的便于了解系列所有框架实时动态的PC端。目前只提供了win x64的版本，因为没有Mac，如果能参与构建就很感谢了！</p>
<p>下面是使用界面:</p>
<img src="https://ibert.me/img/Snipaste_2020-03-17_18-50-54.png"/>
<p>自带了自动更新，无需再考虑版本更新问题，请在 <a href="https://github.com/HerbertHe/EdeverClient">GitHub</a> 的release中获取（因为Gitee限制了附件大小，实在没有办法）</p>
<p>这同时是一个demo基于<code>React Hooks</code>开发，仓库里的代码开源，哪里不会看哪里比文档更直观。</p>
<h2>写在后面的</h2>
<p>作者大三，同时也是考研狗，不是科班出身，更新框架可能有时候会慢一点，欢迎使用，欢迎pr，issues，如果能给个star那就是最好的鼓励了！有任何问题都可以issues。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置Goland主题与工程环境]]></title>
        <id>https://ibert.me/posts/zh/配置Goland主题与工程环境.html</id>
        <link href="https://ibert.me/posts/zh/配置Goland主题与工程环境.html"/>
        <updated>2020-03-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>关于Goland与vscode的比较</h2>
<p>Goland为JetBrains出品的针对于Go编程的IDE，与IDEA、Webstorm、Pycharm等耳熟能详的IDE的风格基本相似。针对于不同的语言，略有差异。vscode通过安装插件也可以搭建优雅的Go开发环境，但是在参考了很多网上的帖子和走过很多坑之后还是放弃了，继续使用了Goland。</p>
<h3>Goland的优越性</h3>
<ul>
<li>代码智能提示</li>
<li>完备的项目开发流程</li>
</ul>
<h3>Goland的缺点</h3>
<ul>
<li>纯英文的开发环境，很容易导致功能了解不完全和误操作</li>
<li>自不知道哪一版的更新之后，Goland的中文显示就崩掉了，需要自己配置</li>
<li>从非Goland创建的工程移植，本地库的导入需要手动操作</li>
<li>需要自行做一些IDE关于proxy的配置</li>
</ul>
<h2>配置Goland主题和字体</h2>
<p>在这里我使用的是<code>Material Theme UI</code>这个插件，<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Plugins</code>-&gt;<code>Marketplace</code>搜索就好了，选择一个自己喜欢的主题。</p>
<img src="https://ibert.me/img/Snipaste_2020-03-09_14-28-07.png" />
<p>字体的配置在<code>File</code>-&gt;<code>Settings</code>-&gt;<code>Editor</code>的<code>Font</code>、<code>Color Scheme</code>的<code>Color Scheme Font</code>和<code>Console Font</code>下</p>
<img src="/img/Snipaste_2020-03-09_14-42-25.png" />
<p>字体推荐使用的是<code>Fira Code</code>看起来很舒服，但是在显示的时候如果习惯普通的符号的话，对于<code>===</code>、<code>!=</code>、<code>!==</code>等这些符号看起来可能会比较陌生。字体链接: <a href="https://github.com/tonsky/FiraCode">GitHub</a></p>
<blockquote>
<p>一定要配置<code>Fallback font</code>这一项不然汉字可能出现渲染问题！</p>
</blockquote>
<h2>关于IDE配置和项目配置</h2>
<p>默认情况下，只要你根据golang的配置要求配置了<code>GOROOT</code>和<code>GOPATH</code>，IDE都会默认找到对应的本地库，可以通过下图的位置来检查。</p>
<img src="/img/Snipaste_2020-03-09_14-54-57.png" />
<img src="/img/Snipaste_2020-03-09_14-55-42.png" />
<img src="/img/Snipaste_2020-03-09_14-57-00.png" />
<h2>从别的IDE迁到Goland</h2>
<p>根据go语言的特性，默认go的源代码必须位于<code>GOPATH</code>的<code>src</code>下，go在更新后提供了<code>go module</code>的包管理工具，强烈建议在新的项目中使用<code>go mod init xxx.xxx</code>的方式使用<code>go module</code>来初始化项目的包管理，以此来抽离项目于默认的文件夹。从别的IDE迁移至<code>Goland</code>请仔细检查上图中的配置，否则可能会导致本地包智能提示无法识别的问题。</p>
<p>在上图<code>Go Modules</code>的proxy配置中，强烈建议改为上图配置以解决国内网络环境对于包下载的不友好，配置 <code>https://goproxy.cn,direct</code></p>
<p>同样建议使用<code>go env</code>检查<code>GOPROXY</code>，<code>go env set GOPROXY=https://goproxy.cn,direct</code></p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows下Vim的安装与插件管理]]></title>
        <id>https://ibert.me/posts/zh/Windows下Vim的安装与插件管理.html</id>
        <link href="https://ibert.me/posts/zh/Windows下Vim的安装与插件管理.html"/>
        <updated>2020-02-04T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>关于Vim</h2>
<p>Vim是一款优秀的编辑器，可以在环境艰苦的纯shell端进行代码及配置文件的编辑。相比于带有GUI的vscode、notepad++等编辑器，Vim的学习成本比较高，但是却被称为“上古神器”。在Linux端<code>vi</code>、<code>vim</code>经常是修改配置文件教程的首选，Linux发行版也大都自带Vim；现在很多的Linux发行版开始自带<code>nano</code>编辑器，相比于Vim足够简单，但是所提供的功能甚少可以做简单编辑操作，对于完全无需鼠标的编辑操作Vim仍然是不二之选！</p>
<p>大多的Vim使用场景在Linux端，很多的教程和配置文件并不适用Windows的环境，这一路走来遇到了不少的坑。因为在学《汇编语言》下纯的shell环境相较于GUI的编辑器更能提高编辑效率，本篇心得将从Windows的环境下说明和配置Vim结构与配置文件</p>
<h2>下载与安装Vim</h2>
<p>在GitHub仓库下的<a href="https://github.com/vim/vim-win32-installer/releases">releases</a>下选择对应的<code>.exe</code>可执行文件，<code>x86</code>32位，<code>x64</code>64位。</p>
<blockquote>
<p>在Windows的环境下默认vim默认为带GUI的<code>gvim</code></p>
</blockquote>
<p>根据安装教程来，均无需修改配置，没有默认将Vim装到C盘，请尽量把软件隔离系统盘安装！这里的安装路径是<code>D:\Vim</code></p>
<p>安装完成之后，在<code>D:\Vim</code>的目录下有<code>vim82</code>和<code>_vimrc</code>两个子项，对应于linux的<code>.vim</code>和<code>.vimrc</code></p>
<h2>测试安装</h2>
<pre><code class="language-shell"># 打开powershell
vim --version
</code></pre>
<h2>基本配置<code>_vimrc</code></h2>
<p>这里贴上我的基本配置文件</p>
<pre><code class="language-_vimrc">&quot; Vim with all enhancements
source $VIMRUNTIME/vimrc_example.vim

&quot; Use the internal diff if available.
&quot; Otherwise use the special 'diffexpr' for Windows.
if &amp;diffopt !~# 'internal'
  set diffexpr=MyDiff()
endif
function MyDiff()
  let opt = '-a --binary '
  if &amp;diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &amp;diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '&quot;' . arg1 . '&quot;' | endif
  let arg1 = substitute(arg1, '!', '\!', 'g')
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '&quot;' . arg2 . '&quot;' | endif
  let arg2 = substitute(arg2, '!', '\!', 'g')
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '&quot;' . arg3 . '&quot;' | endif
  let arg3 = substitute(arg3, '!', '\!', 'g')
  if $VIMRUNTIME =~ ' '
    if &amp;sh =~ '\&lt;cmd'
      if empty(&amp;shellxquote)
        let l:shxq_sav = ''
        set shellxquote&amp;
      endif
      let cmd = '&quot;' . $VIMRUNTIME . '\diff&quot;'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '&quot; ', '') . '\diff&quot;'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  let cmd = substitute(cmd, '!', '\!', 'g')
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' &gt; ' . arg3
  if exists('l:shxq_sav')
    let &amp;shellxquote=l:shxq_sav
  endif
endfunction

&quot;设置文件的代码形式 utf8
set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,chinese,cp936

&quot; 设置中文帮助 &quot;
set helplang=cn

&quot; 保留历史记录 &quot;
set history=500

&quot; 设置字体 &quot;
set guifont=Consolas:h14

&quot; 设置行号 &quot;
set number

&quot; 设置Tab四个空格 &quot;
set tabstop=4
set softtabstop=4
set wrap &quot; 设置自动换行
set linebreak &quot; 设置整词换行
set scrolloff=5 &quot; 设置自动上滚或者下滚
set autoread &quot; 设置外部修改更新

&quot; 查找/替换
set hlsearch &quot; 高亮显示
set incsearch &quot; 增量查找

&quot; 状态栏显示
set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]  &quot; 显示文件名：总行数，总的字符数
set ruler &quot; 在编辑过程中，在右下角显示光标位置的状态行

&quot; 代码设置
syntax enable &quot; 打开语法高亮
syntax on &quot; 打开语法高亮
set showmatch &quot; 设置匹配模式，相当于括号匹配
set smartindent &quot; 智能对齐
set autoindent &quot; 设置自动对齐
set ai! &quot; 设置自动缩进
set fdm=indent
</code></pre>
<p>关于<code>vimrc</code>文件的配置可以直接百度或者GitHub搜索<code>vimrc配置</code>的相关词条，<code>vimrc</code>的配置确实让很多人看到就会想放弃Vim (￣▽￣)&quot;</p>
<h2>设置Vundle插件管理</h2>
<p>Vundle是一个很棒的Vim插件管理工具，同样它也是Vim的插件。根据搜到的配置教程和官方仓库的关于Windows的配置教程，尽量简化了Vundle的安装，但是同样带来了默认C盘的尴尬事情发生，你如果按照官方配置文件来一定会在C盘的<code>User(用户)</code>目录下多出一个<code>.vim</code>的文件夹！！</p>
<blockquote>
<p>官方配置流程: <a href="https://github.com/VundleVim/Vundle.vim/wiki/Vundle-for-Windows">Vundle-for-Windows</a></p>
</blockquote>
<p>下面是详细的配置过程</p>
<h3>下载安装 <a href="https://git-scm.com/download/win">Git on Windows</a></h3>
<p>在<code>Adjusting your PATH environment</code>这一步，一定要勾选<code>Use Git from the Windows Command Prompt</code>这一项配置<code>PATH</code>！</p>
<h3>下载安装 <a href="https://curl.haxx.se/windows/">Curl on Windows</a></h3>
<ol>
<li>下载完成之后解压缩文件获取里面的内容，我解压缩到了<code>D:\curl</code>这个文件夹下！</li>
<li><code>bin</code>文件夹添加到系统的环境变量<code>Path</code>，我的配置是<code>D:\curl\bin</code>   <strong>这一步不做无法在命令行使用curl命令</strong></li>
</ol>
<h3>测试安装git和curl</h3>
<pre><code class="language-shell">git --version

curl --version
</code></pre>
<h3>Vundle on Windows</h3>
<blockquote>
<p>与官方文档不同！很重要！</p>
</blockquote>
<p>打开到<code>vim</code>的安装目录<code>D:\Vim</code>，在此目录下打开<code>PowerShell</code></p>
<pre><code class="language-shell">git clone https://github.com/VundleVim/Vundle.vim.git /vim82/bundle/Vundle.vim

# 你同样也可以使用我在Gitee备份的仓库，提高下载速度
git clone https://gitee.com/HerbertHe/Vundle.vim.git /vim82/bundle/Vundle.vim
</code></pre>
<blockquote>
<p>说明：命令里的<code>vim82</code>对应的就是<code>.vim</code>这个目录！因为Vim版本的不同可能会导致目录的名称不同，请参考修改！</p>
</blockquote>
<p>配置插件，打开修改<code>_vimrc</code>文件</p>
<pre><code class="language-_vimrc">set nocompatible              &quot; 去除VI一致性,必须
filetype off                  &quot; 必须

&quot; 设置包括vundle和初始化相关的runtime path，重要！！
set rtp+=D:/Vim/vim82/bundle/Vundle.vim

&quot; 指定一个vundle安装插件的路径，重要！！
&quot;call vundle#begin('D:/Vim/vim82/bundle')

&quot; 让vundle管理插件版本,必须
Plugin 'VundleVim/Vundle.vim'

&quot; 以下范例用来支持不同格式的插件安装.
&quot; 请将安装插件的命令放在vundle#begin和vundle#end之间.
&quot; Github上的插件
&quot; 格式为 Plugin '用户名/插件仓库名'
&quot; Plugin 'tpope/vim-fugitive'
&quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件
&quot; Plugin '插件名称' 实际上是 Plugin 'vim-scripts/插件仓库名' 只是此处的用户名可以省略
&quot; Plugin 'L9'
&quot; 由Git支持但不再github上的插件仓库 Plugin 'git clone 后面的地址'
&quot; Plugin 'git://git.wincent.com/command-t.git'
&quot; 本地的Git仓库(例如自己的插件) Plugin 'file:///+本地插件仓库绝对路径'
&quot; Plugin 'file:///home/gmarik/path/to/plugin'
&quot; 插件在仓库的子目录中.
&quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下
&quot; Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
&quot; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突
&quot; Plugin 'ascenator/L9', {'name': 'newL9'}

call vundle#end()            &quot; 插件管理结束标志，必须
filetype plugin indent on    &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本
&quot; 忽视插件改变缩进,可以使用以下替代:
&quot;filetype plugin on
&quot;
&quot; 简要帮助文档
&quot; :PluginList       - 列出所有已配置的插件
&quot; :PluginInstall    - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate
&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存
&quot; :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件
&quot;
&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ
&quot; 将你自己对非插件片段放在这行之后
</code></pre>
<p>在配置内容中，我额外配置的是</p>
<pre><code class="language-_vimrc">&quot; 设置Vundle插件管理
set nocompatible
filetype off

&quot; 设置Vundle路径和初始化
set rtp+=D:/Vim/vim82/bundle/Vundle.vim

&quot; 指定插件安装
call vundle#begin('D:/Vim/vim82/bundle')
Plugin 'VundleVim/Vundle.vim'
Plugin 'scrooloose/nerdtree'
Plugin 'altercation/vim-colors-solarized'

call vundle#end()   &quot; 结束

&quot; 加载vim自带和插件对应语法和文件类型相关脚本
filetype plugin indent on

&quot; 目录树插件配置
let NERDTreeHighlightCursorline = 1       &quot; 高亮当前行
let NERDTreeShowLineNumbers     = 1       &quot; 显示行号
map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;    &quot; Ctrl+n打开插件
let g:NERDTreeDirArrowExpandable = '▸'
let g:NERDTreeDirArrowCollapsible = '▾'

&quot; 主题配置
let g:solarized_termtrans  = 1        &quot; 使用 termnal 背景
let g:solarized_visibility = &quot;high&quot;   &quot; 使用 :set list 显示特殊字符时的高亮级别
&quot; GUI 模式浅色背景，终端模式深色背景
if has('gui_running')
    set background=light
else
    set background=dark
endif

&quot; 主题设置为 solarized
colorscheme solarized

</code></pre>
<h2>命令行启动Vim并且安装插件</h2>
<ul>
<li>打开PowerShell</li>
<li>键入<code>vim</code>命令行下打开编辑器</li>
<li>在视图模式下键入<code>:PluginInstall</code>回车</li>
</ul>
<p>安装完成后即可使用插件，上面的配置中我使用了<code>Plugin 'scrooloose/nerdtree'</code>和<code>Plugin 'altercation/vim-colors-solarized'</code></p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次JS线程问题]]></title>
        <id>https://ibert.me/posts/zh/记一次JS线程问题.html</id>
        <link href="https://ibert.me/posts/zh/记一次JS线程问题.html"/>
        <updated>2020-01-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>遇到的错误</h2>
<p><img src="https://ibert.me/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200130165732.png" alt="错误图片"></p>
<p>正如你所见的，报了一个<code>value below was evaluated just now</code>的信息，意味着我拿到的是原来的数据而不是最新的，下面伴随一些demo来看看这个问题。</p>
<h2>问题的引出</h2>
<p>问题最早来源于我想拿到<code>Promise</code>里面返回的数据，所使用的是<code>React</code>并使用<code>Axios</code>来访问请求，<code>Axios</code>为http的异步请求。这里使用的是<code>GitHub</code>和<code>Gitee</code>的接口，请求得到当前的指定用户的关注、关注者、Star的仓库和自己仓库的数据量。具体的示例可以参考PC版的 <a href="https://server.jieec.cn">Jieec Server</a>（目前没有在移动端上适配个人信息相关的，用media隐藏掉了）<strong>目前这个问题并未完全解决</strong></p>
<blockquote>
<p>全站代码都已经开源，可以在<a href="https://github.com/HerbertHe/JieecServerPage">HerbertHe/JieecServerPage</a>获取</p>
</blockquote>
<p>因为每次API请求的数据获取有限制，然后就使用了<code>分页</code>的操作，并且使用了循环的操作。</p>
<h2>第一个问题：如何降低<code>React</code>中异步更新状态的次数</h2>
<p>最开始，我是直接在<code>Axios</code>的<code>.then</code>直接使用了<code>this.setState()</code>的方法，这样直接在获取数据之后直接渲染DOM，这样会导致页面的重复更新。<strong>更重要</strong>的问题是<code>this.setState()</code>这个方法也是<strong>异步</strong>的！</p>
<blockquote>
<p>demo如下：</p>
</blockquote>
<pre><code class="language-js">import Axios from 'axios'

// .....省略组件定义.....

constructor(props){
    super(props)
    this.state = {
        result: 0
    }
}

for (let i = 1; i &lt; 4; i++) {
    Axios.get(`https://api.github.com/users/HerbertHe/followers?page=${i}`).then(res =&gt; {
            if (res.data.length !== 0) {
                this.setState({
                    result: this.state.result + res.data.length
                })
            }
        }
    )
}
</code></pre>
<p>因为<code>this.setState()</code>的操作是异步的，那么问题来了，我根本拿不到最新的<code>this.state.result</code>的值。就意味着<code>setState()</code>设置的值根本不能确定是不是少算了，并且受执行的时刻影响，就真的是&quot;薛定谔的猫了&quot;</p>
<h2>第二个问题：如何抽离请求的代码</h2>
<p>参考这个commit<a href="https://github.com/HerbertHe/JieecServerPage/commit/d28a5ebf3d47cd4e090208773f3bade28a499945#r37037127">d28a5ebf3d47cd4e090208773f3bade28a499945</a>，太多的<code>Axios</code>请求导致代码越来越冗余，由于项目是小项目并没有使用<code>Redux</code>进行状态管理，而是单独抽取了一个文件<a href="https://github.com/HerbertHe/JieecServerPage/blob/master/src/Components/githubAndGiteeData.js">githubAndGiteeData.js</a>，数据使用了<code>_data</code>这样一个全局变量做<br>
统一管理，然后<code>export default GetReq()</code>这个函数供外部使用。参考<a href="https://github.com/HerbertHe/JieecServerPage/commit/01805298a39a90a3feae5d7770d6d3ab8c25d78e#r37037265">commit</a></p>
<h2>第三个问题：获取Promise的返回值</h2>
<p><code>Axios</code>是一个Promise，取值需要在<code>.then</code>之中，因为作用域的问题，对于更新值使用了<code>setter</code>这样的方法，在<code>Axios</code>返回之后做一个记录，从而异步操作数据和重复的DOM渲染问题。参考<a href="https://github.com/HerbertHe/JieecServerPage/blob/master/src/Components/githubAndGiteeData.js">githubAndGiteeData.js</a>。</p>
<h2>第四个问题：上面引言的错误如何解决</h2>
<p>最开始的代码是直接调用<code>GetReq</code>的方法并且<code>console.log()</code>打印了值，也就出现了上面图的报错，我打印的并不是最新的值。后来我才意识到虽然<code>js</code>是单线程的，但是它有协程的存在，函数的执行时机是很有影响的。</p>
<blockquote>
<p>可以参考这篇文章<a href="https://www.jianshu.com/p/8821c6432fe1">彻底明白 JS 线程</a></p>
</blockquote>
<p>然后参考CSDN做了一个简单而粗暴的解决办法，可以参考commit<a href="https://github.com/HerbertHe/JieecServerPage/commit/01805298a39a90a3feae5d7770d6d3ab8c25d78e#r37037489">01805298a39a90a3feae5d7770d6d3ab8c25d78e</a>，通过设置<code>setTimeout()</code>的方式强行延时处理设置状态渲染DOM</p>
<h2>更多的问题和预想解决方案</h2>
<p>上面设置定时器处理很依赖API的响应时间，如果API响应很慢的话，会导致渲染数据不准确的情况（已经发现，主要是GitHub API真的不好确认时间）；如果设的时间过长，用户体验会大打折扣。</p>
<blockquote>
<p>目前预想的解决方案是利用<code>React</code>提供的下一个生命周期函数来获取数据，具体需要更多的尝试。</p>
</blockquote>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu环境安装docker记录]]></title>
        <id>https://ibert.me/posts/zh/Ubuntu环境安装docker记录.html</id>
        <link href="https://ibert.me/posts/zh/Ubuntu环境安装docker记录.html"/>
        <updated>2020-01-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>本地环境</h2>
<ul>
<li>Ubuntu系统版本: Ubuntu19.10</li>
<li>软件源: 清华大学Tuna</li>
<li>虚拟机环境: VMware 15</li>
</ul>
<h2>新装Ubuntu基本配置</h2>
<pre><code class="language-shell"># 配置软件源
sudo nano /etc/apt/sources.list
</code></pre>
<pre><code class="language-sources.list"># 首先注释掉所有的默认软件源
# 添加清华源 (演示系统为Ubuntu19.10, 软件代号为eoan! )

# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-proposed main restricted universe multiverse
</code></pre>
<blockquote>
<p>Ubuntu各版本代号简介请参考: <a href="https://blog.csdn.net/zhengmx100/article/details/78352773">传送门</a>, 不同版本对应的软件清华源: <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">传送门</a></p>
</blockquote>
<pre><code class="language-shell">sudo apt update
sudo apt upgrade
</code></pre>
<h2>安装docker社区版</h2>
<p>安装docker可以参考docker官网的<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Get Docker Engine - Community for Ubuntu</a>, 也可以使用清华源镜像, 下面是参考<em>docker官网</em>和<em>清华源</em>对于安装过程的总结</p>
<p>docker支持的Ubuntu版本为:</p>
<ul>
<li>Disco 19.04</li>
<li>Cosmic 18.10</li>
<li>Bionic 18.04 (LTS)</li>
<li>Xenial 16.04 (LTS)</li>
</ul>
<blockquote>
<p>社区版支持的架构为: <code>x86_64(amd64)</code>, <code>armhf</code>, <code>arm64</code>, <code>s390x</code>, <code>ppc64le</code>!**Eoan 19.10软件源并不受支持!因此官网和清华源的命令在Ubuntu19.10下并不会成功!**报错请参考: <a href="https://www.jb51.net/article/173316.htm">分享Ubuntu19无法安装docker源问题</a></p>
</blockquote>
<h3>卸载旧版本的docker</h3>
<pre><code class="language-shell">sudo apt-get remove docker docker-engine docker.io containerd runc
</code></pre>
<blockquote>
<p>docker社区版新版本名称为: docker-ce</p>
</blockquote>
<h3>更新软件源</h3>
<pre><code class="language-shell">sudo apt update
</code></pre>
<h3>下载依赖</h3>
<pre><code class="language-shell">sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
</code></pre>
<h3>添加docker官方的GPG key</h3>
<pre><code class="language-shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
</code></pre>
<h3>验证指纹信息</h3>
<pre><code class="language-shell">sudo apt-key fingerprint 0EBFCD88

# 输出
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096 2017-02-22 [S]
</code></pre>
<h3>设置软件源</h3>
<blockquote>
<p>这一步很关键！</p>
</blockquote>
<ul>
<li>官网命令</li>
</ul>
<pre><code class="language-shell">sudo add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
</code></pre>
<ul>
<li>清华源命令</li>
</ul>
<pre><code class="language-shell">sudo add-apt-repository \
   &quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
</code></pre>
<blockquote>
<p>上面的命令会在<code>/etc/apt/sources.list</code>文件中添加下面的内容(以清华源为例), 执行之后会报上面提到的错误</p>
</blockquote>
<pre><code class="language-sources.list">deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu eoan stable
# deb-src [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu eoan stable
</code></pre>
<blockquote>
<p>正确的做法是手动更改添加<code>Disco 19.04</code>的docker软件源！</p>
</blockquote>
<pre><code class="language-shell">sudo nano /etc/apt/sources.list
</code></pre>
<pre><code class="language-sources.list">deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu disco stable
# deb-src [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu disco stable
</code></pre>
<p>保存之后执行更新和下载</p>
<pre><code class="language-shell">sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io
</code></pre>
<blockquote>
<p>指定版本下载，列出软件源所有可下载的版本可以参考官网的<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-engine---community-1">To install a specific version of Docker Engine - Community</a>, 用包下载安装可以参考<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-from-a-package">Install from a package</a></p>
</blockquote>
<h3>验证docker安装</h3>
<p>通过跑测试镜像<code>hello-world</code>验证</p>
<pre><code class="language-shell">sudo docker run hello-world
</code></pre>
<blockquote>
<p>可能会因为网络的原因报错, 参考这篇帖子: <a href="https://blog.csdn.net/anjie5595/article/details/101501786">docker pull error pulling image configuration</a></p>
</blockquote>
<p>报错解决</p>
<pre><code class="language-shell"># 停止docker服务
systemctl stop docker
# 修改daemon配置文件添加加速源
sudo nano /etc/docker/daemon.json
</code></pre>
<pre><code class="language-daemon.json">{
　　&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]
}
</code></pre>
<pre><code class="language-shell"># 重载配置
systemctl daemon-reload
# 重启docker服务
systemctl restart docker
</code></pre>
<blockquote>
<p>测试成功信息</p>
</blockquote>
<pre><code class="language-shell">Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 \$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

</code></pre>
<h3>docker更新</h3>
<p>直接使用<code>sudo apt upgrade</code>即可</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nodejs安装若干问题避坑]]></title>
        <id>https://ibert.me/posts/zh/Nodejs安装若干问题避坑.html</id>
        <link href="https://ibert.me/posts/zh/Nodejs安装若干问题避坑.html"/>
        <updated>2020-01-26T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>nodejs的windows下传统安装</h2>
<p><a href="https://nodejs.org/en/">nodejs官网</a>下载：LTS为长期支持版，Current是最新版</p>
<blockquote>
<p>根据官网给的安装包一步步来即可安装</p>
</blockquote>
<h2>nodejs的不同版本安装思考</h2>
<p>由于平时可能涉及到的node版本不同导致所用的代码会出现各种各样的问题，node的版本管理工具切换node版本显得比较重要！在<code>Linux/Mac</code>端<code>nvm</code>很好的解决了版本管理的问题，在Windows端不可使用<code>nvm</code>进行管理！</p>
<p>Github项目<a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a>利用go语言开发解决了Windows环境下的nodejs管理问题！</p>
<blockquote>
<p>下面对 <code>nodejs</code> 和 <code>node</code>, <code>nvm</code> 和 <code>nvm-windows</code> 不加以区分</p>
</blockquote>
<!-- more -->
<h2>配置安装nvm-windows</h2>
<ol>
<li>
<p>首先建议<code>卸载</code>本地环境下的nodejs，以便更好地管理node版本</p>
</li>
<li>
<p><a href="https://github.com/coreybutler/nvm-windows/releases">releases</a>中下载最新的安装包</p>
<blockquote>
<p>建议使用: <code>nvm-setup.zip</code> 傻瓜式安装, <code>nvm-noinstall.zip</code> 为绿色版需要自行配置</p>
</blockquote>
</li>
<li>
<p>安装配置<code>nvm-windows</code></p>
<ul>
<li><code>nvm</code> 安装路径可以自定义</li>
<li>symlink为超链接的目标目录，即用<code>nvm use</code>切换node版本时，本质上是切换链接的指向！symlink配置之后安装工具会把链接的地址加入系统环境变量之中，下面将会详述<code>nvm</code>的命令和具体使用！这个目录就当成node的安装目录就好了。</li>
</ul>
</li>
</ol>
<h2>nvm命令详解</h2>
<ul>
<li>
<p><code>nvm version</code>: 查询当前的nvm版本</p>
</li>
<li>
<p><code>nvm</code>: 列出所有的命令</p>
<pre><code class="language-shell">Running version 1.1.7.

Usage:

nvm arch                     : 显示node运行在32位还是在64位系统上
nvm install &lt;version&gt; [arch] : 利用nvm下载node, 可以指定版本下载或者&quot;latest&quot;下载最新稳定版, 可选指定下载32/64位的版本, 默认与系统架构相同。
                                arch参数为&quot;all&quot;则32/64位版本都下载, 命令后面添加--insecure可以跳过SSL检查下载
nvm list [available]         : 列出所有的node下载, &quot;nvm list available&quot; 命令可以查看所有可下载的node版本, 别名ls
nvm on                       : 允许进行node版本管理
nvm off                      : 不允许进行node版本管理
nvm proxy [url]              : 为下载配置代理, url参数为空打印当前代理, 参数为&quot;none&quot;删除代理
nvm node_mirror [url]        : 设置node镜像, 默认是 https://nodejs.org/dist/ （国内可用: https://npm.taobao.org/mirrors/node/）
nvm npm_mirror [url]         : 设置npm镜像, 默认是 https://github.com/npm/cli/archive/ （国内可用淘宝镜像: https://npm.taobao.org/mirrors/npm/）
nvm uninstall &lt;version&gt;      : 卸载指定版本node
nvm use [version] [arch]     : 切换指定使用的node版本, 可选指定32或64位架构, &quot;arch&quot;参数可选
nvm root [path]              : 设置nvm管理的不同版本node的储存位置, 如果路径没有设置就打印当前nvm安装的目录（ps: 这个其实可以不用设置的）
nvm version                  : 显示当前Windows环境下nvm的版本, 别名 v
</code></pre>
</li>
</ul>
<h2>Win10一般配置nvm</h2>
<pre><code class="language-shell"># 设置64位架构
nvm arch 64

# 设置node镜像
nvm node_mirror https://npm.taobao.org/mirrors/node/

# 设置npm镜像
nvm npm_mirror https://npm.taobao.org/mirrors/npm/

# 列出所有可以下载的node
nvm list available

# 以12.14.1版本为例下载node
nvm install 12.14.1

# 显示所有已下载的node
nvm list

# 切换使用12.14.1
nvm use 12.14.1
</code></pre>
<h2>需要注意的问题</h2>
<ol>
<li>
<p><code>nvm</code>管理node时，利用npm/yarn全局下载的包只能是下载到当前使用版本的node的node_modules\node_global\node_modules下，如果切换node版本，依赖包是要重新下载的！</p>
</li>
<li>
<p>由于yarn和npm全局下载的包在node_modules中的结构是不同的，yarn全局下载的包使用PowerShell跑的时候找不到命令，所以强烈建议全局下载例如Taro、Vue、React等的脚手架工具时使用npm做node的依赖包管理，而非yarn</p>
</li>
<li>
<p>因为yarn可以多线程下载，下载包的速度比npm要快还能多，所以建议在项目中使用yarn进行包管理</p>
</li>
<li>
<p>安装过程中出现的异常通常可以通过重启或者使用<code>管理员身份打开</code>解决</p>
</li>
</ol>
<h2>npm/yarn包镜像源的管理</h2>
<blockquote>
<p>强烈建议使用<code>yrm</code>进行镜像源管理</p>
</blockquote>
<pre><code class="language-shell"># 下载yrm
npm install yrm -g

# 列出所有可以使用的镜像源
yrm ls

# 示例使用taobao镜像源
yrm use taobao
</code></pre>
<h2>yrm命令详解</h2>
<blockquote>
<p>命令行使用<code>yrm</code>即可显示所有的yrm命令</p>
</blockquote>
<pre><code class="language-shell">Usage: cli [options] [command]

Options:
  -V, --version                输出版本
  -h, --help                   输出使用信息

Commands:
  ls                           列出所有的仓库
  current                      展示当前的仓库名
  use &lt;仓库名&gt;                 使用指定的仓库
  add &lt;仓库名&gt; &lt;url&gt; [home]    添加一个自定义仓库
  del &lt;仓库名&gt;                 删除一个仓库
  home &lt;仓库名&gt; [browser]      用可选浏览器打开仓库首页
  test [仓库名]                展示指定仓库或者所有仓库的响应时间
  help                         打印帮助
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[自制操作系统log]]></title>
        <id>https://ibert.me/posts/zh/自制操作系统log.html</id>
        <link href="https://ibert.me/posts/zh/自制操作系统log.html"/>
        <updated>2019-09-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>参考书</h2>
<ul>
<li>《三十天自制操作系统（川合秀实）》</li>
<li>《ORANGE'S：一个操作系统的实现》</li>
</ul>
<h2>写在前面的</h2>
<p>本记录不展示原版书籍的内容，仅作为自己历程的记录和总结。两本书各有所长，根据自己的喜好选择和实践。书籍中的内容根据自己的喜好、习惯，有一定的自己理解和改变！本记录默认对二进制、十六进制和基础硬件等都有一定的了解！</p>
<!-- more -->
<h2>制作启动区(512字节)</h2>
<p>从开始我对两本书都是懵逼的，结合两本书涉及的启动盘代码总结一点东西</p>
<pre><code class="language-asm">ORG 0x7c00                  ; 程序加载0x7c00

; FAT12格式软盘代码位
; (--省略--)

JMP entry
DB 0x90

entry:
        MOV AX, 0           ; 初始化寄存器
        MOV SS, AX
        MOV SP, 0x7c00
        MOV DS, AX
        MOV ES, AX

        MOV SI, msg

putloop:
        MOV AL, [SI]        ; []表示内存中
        ADD SI, 1           ; SI加一
        CMP AL, 0

        JE fin              ; jump if equal
        MOV AH, 0x0e        ; 显示一个文字
        MOV BX, 15          ; 指定字符颜色
        INT 0x10            ; 调用显卡BIOS，INT软件中断指令
        JMP putloop

fin:
        HLT                 ; 让CPU停止等待指令
        JMP fin             ; 无限循环

msg:
        DB 0x0a, 0x0a       ; 换行
        DB &quot;hello, world&quot;
        DB 0x0a
        DB 0

        RESB 0x7dfe-$       ; 填写0x00直到0x001fe
        DB 0x55, 0xaa       ; 结束
</code></pre>
<blockquote>
<p>注意：30天那个书制作启动盘的部分完全可以看看就行。。。代码就是上面的，就是helloos.nas节选那个末尾加上了两行，写满512字节和结束标志！</p>
</blockquote>
<p>代码直接看<a href="https://github.com/yourtion/30dayMakeOS">这个库</a></p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[免费证书实现https(保姆级教程)]]></title>
        <id>https://ibert.me/posts/zh/免费证书实现https(保姆级教程).html</id>
        <link href="https://ibert.me/posts/zh/免费证书实现https(保姆级教程).html"/>
        <updated>2019-08-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>使用Certbot</h2>
<p>Certbot使用的是<a href="https://letsencrypt.org">Let's Encrypt</a>的证书，该组织也强烈建议使用<a href="https://certbot.eff.org/">Certbot</a>获取证书。</p>
<h2>Certbot配置</h2>
<p>使用这个的目的是获取通配符证书，也就是支持二级域的证书验证，避免https错误的预警。</p>
<ul>
<li>主机商: 阿里云</li>
<li>系统版本: Ubuntu18.04</li>
<li>Web服务: nginx</li>
<li>使用环境: python3</li>
</ul>
<!-- more -->
<h3>在Certbot</h3>
<p>进入<a href="https://certbot.eff.org/">Certbot</a>选择Web服务和系统</p>
<img src="https://ibert.me/img/20190801231928.png">
<p>上图我选的是在Ubuntu18.04上面跑的nginx。下面的提示就是你使用证书实现https之前需要有一个正常运行的网站，并且得有sudo的权限(直接云服务器实例，轻量应用服务器之类的就可以了)</p>
<img src="/img/20190801232653.png">
<p>可以选择 <strong>默认(Default)</strong> 和 <strong>通配符(wildcard)</strong></p>
<h4>默认的就是一张单域名的证书 (我用的是通配符的，直接通配符的可以跳过这一节)</h4>
<ol>
<li>
<p>SSH连接</p>
</li>
<li>
<p>添加Certbot PPA到库(阿里云root下不需要sudo就直接可以的，下同)</p>
<pre><code class="language-shell">apt update
apt install software-properties-common
add-apt-repository universe
add-apt-repository ppa:certbot/certbot
apt-get update
</code></pre>
</li>
<li>
<p>下载Certbot</p>
<pre><code class="language-shell">apt install certbot python-certbot-nginx
</code></pre>
</li>
<li>
<p>选择使用一种方式(推荐使用手动！！)</p>
<p>自动：使用Certbot下载证书并且更新你的nginx设置</p>
<pre><code class="language-shell">certbot --nginx
</code></pre>
<p>手动：只下载证书，手动配置/重启/重载nginx(手动配置nginx需要对nginx有一定的了解，下面的参考文章里有阿里云ssl配置的参考)</p>
<pre><code class="language-shell">certbot certonly --nginx
# 主要区别就在于certonly这个参数，通配符咱们也会遇到
</code></pre>
<blockquote>
<p>证书成功生成之后会有信息显示证书所在的位置的，或者运行下面的命令查看证书，然后配置nginx的ssl_certificate和ssl_certificate_key这两个参数就好了。其中privkey.pem对应的就是ssl_certificate_key的目标文件。</p>
</blockquote>
<pre><code class="language-shell">certbot certificates
</code></pre>
</li>
<li>
<p>测试自动更新</p>
<p>Certbot支持自动更新证书，然后自动添加了定时任务，就不需要手动更新证书了。官网说在/etc/crontab、/etc/cron.*/*或者systemctl list-timers里面使用了，不放心的可以手动添加定时任务并且设置重启nginx的。</p>
<pre><code class="language-shell">certbot renew --dry-run
# --dry-run这个参数用于测试的
</code></pre>
</li>
<li>
<p>查看的网站的状态</p>
<p>这个要看具体的配置，80端口开启ssl直接就好了，443端口https访问！</p>
</li>
</ol>
<h4>通配符证书</h4>
<ol>
<li>
<p>检查DNS服务商是否被支持（国内的就不用看了）</p>
</li>
<li>
<p>SSH连接</p>
</li>
<li>
<p>添加Certbot PPA到库(阿里云root下不需要sudo就直接可以的，下同)</p>
<pre><code class="language-shell">apt update
apt install software-properties-common
add-apt-repository universe
add-apt-repository ppa:certbot/certbot
apt-get update
</code></pre>
</li>
<li>
<p>下载Certbot</p>
<pre><code class="language-shell">apt install certbot python-certbot-nginx
</code></pre>
</li>
<li>
<p>下载正确的插件(国内的，从这一步开始咱们就可以下一章了！)</p>
</li>
</ol>
<h2>通配符插件国内主机如何解决之使用certbot-letencrypt-wildcardcertificates-alydns-au</h2>
<p>Certbot官方有给出插件的编写的方法，也有提供第三方的插件(有兴趣自行去了解)。国内有大佬自己写了插件，在此使用的是<a href="https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au">certbot-letencrypt-wildcardcertificates-alydns-au</a>，文档比较友好，并且issues的回复也很快。</p>
<blockquote>
<p>特别提醒： <strong>下面官方的使用参考文档中的所有./certbot-auto命令不再支持！请使用直接使用certbot！</strong> 下面是基于aliyun+python+nginx的演示，具体流程和参数说明请直接参考官方文档！！</p>
</blockquote>
<h3>下载到/var下</h3>
<pre><code class="language-shell">cd /var
git clone https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au
cd certbot-letencrypt-wildcardcertificates-alydns-au
chmod 0777 au.sh
</code></pre>
<h3>配置domain.ini</h3>
<pre><code class="language-shell">cat domain.ini
# 如果有自己域名后缀的话就不用执行下面修改了
nano domain.ini
</code></pre>
<h3>获取阿里云的accesskey(腾讯云请参考官方文档)</h3>
<p>参考 <a href="https://help.aliyun.com/knowledge_detail/38738.html">阿里云API Key和Secret的申请</a></p>
<h3>修改au.sh参数</h3>
<pre><code class="language-shell">nano au.sh
</code></pre>
<pre><code class="language-bash"># 填写下面两个参数
ALY_KEY=&quot;&quot;
ALY_TOKEN=&quot;&quot;
# 命令行路径可以修改，/usr/bin/python可以改为/usr/bin/python3，不过作者已经对python2、3都进行了适配
</code></pre>
<h3>申请证书(nginx+python)</h3>
<p>测试配置</p>
<pre><code class="language-shell">certbot certonly  -d *.example.com --manual --preferred-challenges dns --dry-run  --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;
</code></pre>
<pre><code class="language-shell"># 一个顶级域名获取通配符证书直接修改*.example.com为自己的就好了，上述命令去掉--dry-run参数
# 以baidu.com举例(python)

certbot certonly  -d *.baidu.com --manual --preferred-challenges dns --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;
</code></pre>
<p>SAN通配符证书(直接添加-d 和域名就好了)</p>
<pre><code class="language-shell"># 基于官方示例(python)
certbot certonly  -d *.example.com -d *.example.org -d www.example.cn --manual --preferred-challenges dns --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;
</code></pre>
<h3>配置nginx</h3>
<p>上面包括下面的所有命令都带certonly，因此所有的操作都是只做认证，nginx需要自行修改配置！！</p>
<blockquote>
<p>证书成功生成之后会有信息显示证书所在的位置的，或者运行下面的命令查看证书，然后配置nginx的ssl_certificate和ssl_certificate_key这两个参数就好了。其中privkey.pem对应的就是ssl_certificate_key的目标文件。</p>
</blockquote>
<p>如果不知道证书的位置，可以使用下面的命令查看</p>
<pre><code class="language-shell">certbot certificates
</code></pre>
<p>配置完成之后</p>
<pre><code class="language-shell">service nginx restart
</code></pre>
<h3>证书的续期</h3>
<p>请直接参考<a href="https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au/blob/master/README.md">官方文档</a>，下面贴出来的只是基于官方文档的 <strong>阿里云+python版</strong> shell，官方演示shell使用的都是php和阿里云！！</p>
<pre><code class="language-shell"># 所有证书renew
certbot renew  --manual --preferred-challenges dns --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;

# 某一张证书续期
# 查看证书
certbot certificates

# 记住证书名，比如simplehttps.com
certbot renew --cert-name simplehttps.com  --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;
</code></pre>
<h3>加入crontab</h3>
<p>因为我使用了nginx，所以添加crontab就直接renew成功之后重启nginx了。这里强烈建议service nginx restart重启！nginx -s reload重载nginx.conf配置时并不一定会报错而带来影响debug的问题。</p>
<pre><code class="language-shell">nano /etc/crontab
</code></pre>
<p>添加内容</p>
<pre><code class="language-crontab">1 1 */1 * * root certbot-auto renew --manual --preferred-challenges dns --deploy-hook  &quot;service nginx restart&quot; --manual-auth-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly add&quot; --manual-cleanup-hook &quot;/var/certbot-letencrypt-wildcardcertificates-alydns-au/au.sh python aly clean&quot;
</code></pre>
<p>然后，就结束了！！</p>
<h2>参考文章</h2>
<ul>
<li><a href="https://blog.csdn.net/u010102390/article/details/80505451">linux的crontab定时配置全过程</a></li>
<li><a href="https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au/blob/master/README.md">插件certbot-letencrypt-wildcardcertificates-alydns-au的使用</a></li>
<li><a href="https://help.aliyun.com/knowledge_detail/95491.html?spm=5176.2020520163.cas.52.5cd656a7iFDuEI">Nginx/Tengine服务器安装SSL证书</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog-HDL基础语法（下）]]></title>
        <id>https://ibert.me/posts/zh/Verilog-HDL基础语法（下）.html</id>
        <link href="https://ibert.me/posts/zh/Verilog-HDL基础语法（下）.html"/>
        <updated>2019-07-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>过程块</h2>
<ul>
<li>initial块，只执行一次</li>
<li>always块，循环执行</li>
</ul>
<p>过程块中的部件：</p>
<ul>
<li>过程赋值语句</li>
<li>高级结构（循环，条件语句）</li>
<li>时序控制</li>
</ul>
<!-- more -->
<h2>过程赋值</h2>
<p>过程赋值的对象必须是寄存器类型，过程赋值语句给wire赋值会产生错误！！</p>
<h2>过程时序控制</h2>
<ul>
<li>简单延时(#delay)：延时指定时间之后执行</li>
<li>边沿敏感的时序控制：@(&lt;signal&gt;)，上升沿(posedge)，下降沿(negedge)，用关键字or指定多个参数</li>
<li>电平敏感的时序控制：wait(&lt;expr&gt;)，expr为真时执行</li>
</ul>
<p>！！！综合工具不支持 <strong>wait语句</strong> ！！！</p>
<p>内容参考 <a href="https://wenku.baidu.com/view/b4a43aefaeaad1f346933f7d.html">百度文库</a>，不支持综合的部分内容，略。</p>
<h2>块语句</h2>
<ul>
<li>顺序块：语句置于begin和end之间，块中语句顺序执行</li>
<li>并行块：语句置于fork和join之间，语句并行执行（不可综合）</li>
</ul>
<h2>延时赋值语句（可以用于模拟寄存器交换和移位）</h2>
<pre><code class="language-verilog">LHS = &lt;timing_control&gt; RHS;

// 举例
begin
    temp = b;
    @(posedge clk) a = temp;
end

// 等价于

a = @(posedge clk) b;
</code></pre>
<h2>阻塞赋值与非阻塞赋值</h2>
<ul>
<li>阻塞赋值：语句结束立即完成赋值操作，前面的赋值语句完成之前，后面的语句不能被执行，使用 &quot;=&quot;</li>
<li>非阻塞赋值：整个过程块结束时才完成赋值操作，使用 &quot;&lt;=&quot;</li>
</ul>
<p>对比举例</p>
<pre><code class="language-verilog">// 非阻塞赋值
module non_block(c, b, a, clk);
    output c, b;
    input a, clk;
    reg c, b;
    always @(posedge clk)
        begin
        b &lt;= a;
        c &lt;= b;
        end
endmodule

// 阻塞赋值
module block(c, b, a, clk);
    output c, b;
    input a, clk;
    reg c, b;
    always @(posedge clk)
        begin
        b = a;
        c = b;
        end
endmodule

// 非阻塞赋值中c的结果为上一个时刻的b的值（旧值），阻塞赋值中c和b的值相等
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Verilog HDL基础语法（上）]]></title>
        <id>https://ibert.me/posts/zh/Verilog-HDL基础语法（上）.html</id>
        <link href="https://ibert.me/posts/zh/Verilog-HDL基础语法（上）.html"/>
        <updated>2019-07-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>写在前面的</h2>
<p>本博客是对于自己接触基于Verilog硬件开发学习的基础语法学习笔记！接触Verilog之前一定要有《数字电子技术》的基础！</p>
<p>Verilog HDL是一门硬件描述性语言，可以类似于软件开发一样去做硬件开发。符合“顶层设计”，与传统的搭电路是不一样的，学习过C之类的会更容易。</p>
<p>对于基础概念和简介在此跳过了！！<strong>Verilog大小写敏感！</strong></p>
<p>关于寄存器、锁存器、触发器可以参考 <a href="https://blog.csdn.net/hengzo/article/details/53164626">锁存器与寄存器的区别</a></p>
<!-- more -->
<h2>Verilog的注释</h2>
<p>和C一样，<code>//</code> 为单行注释，<code>/* */</code>为多行注释</p>
<h2>module初探</h2>
<p>module模块由module和endmodule包裹</p>
<pre><code class="language-verilog">module &lt;模块名&gt;(&lt;端口列表&gt;)
&lt;端口说明&gt;
&lt;内部信号说明&gt;
&lt;功能定义&gt;
endmodule
</code></pre>
<ul>
<li>端口：相当于硬件的pin <strong>模块通过端口与外部通信</strong></li>
<li>端口说明：input和output（输入or输出）</li>
</ul>
<p><img src="https://ibert.me/img/20170926191009923.png" alt="输入输出"></p>
<!-- <img src="/img/20170926191009923.png"> -->
<pre><code class="language-verilog">module block(a,b,c,d);
    // 端口说明
    input a,b;
    output c,d;

    // 不指明内部信号说明，默认为wire

    // 功能定义
    assign c=a | b;
    assign d=a &amp; b;
endmodule
</code></pre>
<h2>Verilog基础</h2>
<h3>术语</h3>
<ol>
<li>空白符：空格、tabs、换行</li>
<li>标识符：对象的名字</li>
<li>关键字：比如module之类的</li>
<li>LSB：最低有效位</li>
<li>MSB：最高有效位</li>
</ol>
<h3>Verilog的四值逻辑系统</h3>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">低位，逻辑假</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">高位，逻辑真</td>
</tr>
<tr>
<td style="text-align:center">x或X</td>
<td style="text-align:left">不定态</td>
</tr>
<tr>
<td style="text-align:center">z或Z</td>
<td style="text-align:left">高阻态</td>
</tr>
</tbody>
</table>
<h3>常量及其表示</h3>
<p>常量分为整数型和实数型</p>
<ol>
<li>
<p>整数的大小可以定义也可不。表示为：</p>
<pre><code class="language-verilog">&lt;size&gt;'&lt;base&gt;&lt;value&gt;
</code></pre>
<ul>
<li>size：位数大小，由十进制数表示。<strong>缺省为32位</strong></li>
<li>base：数基，2(b),8(o),10(d),16(h)进制。<strong>缺省为10进制</strong></li>
<li>value：基内的有效数字</li>
</ul>
<blockquote>
<p>注意：规定了位数大小，如果值超过位数会舍掉超过的高位！</p>
</blockquote>
</li>
<li>
<p>实数常量可以用十进制数或科学计数法表示</p>
<table>
<thead>
<tr>
<th style="text-align:center">实例</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">未规定大小的十进制数</td>
</tr>
<tr>
<td style="text-align:center">'h83a</td>
<td style="text-align:left">未规定大小的十六进制数</td>
</tr>
<tr>
<td style="text-align:center">8'b1100 0001</td>
<td style="text-align:left">八位二进制数</td>
</tr>
<tr>
<td style="text-align:center">16'hff01</td>
<td style="text-align:left">十六位十六进制数</td>
</tr>
<tr>
<td style="text-align:center">32'bz01x</td>
<td style="text-align:left">Z扩展至32位</td>
</tr>
<tr>
<td style="text-align:center">3'b1010 1101</td>
<td style="text-align:left">3位数字，3'b101</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">6.3</td>
<td style="text-align:left">十进制数</td>
</tr>
<tr>
<td style="text-align:center">32e-4</td>
<td style="text-align:left">0.0032的科学计数法表示</td>
</tr>
<tr>
<td style="text-align:center">4.1E3</td>
<td style="text-align:left">4100的科学计数法表示</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>注意的一些点</p>
<p>整数：</p>
<ul>
<li>size缺省即32位</li>
<li>数基缺省即10进制</li>
<li>数基和数字中字母无大小写之分</li>
<li>value大于指定大小时，截去高位2'b1101 =&gt; 2'b01</li>
</ul>
<p>实数：</p>
<ul>
<li>可以用十进制或者科学计数法表示</li>
<li>表示方法，略，见上面表格的例子</li>
</ul>
</li>
</ol>
<h3>字符串（仅用在测试中）</h3>
<p>大多用于显示信息的命令中，由一对双引号包裹！</p>
<ul>
<li>不能跨行</li>
<li>可以使用格式符，比如：%b</li>
<li>可以使用转义符，比如：\t</li>
</ul>
<h3>标识符</h3>
<ul>
<li>对象名字</li>
<li>必须以( a-z, A-Z )或( _ )开头，后面可以是字母、数字、( $ )或( _ )</li>
<li>最长1023个字符</li>
<li>区分大小写</li>
</ul>
<blockquote>
<p><strong>所有的Verilog的关键字都是小写字母！</strong></p>
</blockquote>
<h3>数据类型</h3>
<ol>
<li>
<p>线网类型（net type）：表示Verilog结构化元件间的物理连线。缺省为z。</p>
<p>需要被持续驱动，门或者模块都可以！net驱动器值变化时，新值被传送到net上。</p>
<table>
<thead>
<tr>
<th style="text-align:center">net类型</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wire, tri</td>
<td style="text-align:left">标准内部连接线（缺省）</td>
</tr>
<tr>
<td style="text-align:center">supply1, supply0</td>
<td style="text-align:left">电源和地</td>
</tr>
<tr>
<td style="text-align:center">wor, trior</td>
<td style="text-align:left">多驱动源线或</td>
</tr>
<tr>
<td style="text-align:center">wand, triand</td>
<td style="text-align:left">多驱动源线与</td>
</tr>
<tr>
<td style="text-align:center">trireg</td>
<td style="text-align:left">能保存电荷的net</td>
</tr>
<tr>
<td style="text-align:center">tri1, tri0</td>
<td style="text-align:left">无驱动时上拉/下拉</td>
</tr>
</tbody>
</table>
<blockquote>
<p>可综合的线网数据类型：<strong>wire</strong>、wor、wand、tri、supply1、supply0。缺省默认为1位wire！！！</p>
</blockquote>
<p>使用语法：</p>
<pre><code class="language-verilog">&lt;net类型&gt; [msb:lsb] net1, net2, ..., netN
</code></pre>
</li>
<li>
<p>寄存器类型（register type）：表示一个抽象的数据存储单元，只能在always和initial等过程语句中被赋值，并且它的值从一个赋值到另一个赋值被保存下来。缺省为x。</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器类型</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">reg</td>
<td style="text-align:left">最常用，无符号型</td>
</tr>
<tr>
<td style="text-align:center">integer</td>
<td style="text-align:left">32位有符号整型，算术操作产生二进制补码形式。通常不用于由硬件实现的数据处理</td>
</tr>
<tr>
<td style="text-align:center">real</td>
<td style="text-align:left">双精度的带符号的浮点变量，用法上同</td>
</tr>
<tr>
<td style="text-align:center">time</td>
<td style="text-align:left">64位无符号整数变量，用于<strong>仿真时间</strong>保存与处理</td>
</tr>
<tr>
<td style="text-align:center">realtime</td>
<td style="text-align:left">上同，但可以<strong>用于实数仿真时间</strong>保存与处理</td>
</tr>
</tbody>
</table>
<p>reg使用语法：</p>
<pre><code class="language-verilog">reg [msb:lsb] reg1, reg2, ..., regN              // [msb:lsb]缺省即1位
</code></pre>
<p>integer使用语法：</p>
<pre><code class="language-verilog">integer A, B, C;
</code></pre>
</li>
<li>
<p>参数</p>
<p>参数是一个常量，<strong>建议常量使用大写字母，变量使用小写字母</strong></p>
<p>定义语法：</p>
<pre><code class="language-verilog">parameter &lt;list_of_assignment&gt;;          // 多个使用逗号隔开

examples:
parameter WIDTH = 8'h20;

parameter WORD_WIDTH = 8;
wire[WORD_WIDTH:0] int1;

parameter WORD_WIDTH = 32, ADDR_WIDTH = 8;
</code></pre>
<blockquote>
<p>参数的定义是 <strong>局部的</strong>，只在 <strong>当前模块</strong> 有效。和 `define有区别 ！</p>
</blockquote>
</li>
<li>
<p>位选择</p>
<p>位选择从向量中抽取特定的位，整数不能作为位向量访问。</p>
</li>
<li>
<p>常见信号类型</p>
<ul>
<li>寄存器类型：reg（在always等过程快中被赋值的信号，往往代表触发器，但是不一定）<strong>时序逻辑电路中常常被综合为D触发器，纯组合逻辑电路中被组合为连线</strong></li>
<li>连线类型：wire：用assign关键字给指定连续/持续赋值所描述的组合逻辑信号或者连线。</li>
</ul>
</li>
</ol>
<p>Verilog中reg与wire不同点举例 <a href="https://max.book118.com/html/2017/0523/108520648.shtm">参考PPT</a></p>
<p><img src="/img/20190718230151.png" alt="图片"></p>
<pre><code class="language-verilog">// 用寄存器类型变量生成组合逻辑
module rw1(a, b, out1, out2);
    input a, b;
    output out1, out2;
    reg out1;
    wire out2;

    assign out2 = a;
    always @(b) out1 = ~b;
endmodule
</code></pre>
<p><img src="/img/20190718230334.png" alt="图片"></p>
<pre><code class="language-verilog">// 用寄存器生成触发器
module rw2(clk, d, out1, out2);
    input clk, b;
    output out1, out2;
    reg out1;
    wire out2;

    assign out2 = d &amp; ~out1;
    always @(posedge clk)
        out1 &lt;= d;
endmodule
</code></pre>
<h3>Verilog的运算符</h3>
<p>不面向纯的编程小白，在此就不细解释了，和其他语言大都一样。</p>
<table>
<thead>
<tr>
<th style="text-align:center">算术及逻辑运算符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:left">整除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">取模</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">丨丨</td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:left">逻辑非</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ol>
<li>将负数赋值给reg或其他无符号变量，使用2的补码算术</li>
<li>如果一位操作数是x或z，则结果为x</li>
<li>模运算使用第一个操作数的符号</li>
<li>integer和reg算术有差异，一个有符号，一个没有</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">按位操作运算符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:left">一元非</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">二元与</td>
</tr>
<tr>
<td style="text-align:center">丨</td>
<td style="text-align:left">二元或</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">二元异或</td>
</tr>
<tr>
<td style="text-align:center">~^, ^~</td>
<td style="text-align:left">二元异或非</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">关系运算符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:left">不小于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:left">不大于</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">相等操作符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:left">逻辑等</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:left">逻辑不等</td>
</tr>
<tr>
<td style="text-align:center">===</td>
<td style="text-align:left">相同（case等）</td>
</tr>
<tr>
<td style="text-align:center">!==</td>
<td style="text-align:left">不相同（case不等）</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>对于有值不确定的位，确定的位相等，结果为x</li>
<li>===左右值（包含x,z）相同为一，不可被综合！</li>
</ul>
<h4>条件操作符</h4>
<pre><code class="language-verilog">&lt;LHS&gt;=&lt;condition&gt;?&lt;true_expression&gt;:&lt;false_expression&gt;;
</code></pre>
<p>与其他语言一样，缺少参数会出现错误！</p>
<table>
<thead>
<tr>
<th style="text-align:center">移位操作符</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:left">左移</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:left">右移</td>
</tr>
</tbody>
</table>
<p>第二位操作数为无符号数！</p>
<h4>连接操作</h4>
<p>将小表达式合并成大表达式！</p>
<pre><code class="language-verilog">{expr1, expr2, expr3, ..., exprN}

// 实例
wire [9:0] d;
wire [9:0] a;
assign d[9:5] = {a[0], a[1], a[2], a[3], a[4]};  // 以反转的顺序把a的低五位赋值给d的高五位

assign d = {d[4:0], d[9:5]};  // 高五位与低五位交换
</code></pre>
<p>！！不允许连接非定长常数！！</p>
<pre><code class="language-verilog">reg [16:0] a;
reg [31:0] d;
...
d = {a,5};           // 不允许连接非定长常数
d = {a, 16'h0005}    // 左边32位，右边33位，位宽不匹配，一样会报错
</code></pre>
<h4>复制操作</h4>
<pre><code class="language-verilog">{repetition_number{expr1, expr2, ..., exprN}}
</code></pre>
<p>复制指定重复次数来执行操作</p>
<pre><code class="language-verilog">// 实例
wire [7:0] d;
wire [11:0] a;
...
assign d = {2{4'b1011}};          // d =&gt; 8'b1011 1011

/* 符号扩展 */
{3{1'b1}}   // 结果为3'b111
{3{Ack}}    // 和{Ack, Ack, Ack}相同
</code></pre>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NumPy的一些点]]></title>
        <id>https://ibert.me/posts/zh/NumPy的一些点.html</id>
        <link href="https://ibert.me/posts/zh/NumPy的一些点.html"/>
        <updated>2019-07-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>参考教程</h2>
<p><a href="https://www.runoob.com/numpy">runoob numpy</a></p>
<h2>NumPy Ndarray对象</h2>
<ul>
<li>N维数组对象</li>
<li>同类型数据的集合</li>
<li>从0下标开始元素索引</li>
</ul>
<!-- more -->
<p>组成</p>
<ul>
<li>一个指向数据的指针</li>
<li>数据类型/dtype(描述数组中固定大小值)</li>
<li>一个表示数组形状的元组(表示各维度大小的元组)</li>
<li>一个跨度元组，其中的整数是指为了前进到当前维度下一个元素所需要“跨过”的字节数</li>
</ul>
<blockquote>
<p>跨度可以是负数，这样会使数组在内存中后向移动</p>
</blockquote>
<pre><code class="language-python">numpy.array(object, dtype = None, copy = True, oreder = None, subok = False, ndmin = 0)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">object</td>
<td style="text-align:left">数组或嵌套的数列</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">元素的数据类型，可选</td>
</tr>
<tr>
<td style="text-align:left">copy</td>
<td style="text-align:left">对象是否需要复制，可选</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left">创建数据的样式，C行，F列，A任意(默认)</td>
</tr>
<tr>
<td style="text-align:left">subok</td>
<td style="text-align:left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td style="text-align:left">ndmin</td>
<td style="text-align:left">指定生成数组的最小维度</td>
</tr>
</tbody>
</table>
<h2>NumPy数据类型</h2>
<p>参考NumPy数据类型的<a href="https://www.runoob.com/numpy/numpy-dtype.html">教程</a>，主要规定数据类型对象的数据结构(类似于C的结构体，内建类型相当于是正则)</p>
<h2>NumPy数组属性</h2>
<p>NumPy数组的维数成为秩(rank)，一维数组的秩为1，以此类推。每一个一维线性数组称为一个轴(axis)，也就是维度(dimensions)。</p>
<p><img src="https://ibert.me/img/20190219173235151.jpg" alt="图片"></p>
<blockquote>
<p>axis所代表的如上图所示，图片来源于 <a href="https://blog.csdn.net/Babyfatliang/article/details/87721282">CSDN</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ndarray.ndim</td>
<td style="text-align:left">秩，轴的数量(维度的数量)</td>
</tr>
<tr>
<td style="text-align:left">ndarray.shape</td>
<td style="text-align:left">数组的维度，对于矩阵， n行m列</td>
</tr>
<tr>
<td style="text-align:left">ndarray.size</td>
<td style="text-align:left">元素的总个数，相当于.shape中n*m的值</td>
</tr>
<tr>
<td style="text-align:left">ndarray.dtype</td>
<td style="text-align:left">ndarray对象的元素类型</td>
</tr>
<tr>
<td style="text-align:left">ndarray.itemsize</td>
<td style="text-align:left">ndarray对象中每个元素的大小，以字节为单位</td>
</tr>
<tr>
<td style="text-align:left">ndarray.flasgs</td>
<td style="text-align:left">ndarray对象的内存信息</td>
</tr>
<tr>
<td style="text-align:left">ndarray.real</td>
<td style="text-align:left">ndarray元素的实部</td>
</tr>
<tr>
<td style="text-align:left">ndarray.imag</td>
<td style="text-align:left">ndarray元素的虚部</td>
</tr>
<tr>
<td style="text-align:left">ndarray.data</td>
<td style="text-align:left">包含实际数组元素的缓冲区，通常不使用这个属性</td>
</tr>
</tbody>
</table>
<h2>NumPy创建数组</h2>
<h3>numpy.empty</h3>
<p>用来创建一个指定形状和数据类型的未初始化的数组：</p>
<pre><code class="language-python">numpy.empty(shape, dtype = float, order = 'C')
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shape</td>
<td style="text-align:left">数组形状</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">数据类型，可选</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left">C行优先，F列优先</td>
</tr>
</tbody>
</table>
<h3>numpy.zeros</h3>
<p>创建指定大小的数组，元素全是0</p>
<pre><code class="language-python">numpy.zeros(shape, dtype = float, order = 'C')
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">shape</td>
<td style="text-align:left">数组的形状</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">数据类型，可选</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left">C行数组，F列数组</td>
</tr>
</tbody>
</table>
<h3>numpy.ones</h3>
<p>同上</p>
<h2>NumPy从已有的数组创建数组</h2>
<h3>numpy.asarray</h3>
<p>numpy.asarray类似numpy.array，但numpy.asarray只有三个参数</p>
<pre><code class="language-python">numpy.asarray(a, dtype = None, order = None)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">任意形式的输入参数，列表、元组及其嵌套和多维数组</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">数据类型，可选</td>
</tr>
<tr>
<td style="text-align:left">order</td>
<td style="text-align:left">C行优先，F列优先</td>
</tr>
</tbody>
</table>
<h3>numpy.frombuffer</h3>
<p>numpy.frombuffer用于实现动态数组</p>
<p>numpy.frombuffer接受buffer输入参数，以流的形式读入转化成ndarray对象</p>
<pre><code class="language-python">numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)
</code></pre>
<blockquote>
<p>buffer是字符串的时候，python3默认str是Unicode，转化成bytestring在原str前加b</p>
</blockquote>
<p>报错：<strong>AttributeError: 'str' object has no attribute '__buffer__'</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">buffer</td>
<td style="text-align:left">任意对象，流式读入</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">返回的数组数据类型</td>
</tr>
<tr>
<td style="text-align:left">count</td>
<td style="text-align:left">读取的数据数量，默认-1读取所有</td>
</tr>
<tr>
<td style="text-align:left">offset</td>
<td style="text-align:left">读取的起始位置，默认0</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">s = b'Hello World'
x = np.frombuffer(s, dtype = 'S1')
</code></pre>
<h3>numpy.fromiter</h3>
<p>从可迭代对象中建立ndarray对象，返回一维数组</p>
<pre><code class="language-python">numpy.fromiter(iterable, dtype, count = -1)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">iterable</td>
<td style="text-align:left">可迭代对象</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">返回数组的数据类型</td>
</tr>
<tr>
<td style="text-align:left">count</td>
<td style="text-align:left">读取的数据数量</td>
</tr>
</tbody>
</table>
<h2>NumPy从数值范围创建数组</h2>
<h3>numpy.arange</h3>
<p>使用arange函数创建数值范围并返回ndarray对象</p>
<pre><code class="language-python">numpy.arange(start, stop, step, dtype)
</code></pre>
<p>参数说明，略</p>
<h3>numpy.linspace</h3>
<p>numpy.linspace函数用于创建一个一维数组，并且为等差数列</p>
<pre><code class="language-python">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">start</td>
<td style="text-align:left">序列起始值</td>
</tr>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:left">序列终止值，endpoint为True包含</td>
</tr>
<tr>
<td style="text-align:left">num</td>
<td style="text-align:left">要生成等步长的样本数量，默认50</td>
</tr>
<tr>
<td style="text-align:left">endpoint</td>
<td style="text-align:left">见上</td>
</tr>
<tr>
<td style="text-align:left">retstep</td>
<td style="text-align:left">True时生成数组会显示间距，反之</td>
</tr>
<tr>
<td style="text-align:left">dtype</td>
<td style="text-align:left">ndarray的数据类型</td>
</tr>
</tbody>
</table>
<h3>numpy.logspace</h3>
<p>用于创建等比数列</p>
<pre><code class="language-python">np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)
</code></pre>
<p>base即为取对数的时候log的下标(底数)</p>
<h2>NumPy切片和索引</h2>
<p>与python的list切片操作一样</p>
<p>完全可以使用列表的 <strong>start:stop:step</strong> 的切片操作！</p>
<p>或者：</p>
<pre><code class="language-python">a = np.arange(10)
s = slice(2, 7, 2)
print(a[s])
</code></pre>
<p>切片还可以使用省略号 (...)</p>
<pre><code class="language-python">import numpy as np

a = np.array([[1,2,3],[3,4,5],[4,5,6]])
print(a[...,1])   # 第2列元素
print(a[1,...])   # 第2行元素
print(a[...,1:])  # 第2列及剩下的所有元素
</code></pre>
<p>输出结果：</p>
<blockquote>
<ol>
<li>[2 4 5]</li>
<li>[3 4 5]</li>
<li>[[2 3]<br>
[4 5]<br>
[5 6]]</li>
</ol>
</blockquote>
<h2>NumPy高级索引</h2>
<p>相比于Python的索引，numpy提供了更多的索引方式。数组可以整数数组索引、布尔索引及花式索引。</p>
<h3>整数数组索引</h3>
<p>获取(0, 0) (1, 1) (2, 0)处的元素：</p>
<pre><code class="language-python">import numpy as np

x = np.array([[1, 2], [3, 4], [5, 6]])
y = x[[0, 1, 2], [0, 1, 0]]
print(y)

# 输出 [1 4 5]
</code></pre>
<blockquote>
<p>返回结果为ndarray对象</p>
</blockquote>
<p>可以借助 : , ... 和索引数组组合</p>
<pre><code class="language-python">import numpy as np

a = np.array([[1,2,3], [4,5,6],[7,8,9]])
b = a[1:3, 1:3]
c = a[1:3,[1,2]]
d = a[...,1:]
print(b)
print(c)
print(d)

# 输出：
# [[5 6]
#  [8 9]]
# [[5 6]
#  [8 9]]
# [[2 3]
#  [5 6]
#  [8 9]]
</code></pre>
<h3>布尔索引</h3>
<p>通过布尔数组索引目标数组，对数组元素进行布尔运算获取符合指定元素条件的数组。</p>
<pre><code class="language-python">import numpy as np

x = np.array([[0, 1, 2],[3, 4, 5],[6, 7, 8],[9, 10, 11]])
print(x[x &gt; 5])

# 输出：[6 7 8 9 10 11]
</code></pre>
<p>使用取补运算符 ~ 来过滤NaN</p>
<pre><code class="language-python">import numpy as np

a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5])
print(a[~np.isnan(a)])

# 输出：[1. 2. 3. 4. 5.]
</code></pre>
<p>过滤非复数元素</p>
<pre><code class="language-python">import numpy as np
a = np.array([1, 2+6j, 5, 3.5+5j])
print (a[np.iscomplex(a)])

# 输出：[2.0+6.j 3.5+5.j]
</code></pre>
<h3>花式索引</h3>
<p>花式索引利用整数数组来索引，把整数索引当作轴进行索引。对于轴的理解，可以参考上面！跟切片不一样的是它将数据复制到新的数组中（对切片感兴趣的可以使用id()这个函数研究列表和元素对应关系的！这样便于理解这一句话！）</p>
<pre><code class="language-python">
import numpy as np

x = np.arange(32).reshape((8, 4))
print(x)
print(x[[4, 2, 1, 7]])
# 倒序
print(x[[-4, -2, -1, -7]])
# 多个索引数组
print(x[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])])

# 输出：
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]
#  [12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]
#  [24 25 26 27]
#  [28 29 30 31]]

# [[16 17 18 19]
#  [ 8  9 10 11]
#  [ 4  5  6  7]
#  [28 29 30 31]]

# [[16 17 18 19]
#  [24 25 26 27]
#  [28 29 30 31]
#  [ 4  5  6  7]]

# [[ 4  7  5  6]
#  [20 23 21 22]
#  [28 31 29 30]
#  [ 8 11  9 10]]
</code></pre>
<h2>NumPy广播</h2>
<p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行</p>
<p>如果形状相同即对应位运算，不同则触发广播机制。</p>
<pre><code class="language-python">import numpy as np

a = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]])
b = np.array([1, 2, 3])
print(a + b)

# [[ 1  2  3]
#  [11 12 13]
#  [21 22 23]
#  [31 32 33]]
</code></pre>
<p><img src="/img/1222.png" alt="图片"></p>
<p>原理和要求请参考 <a href="https://www.runoob.com/numpy/numpy-broadcast.html">NumPy广播</a></p>
<h2>NumPy迭代数组</h2>
<p>使用迭代器对象numpy.nditer访问元素</p>
<pre><code class="language-python">import numpy as np
a = np.arange(6).reshape(2, 3)

for x in np.nditer(a):
    print (x, end=&quot;, &quot; )
</code></pre>
<p>！！！默认行序优先！！！</p>
<p>可以通过传入nditer的order参数改变遍历顺序 order = 'F'</p>
<p>可以改变可选参数op_flags获得权限修改值，默认为 <em>readonly</em> 可以改为 <em>readwrite</em> 。op_flags=['readwrite']</p>
<p>flags参数：可选参数，用于外部循环</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c_index</td>
<td style="text-align:left">C顺序索引</td>
</tr>
<tr>
<td style="text-align:center">f_index</td>
<td style="text-align:left">F顺序索引</td>
</tr>
<tr>
<td style="text-align:center">multi_index</td>
<td style="text-align:left">每次迭代可以跟踪一种索引类型</td>
</tr>
<tr>
<td style="text-align:center">external_loop</td>
<td style="text-align:left">给出的值是具有多个值的一维数组，而不是零维数组</td>
</tr>
</tbody>
</table>
<blockquote>
<p>NumPy的可选参数可以参考 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.nditer.html?highlight=multi_index">scipy.org</a></p>
</blockquote>
<h3>广播迭代</h3>
<p>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。假设数组 a 的维度为 3X4，数组 b 的维度为 1X4，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p>
<pre><code class="language-python">import numpy as np

a = np.arange(0,60,5)
a = a.reshape(3,4)
print  ('第一个数组为：')
print (a)
print  ('\n')
print ('第二个数组为：')
b = np.array([1, 2, 3, 4], dtype =  int)
print (b)
print ('\n')
print ('修改后的数组为：')
for x,y in np.nditer([a,b]):
    print (&quot;%d:%d&quot; % (x,y), end=&quot;, &quot; )

# 输出
# 第一个数组为：
# [[ 0  5 10 15]
#  [20 25 30 35]
#  [40 45 50 55]]


# 第二个数组为：
# [1 2 3 4]


# 修改后的数组为：
# 0:1, 5:2, 10:3, 15:4, 20:1, 25:2, 30:3, 35:4, 40:1, 45:2, 50:3, 55:4,
</code></pre>
<blockquote>
<p>上述例子来源于runoob</p>
</blockquote>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于我和物理]]></title>
        <id>https://ibert.me/posts/zh/关于我和物理.html</id>
        <link href="https://ibert.me/posts/zh/关于我和物理.html"/>
        <updated>2019-07-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>为什么会有这个菜单</h2>
<p>博主本专业是应用物理学，长期感兴趣的方向却是计算机和嵌入式开发相关，然后专业课有时候会挂，毕竟物理这一行比较艰辛。新开这个菜单是为了提醒自己仍然是物理专业的学生，也会在这个菜单里写一些自己的学习笔记，拿到电脑也会想起来去写一写笔记和思考。</p>
<!-- more -->
<h2>已经学了哪些课程</h2>
<p>应用物理学的课程很多，写这篇博文的时候已经是准大三了，物理方面自我感觉没有啥天赋，也不知道自己能干什么。</p>
<ul>
<li>物理基础课：力学、光学、电磁学、热学、理论力学、数学物理方法、原子物理学</li>
<li>理工公共课：工程制图B、概率论与数理统计B、C语言、大学计算机基础、高等数学A、线性代数A、电路分析基础A、模拟电子技术A、数字电子技术A、数值计算方法B</li>
<li>其他公共课</li>
</ul>
<h2>对物理专业的看法</h2>
<p>作为一个物理专业的学生，每次被别人得知专业的时候总会被说是个狠人。。物理是基于实验的，说真的在它的面前想必大多数人都是弟弟。学物理最大的问题对我来说就是没有获得感，因为我不知道要干些什么，或者说我不知道究竟有什么用。对很多人来说，物理是困难的，难在没有可视化实验的情况下的纯理论学习。物质来说，物理专业并没有工科专业容易找工作。</p>
<p>如果有想法学物理的话，首先请仔细了解这类专业。你喜欢和能学好是两回事！应用物理学学的不仅仅是物理的专业课，也会涉及到数学和工科的专业课。首先的数学就是基础，物理的公式推导会涉及到不定积分、偏微分方程和场论等等。同济版高等数学教材的后部分很多专业是根本不会要求的，但是在物理上都是基础课，后面涉及的数学物理方法会从复变函数开始然后到常用的数学方程和基础的模型。同时，数学物理方法也是电动力学和量子力学的基础。</p>
<p>学物理除了有恒心之外，还得有家庭的支持。本科物理类专业读完才是刚刚开始，本科所学的课程是基础课，确定研究方向是从研究生开始。不想再读物理专业可以选择跨考，跨考电子类、计算机类、金融类的人很多。物理专业得准备好充足的经济支持，可能因为攻读学位的问题毕业得花很长的时间并且经济收入困难。所以建议想读物理，一定要去一所名校并且做好准备，物理并不比医学要简单。</p>
<h2>对物理的期许</h2>
<p>希望物理这个学科能够好好发展，急功近利是做不了物理的。物理的科普和传承需要每个物理学生（不管学的多差）的支撑，工科是来源于物理的，如果物理得不到发展，工业也会停滞不前。物理学家里，除了敬重爱因斯坦、钱学森、邓稼先之外，我也很敬重杨振宁。国内对于杨振宁的评价太过于片面，而却忽视了他所做出的成就（可能是看不懂吧）。博主作为一个物理专业的本科学生，对于杨振宁所涉及的研究现在还根本没触及到，因为杨老的研究已经是最前沿了。有评论说杨老是继爱因斯坦之后最伟大的理论物理学家，博主觉得并不为过。</p>
<p>针对回国的问题，我并不觉得这个有什么好争论的。从事理论物理和工科相关是不一样的，理论物理的研究很大程度上依赖环境，杨老在近些年促进国内物理发展上已经做出了很多贡献了。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[EMQ试用Log]]></title>
        <id>https://ibert.me/posts/zh/EMQ试用Log.html</id>
        <link href="https://ibert.me/posts/zh/EMQ试用Log.html"/>
        <updated>2019-07-09T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>什么是EMQ</h2>
<p>EMQ是一款部署在服务端的物联网框架，支持主流的物联网协议。更多的介绍可以参考 <a href="https://www.emqx.io/cn/">EMQ官网</a> 的介绍。</p>
<!-- more -->
<h2>为什么要选择EMQ</h2>
<blockquote>
<p>各个框架的对比可以参考 <a href="https://github.com/mqtt/mqtt.github.io/wiki/server-support">GitHub的一篇比较全面的对比文章</a>，其中的emqttd就是这里的EMQ。</p>
</blockquote>
<p>EMQ国人开发的，因此在中文文档支持上会好很多，更容易去使用。EMQ提供了可视的数据监控台、大量的API和集成了一些插件，对于快速建立和部署服务端很友好。</p>
<h2>EMQ的安装</h2>
<p>作者用的是Win10的系统，在开发上来说个人不是很推荐，但是做硬件和软件客户端的测试和学习还是很不错的！EMQ也提供了Win10的版本！！</p>
<p>官方的简介和安装可以直接参考文档 <a href="https://developer.emqx.io/docs/broker/v3/cn/getstarted.html#">开始使用</a> 和 <a href="https://developer.emqx.io/docs/broker/v3/cn/install.html">程序安装</a></p>
<blockquote>
<p>Win10直接下载zip到非系统盘解压就完事了</p>
</blockquote>
<h2>程序的启动（Win10）</h2>
<ol>
<li>进入文件夹的bin下</li>
<li>打开Git Bash 或者 Windows PowerShell</li>
<li>./emqx.cmd start 启动服务</li>
<li>./emqx_ctl.cmd status 查看状态</li>
<li>./emqx.cmd stop 停止服务</li>
</ol>
<h2>在线监控</h2>
<blockquote>
<p>浏览器打开localhost:18083即可进入DashBoard页面，默认用户名是admin，密码是public</p>
</blockquote>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo基础搭建使用]]></title>
        <id>https://ibert.me/posts/zh/Hexo基础搭建使用.html</id>
        <link href="https://ibert.me/posts/zh/Hexo基础搭建使用.html"/>
        <updated>2019-07-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2>Hexo安装环境</h2>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> (<a href="https://github.com/creationix/nvm">nvm</a>)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<blockquote>
<p>推荐使用nvm，在实践之后发现nvm真的很好用，当然Windows用户可以直接下载安装</p>
</blockquote>
<pre><code class="language-shell"># 下载node.js
 nvm install stable
</code></pre>
<!-- more -->
<h2>安装Hexo</h2>
<blockquote>
<p>Linux和Mac用户直接使用下面的shell就完事了，Windows用户可以使用在相应文件夹下使用Window Powershell或者git bash然后shell，国内推荐用npm下载cnpm，代替npm来提高依赖的下载速度和稳定性！！（cnpm用的是淘宝的镜像）</p>
</blockquote>
<pre><code class="language-shell"># 下载cnpm
 npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<pre><code class="language-shell"># 安装Hexo
 cnpm install -g hexo-cli
</code></pre>
<h2>文章迁移插件的安装（没有需要的可以跳过）</h2>
<p>Hexo官方支持的迁移来源</p>
<ul>
<li><a href="https://hexo.io/zh-cn/docs/migration#RSS">RSS</a></li>
<li><a href="https://hexo.io/zh-cn/docs/migration#Jekyll">Jekyll</a></li>
<li><a href="https://hexo.io/zh-cn/docs/migration#Octopress">Octopress</a></li>
<li><a href="https://hexo.io/zh-cn/docs/migration#WordPress">WordPress</a></li>
<li><a href="https://hexo.io/zh-cn/docs/migration#Joomla">Joomla</a></li>
</ul>
<h2>初始化一个Hexo项目</h2>
<pre><code class="language-shell"># 初始化博客项目
 hexo init &lt;项目名称&gt;
 cd &lt;项目名称&gt;      # 打开项目文件夹

# 下载Hexo server
 cnpm install hexo-server --save

# 启动本地预览
 hexo server       # 默认http://localhost:4000
</code></pre>
<blockquote>
<p>关于更改预览设置的请参考 <a href="https://hexo.io/zh-cn/docs/server">Hexo Server</a></p>
</blockquote>
<h2>修改Hexo的主题</h2>
<p>这里以yilia为例（请保证网络环境）</p>
<pre><code class="language-git"># 确保在上面项目文件夹下
git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia
</code></pre>
<blockquote>
<p>themes/yilia 也就是下载到项目文件夹下的themes/yilia目录下</p>
</blockquote>
<p>进入themes/yilia下，修改_config.yml文件</p>
<pre><code class="language-shell"># Linux的进入修改
 cd themes/yilia
 nano _config.yml
</code></pre>
<blockquote>
<p>Windows建议使用vscode打开编辑</p>
</blockquote>
<pre><code class="language-yml"># 修改内容
themes: yilia        # (上面下载位置文件夹名)
</code></pre>
<h2>生成保存更改</h2>
<blockquote>
<p>Hexo每次修改或者添加等操作都需要重新生成文件，生成的文件在工程根目录的public文件夹下</p>
</blockquote>
<pre><code class="language-shell"># 清除之前的文件
 hexo clean

# 生成新的文件
 hexo generate
# 或者
 hexo g

# 预览文件
 hexo server
# 或者
 hexo start
# 或者
 hexo s

</code></pre>
<blockquote>
<p>在生成操作时可以使用--watch来比较文件的SHA1 checksum仅生成不同的文件</p>
</blockquote>
<pre><code class="language-shell"># 监视文件变动
 hexo generate --watch
</code></pre>
<p>一条命令也可以这样写</p>
<pre><code class="language-shell"># 清除保存预览
 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s
</code></pre>
<h2>Hexo的目录树</h2>
<p>目录树在此就不赘述了，请参考Hexo官方介绍 <a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a> 和 <a href="https://hexo.io/zh-cn/docs/data-files">数据文件夹</a></p>
<blockquote>
<p>作为仅markdown用户个人没有采取官方的引用方式而是使用了! [ ] ( )</p>
</blockquote>
<h2>Hexo新建文章</h2>
<p>Hexo的文章放置在根目录的/sources/_post下</p>
<pre><code class="language-shell"># 生成一篇md文章
 hexo new &lt;文章名&gt;
# 或者
 hexo n &lt;文件名&gt;
</code></pre>
<blockquote>
<p>相关关于写作的具体操作参考 <a href="https://hexo.io/zh-cn/docs/writing">写作</a></p>
</blockquote>
<h2>Hexo的部署</h2>
<p>作为一个Git用户表示也习惯了git的使用，本文采取Gitpage来演示（其他参考 <a href="https://hexo.io/zh-cn/docs/deployment">官方教程</a>）</p>
<h3>首先得下载依赖（根目录下）</h3>
<pre><code class="language-shell"># 下载hexo-deployer-git
 cnpm install hexo-deployer-git --save
</code></pre>
<h3>修改配置文件</h3>
<p>修改根目录下的_config.yml</p>
<pre><code class="language-yml">deploy:
    type: git
    repo: &lt;Gitpage仓库地址&gt;
    branch: master            # 默认的分支就是master
</code></pre>
<h3>重新生成更新文件（同上）</h3>
<h3>发到部署仓库</h3>
<pre><code class="language-shell"># 部署命令
 hexo deploy
# 这里采取非监视的一条shell
 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d
</code></pre>
<blockquote>
<p>私有库要求输入用户名和密码，首次安装git请参考git的设置</p>
</blockquote>
<h2>私人云服务器Git仓库的搭建、nginx配置及部署</h2>
<h3>云Git仓库的建立</h3>
<pre><code class="language-shell"># 设置新的用户
 useradd git           # 添加git用户
 passwd git            # 设置git密码

# 修改权限文件
 chown 740 /etc/sudoers
 nano /etc/sudoers

# 添加内容
# 找到 root ALL=(ALL:ALL) ALL
# 下面添加
git ALL=(ALL:ALL) ALL

# 保存退出
# 修改权限
 chown 440 /etc/sudoers

# 关闭git用户shell权限
 nano /etc/passwd

# 将git:x:1001:1001:,,,:/home/git:/bin/bash改为
git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre>
<p>在网上教程中会要求su git切换用户！！这里有一个坑，会报错的！！因为上面禁掉了git的shell权限！！可以不切换的</p>
<pre><code class="language-shell"># 创建git目录
 cd /home/git                # 没有的进入home然后mkdir git
 mkdir blog.git              # 这里以blog.git为例建立git仓库
 git init --bare             # 创建空仓库

# 创建网站目录
 cd /var/www
 mkdir blog                  # 这里/var/www/blog作为网站源码的存放位置
</code></pre>
<p>网上教程在这里证书配置ssh免密码认证，个人没有采用这种方式（老老实实输密码）</p>
<p>用户组的管理</p>
<pre><code class="language-shell"> ll /home/git/
 ll /var/www/
# 确保blog.git、blog目录的用户组权限为git:git
</code></pre>
<blockquote>
<p>如果不是</p>
</blockquote>
<pre><code class="language-shell"># 执行
 chown git:git -R /var/www/blog
 chown git:git -R /home/git/blog.git
</code></pre>
<h3>配置nginx</h3>
<p>这里就不赘述nginx的参数意义和配置了，仅仅修改源码放置的配置！！！</p>
<pre><code class="language-nginx"># 进入/etc/nginx/sites-available下
 nano default

# 修改配置文件的location下的root
# 举个例子

root /var/www/blog;
</code></pre>
<p>保存退出！然后重新加载nginx</p>
<pre><code class="language-shell"># 重新加载nginx
 service nginx reload
</code></pre>
<h3>配置Git Hooks</h3>
<pre><code class="language-shell"># 创建post-receive文件并添加内容
 cd /home/git/blog.git/hooks           # 切换目录

 nano post-receive
</code></pre>
<p>添加内容</p>
<pre><code class="language-post-receive">#!/bin/bash
GIT_REPO=/home/git/blog.git
TMP_GIT_CLONE=/tmp/blog
PUBLIC_WWW=/var/www/blog
rm -rf ${TMP_GIT_CLONE}
git clone $GIT_REPO $TMP_GIT_CLONE
rm -rf ${PUBLIC_WWW}/*
cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}
</code></pre>
<blockquote>
<p>上面内容可以按需要修改</p>
</blockquote>
<p>保存退出之后，chmod +x post-receive赋予可执行权限</p>
<h3>配置本地工程部署</h3>
<p>上面是基于Gitpage配置的Hexo，在此只需要修改_config.yml的deploy下的repo</p>
<pre><code class="language-yml">repo: git@你的服务器IP:blog.git               # git访问对应服务器的blog.git仓库
</code></pre>
<p>然后就是上面的部署操作就完成了！！</p>
<h2>yilia主题下文章预览设置more的操作</h2>
<pre><code class="language-md">&lt;!-- 在你要中断文章结尾的位置添加下面的内容 --&gt;

&lt;!-- more --&gt;
</code></pre>
<h2>参考文档</h2>
<ul>
<li><a href="https://hexo.io/zh-cn/docs/">官网文档</a></li>
<li><a href="https://www.jianshu.com/p/b926ecf1c6f6">简书博文</a></li>
</ul>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dart之旅]]></title>
        <id>https://ibert.me/posts/zh/Dart之旅.html</id>
        <link href="https://ibert.me/posts/zh/Dart之旅.html"/>
        <updated>2018-12-02T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文于2020/1/27修订</p>
</blockquote>
<h2>写在前面</h2>
<blockquote>
<p>本文是参考了<a href="https://www.dartlang.org">Dart官网</a> 的教程、参考的机翻以及对于其他语言学习的经验来翻译的本入门教程，译者精力和学历有限，如有不妥之处欢迎指正。</p>
</blockquote>
<blockquote>
<p>本文出于知识共享的目的，转载请注明出处，如果用于商用请联系 <a href="mailto:admin@jieec.cn">admin@jieec.cn</a></p>
</blockquote>
<h2>在线编译</h2>
<blockquote>
<p><a href="https://dartpad.dartlang.org/">DartPad</a></p>
</blockquote>
<!-- more -->
<h2>概念</h2>
<ul>
<li>Dart变量中的内容都是对象，对象都是类的实例，所有对象都是从Object类继承的</li>
<li>Dart要求规定类型，但是可以自行推断类型。var num = 10; 就可以推断其类型为int（<strong>不需要类型之dynamic</strong>）</li>
<li>Dart之泛型类型List &lt;int&gt; (<em>整数列表</em>)or List &lt;dynamic&gt;（<em>任何类型的对象列表</em>）</li>
<li>主函数main(),支持自定义函数和函数嵌套</li>
<li>支持全局变量，私有变量。实例的变量可以称为字段或者属性</li>
<li>不具备数据保护相关的关键字，用（_)开头确定私有</li>
<li>标识符可以以字母或者（_）下划线开头，后面字母和数字任意组合</li>
</ul>
<h2>关键字</h2>
<table>
<thead>
<tr>
<th style="text-align:center">关键字列表</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">abstract 2</td>
<td style="text-align:center">dynamic 2</td>
<td style="text-align:center">implements 2</td>
<td style="text-align:center">show 1</td>
</tr>
<tr>
<td style="text-align:center">as 2</td>
<td style="text-align:center">else</td>
<td style="text-align:center">import 2</td>
<td style="text-align:center">static 2</td>
</tr>
<tr>
<td style="text-align:center">assert</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">in</td>
<td style="text-align:center">super</td>
</tr>
<tr>
<td style="text-align:center">async 1</td>
<td style="text-align:center">export 2</td>
<td style="text-align:center">interface 2</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">await 3</td>
<td style="text-align:center">external 2</td>
<td style="text-align:center">is</td>
<td style="text-align:center">sync 1</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">library 2</td>
<td style="text-align:center">this</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">factory 2</td>
<td style="text-align:center">mixin 2</td>
<td style="text-align:center">throw</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">false</td>
<td style="text-align:center">new</td>
<td style="text-align:center">true</td>
</tr>
<tr>
<td style="text-align:center">class</td>
<td style="text-align:center">final</td>
<td style="text-align:center">null</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">on 1</td>
<td style="text-align:center">typedef 2</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">operator 2</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">covariant 2</td>
<td style="text-align:center">Function 2</td>
<td style="text-align:center">part 2</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">get 2</td>
<td style="text-align:center">rethrow</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">deferred 2</td>
<td style="text-align:center">hide 1</td>
<td style="text-align:center">return</td>
<td style="text-align:center">with</td>
</tr>
<tr>
<td style="text-align:center">do</td>
<td style="text-align:center">if</td>
<td style="text-align:center">set 2</td>
<td style="text-align:center">yield 3</td>
</tr>
</tbody>
</table>
<p>避免使用关键字作为标识符，如果有必要标数字的关键字可以作为标识符：</p>
<ol>
<li>上下文关键字标识符，仅在特定位置有含义</li>
<li>内置标识符，简化js转移dart的工作，不能作为类或者类型的标识符，不能用作导入前缀</li>
<li>dart 1.0发布后添加的异步支持相关的更新，有限的保留字。不能使用await or yield作为任何函数体中的标识符标记async,async* or sync*</li>
</ol>
<h2>变量</h2>
<h3>* var（属于Object）&amp; dynamic的辨析</h3>
<ul>
<li>var可以被解析为任意类型，但是一旦确定就不可更改！</li>
<li>dynamic的值不可以被编译器解析或者类型检查</li>
<li>dynamic编译到Object中，dynamic编译时存在，运行时不存在</li>
</ul>
<h3>默认值</h3>
<p>未初始化的默认值都为null，断言<em>assert(condition);</em></p>
<h3>final &amp; const</h3>
<p>不打算更改变量的值用final或者const定义变量。final变量只能被设置一次；const变量是编译时常量（const变量是隐式final的）。final的全局变量和类变量第一次使用的时候要被初始化。</p>
<blockquote>
<p>注意：在实例变量中只可以用final而非const。必须在构造函数体之前初始化final变量（在变量声明，构造函数参数或者构造函数的初始化列表中。）</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-dart">  final name = 'Bob';//无法再更改值
</code></pre>
<p>如果const变量在类内，请标记为static const,const属于Object类</p>
<pre><code class="language-dart">  const bar = 1000000;//压力单位(dynes/cm2)
  const double atm = 1.01325*bar;//标准大气压
</code></pre>
<p>const不仅仅可以声明常变量，也可以用来创建常量值constant values，以及声明常量值的构造函数，任何变量都可以具有常量值。</p>
<pre><code class="language-dart">  var foo = const [];
  final bar = const [];
  const baz = [];//与&quot;const []&quot;等价
</code></pre>
<ul>
<li>可以省略声明const的初始化表达式，如上所示。不要冗余使用const！</li>
<li>你可以修改非final，非const变量的值，即使变量曾用过const的值</li>
</ul>
<pre><code class="language-dart">  foo = [1,2,3];√
  baz = [1,2,3];×
</code></pre>
<h2>内置类型</h2>
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔型</li>
<li>列表（数组）</li>
<li>地图map</li>
<li>符文runes（用于在字符串中表示Unicode字符）</li>
<li>符号symbols</li>
</ul>
<blockquote>
<p>因为Dart中的每个变量都引用一个对象 - 一个类的实例 - 您通常可以使用构造函数来初始化变量。一些内置类型有自己的构造函数。例如，您可以使用Map()构造函数来创建地图。 ——来源于官网引用</p>
</blockquote>
<h3>数字</h3>
<ul>
<li>
<p>int</p>
<blockquote>
<p>整数值不大于64位，具体视平台而定</p>
</blockquote>
</li>
<li>
<p>double</p>
<p><em>64位双精度浮点数，IEEE 754标准</em></p>
<blockquote>
<p>int &amp; double都属于数字这一类型，数字基本运算符有+、-、*、/之类的，也包括abs()、ceil()、floor()和其他方法。（类似于&quot;&gt;&gt;&quot;的位运算符，在int类中被定义），如果在num及其子类中没有要找的，去dart:math库中看看！</p>
</blockquote>
</li>
</ul>
<p>int示例</p>
<pre><code class="language-dart">  int x = 1;
  int hex = 0xDEADBEEF;
</code></pre>
<p>double示例</p>
<pre><code class="language-dart">  double y = 1.1;
  double exponents = 1.42e5;
</code></pre>
<p>以下是字符串如何转化为数字，反之亦然</p>
<pre><code class="language-dart">  // String -&gt; int
  var one = int.parse('1');
  assert(one == 1);

  // String -&gt; double
  var onePointOne = double.parse('1.1');
  assert(onePointOne == 1.1);

  // int -&gt; String
  String oneAsString = 1.toString();
  assert(oneAsString == '1');

  // double -&gt; String
  String piAsString = 3.14159.toStringAsFixed(2);
  assert(piAsString == '3.14');

</code></pre>
<p>int类型指定移位操作（&lt;&lt;、&gt;&gt;）,AND（&amp;）和OR（|）运算符。</p>
<pre><code class="language-dart">  assert((3&lt;&lt;1)==6);// 0011 &lt;&lt; 1 == 0110
  assert((3&gt;&gt;1)==1);// 0011 &gt;&gt; 1 == 0001
  assert((3|4)==7);// 0011 | 0100 == 0111
</code></pre>
<blockquote>
<p>Literal numbers（能力有限，不知道如何翻译）是编译时常量，很多的算术表达式也是编译时的常量，只要它们的操作数是编译为数字的编译时常量——引用自dart官网</p>
</blockquote>
<pre><code class="language-dart">  const msPerSecond = 1000;
  const secondsUntilRetry = 5;
  const msUntilRetry = secondsUntilRetry*msPerSecond;
</code></pre>
<h3>字符串</h3>
<p>Dart字符串是一系列的UTF-16代码单元，可以使用 '' or &quot;&quot; 创建字符串。</p>
<p>示例</p>
<pre><code class="language-dart">  var s1 = 'Single quotes work well for string literals.';
  var s2 = &quot;Double quotes work just as well.&quot;;
  var s3 = 'It\'s easy to escape the string delimiter.'; // 译者注\'是转译输出'
  var s4 = &quot;It's even easier to use the other delimiter.&quot;;
</code></pre>
<p>你可以将表达式的值置入字符串中通过使用${expression}。如果表达式是标识符，你可以跳过{}（就是省略{}）。要获取会对象对应的字符串，Dart会调用对象的toString()方法。</p>
<pre><code class="language-dart">  var s = 'string interpolation';

  assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' + 'which is very handy.');
  assert('That deserves all caps. ' + '${s.toUpperCase()} is very handy!' == 'That deserves all caps. ' + 'STRING INTERPOLATION is very handy!');

</code></pre>
<blockquote>
<p>&quot;==&quot;运算符是测试两个对象是否是等价的，如果它们包含相同的代码单元序列，那么就是等价的。</p>
</blockquote>
<p>你可以使用运算符'+'连接字符串（译者省略了演示代码）</p>
<p>另一种创建多行字符串的方法是：使用三个单引号或者双引号</p>
<pre><code class="language-dart">  var s1 = '''
  多行字符串1
  ''';

  var s2 = &quot;&quot;&quot;
  多行字符串2
  &quot;&quot;&quot;;

</code></pre>
<p>你可以通过添加前缀r来创建原始字符串（在原始字符串中，字符串是不会被特殊处理的）</p>
<pre><code class="language-dart">  var s = r'这是一个原始字符串';
</code></pre>
<p>有关如何在字符串中表示Unicode字符的详细信息，请参阅<em>Runes</em>。</p>
<p>只要任何插值表达式是一个编译时常量，其值为null或数值，字符串或布尔值；文字字符串即为编译时常量。</p>
<p>演示代码</p>
<pre><code class="language-dart">  // 常字符串
  const aConstNum = 0;
  const aConstBool = true;
  const aConstString = 'a constant string';

  // 并非常字符串
  var aNum = 0;
  var aBool = true;
  var aString = 'a string';

  const aConstList = [1, 2, 3];
  const validConstString = '$aConstNum $aConstBool $aConstString';
  // const invalidConstString = '$aNum $aBool $aString $aConstList';
</code></pre>
<p>获取更多的字符串的使用信息，请参考<em>字符串与正则表达式</em></p>
<h3>布尔型</h3>
<p>Dart用bool类表示布尔值，只有两个对象true、false，它们都是编译时常量。</p>
<p>Dart的类型安全意味着你不能使用类似于if(非布尔值)或者assert(非布尔值)的语句，不过可以明确地检查值，如示例：</p>
<pre><code class="language-dart">  // 检查空字符串
  var fullName = '';
  assert(fullName.isEmpty);

  // 检查零
  var hitPoints = 0;
  assert(hitPoints &lt;= 0);

  // 检查null
  var unicorn;
  assert(unicorn == null);

  // 检查NaN
  var iMeantToDoThis = 0 / 0;
  assert(iMeantToDoThis.isNaN);

</code></pre>
<h3>列表</h3>
<p>几乎每种语言中最常见的是数组或者有序对象组。在Dart中数组是List对象，因此大多人也称为列表。</p>
<p>Dart列表看起来想JavaScript数组。示例：</p>
<pre><code class="language-dart">  var list = [1,2,3];
</code></pre>
<blockquote>
<p>分析器推断list类型为list&lt;int&gt;。如果将非int类型对象加入此列表，会引发错误。获取更多的信息，阅读有关 <em>类型推断</em>。</p>
</blockquote>
<p>列表从零开始索引，0是列表的第一个元素索引，list.length - 1是列表的最后一个元素索引。可以像JavaScript那样获取一个列表的长度并引用元素。</p>
<pre><code class="language-dart">  var list = [1,2,3];
  assert(list.length == 3);
  assert(list[1] == 2);

  list[1] == 1;
  assert(list[1] == 1);
</code></pre>
<p>创建一个编译时常量列表，在列表文字前添加const：</p>
<pre><code class="language-dart">  var constantList = const [1,2,3]
  // 同样，值不可以更改
</code></pre>
<p>List类型有很多方便的方法来操作列表。有关更多信息，请参阅 <em>泛型Generics</em> 和 <em>集合Collections</em> 。</p>
<h3>地图型Maps</h3>
<p><strong>译者注：根据译者对于其他语言的学习和开发经验，Dart语言的Maps型和Python中的字典是一样的，其中键就是key，值就是value。</strong></p>
<p>通常，map型是一个有键值对构成的对象。键和值可以是任意类型的对象。键不能重复，而同样的值是可以的。Dart对于map的支持是通过地图文字和Map类型。</p>
<p>以下是一些简单使用map文字创建的Dart maps：</p>
<pre><code class="language-dart">  var gifts = {
    // key:value
    'first': 'partridge',
    'second': 'turtledoves',
    'fifth': 'golden rings',
  };

  var nobleGases = {
    2: 'helium',
    10: 'neon',
    18: 'argon',
  };
</code></pre>
<blockquote>
<p>解析推断gifts类型为Map&lt;String,String&gt;，nobleGases的类型为Map&lt;int,String&gt;。如果尝试去添加非对应类型的值，解析器或者运行的时候会报错。获取更多的信息，请参阅 <em>类型推断</em> 。</p>
</blockquote>
<p>你也可以使用构造函数Map()创建相同的对象：</p>
<pre><code class="language-dart">  var gifts = Map();
  gifts['first'] = 'partridge';
  gifts['second'] = 'turtledoves';

  // 不想写了，省略···
</code></pre>
<blockquote>
<p>你可能想看到的是new Map()，而非Map()。从Dart 2开始，new关键字是可选的。有关详细信息，请参阅 <em>使用构造函数</em> 。</p>
</blockquote>
<p>跟在JavaScript中一样，将新的键值对加到现有的地图中（<strong>译者注：在python的字典中其实也是这样的···</strong>）</p>
<pre><code class="language-dart">  var gifts = {'first': 'partridge'};
  gifts['fourth'] = 'calling birds';
</code></pre>
<p>跟在JavaScript中一样的方式在地图中检索值，不在就返回null：（<strong>译者注：译者懒得注了</strong>）</p>
<pre><code class="language-dart">  var gifts = {'first': 'partridge'};
  assert(gifts['first'] == 'partridge');
  assert(gifts['fifth'] == null);
</code></pre>
<p>使用.length获取map中键值对的数目</p>
<pre><code class="language-dart">  var gifts = {'first': 'partridge'};
  gifts['fourth'] = 'calling birds';
  assert(gifts.length == 2);
</code></pre>
<p>常地图，定义与上面相似，不写了···</p>
<pre><code class="language-dart">  final constantMap = const {
    2: 'helium',
    10: 'neon',
    18: 'argon',
  };
  // const改都报错，后面就不写了
</code></pre>
<p>获取更多的信息，请参阅 <em>泛型Generics</em> 和 <em>地图型Maps</em></p>
<h3>符文</h3>
<p>在Dart中，符文是字符串中UTF-32代码点</p>
<p>Unicode为世界上所有书写系统中的每一个字母、数字、符号都定义了唯一的数值。由于Dart字符串是一系列的UTF-16代码单元，因此在字符串中表示32位要用特殊的语法。</p>
<p>表达Unicode代码点的常用的方法是\uXXXX，其中XXXX是4位十六进制值。例如心（💗）是\u2665。要指定多于或者少于4个十六进制值，请将值放在大括号里。例如，笑脸（😆）是\u{1f600}。</p>
<p>该字符串类有几个属性，你可以用它来提取符文信息。codeUnitAt和codeUnit属性返回16位编码单元。使用该runes属性获取字符串的符文。</p>
<p>以下示例说明了符文，16位代码单元和32位代码点之间的关系。</p>
<pre><code class="language-dart">  main()
  {
    var clapping = '\u{1f44f}';
    print(clapping);
    print(clapping.codeUnits);
    print(clapping.runes.toList());

    Runes input = new Runes(
      '\u2665  \u{1f605}  \u{1f60e}  \u{1f47b}  \u{1f596}  \u{1f44d}');
    print(new String.fromCharCodes(input));
  }
</code></pre>
<blockquote>
<p>注意：使用列表操作符文要小心，这种方法容易分解，具体取决于特定的语言，字符集和操作。更多信息，请在Stack Overflow上参阅 <em>如何在Dart中反转字符串？</em> ——引用自dart官网</p>
</blockquote>
<h3>符号Symbols</h3>
<p>符号对象表示Dart程序的操作或者声明。你可能不会去使用符号对象，但是它们对于API通过名称引用是非常有用的，因为缩小会更改标识符名称而不会更改标识符符号。（<strong>译者并不清楚官网这句话的具体含义，引用自Dart官网</strong>）</p>
<p>请使用符号文字获取标识符的符号（#后面跟着标识符）：</p>
<pre><code class="language-dart">  #radix
  #bar
</code></pre>
<p>符号文字是编译时常量！</p>
<h2>函数Function</h2>
<p>Dart是一门面向对象的语言，即便是函数也是对象，并且具有类型 <em>Function</em> 。这意味着函数可以被赋值给变量，或者作为参数传递给其他函数。你也可以跟调用函数一样，调用Dart类的实例。有关信息请参阅 <em>可调用类Callable classes</em> 。</p>
<p>以下是一个实现函数的示例：</p>
<pre><code class="language-dart">  bool isNoble(int atomicNumber){
    return _nobleGases[atomicNumber] != null;
  }
</code></pre>
<p>虽然Effective Dart建议 <em><strong>为公共API键入注释</strong></em> ，但是省略类型，函数还是有效的</p>
<pre><code class="language-dart">  isNoble(atomicNumber){
    return _nobleGases[atomicNumber] != null;
  }
</code></pre>
<p>对于只含有一个表达式的函数，可以使用简写的语法：</p>
<pre><code class="language-dart">  bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;
</code></pre>
<p>该语法是速记，有时候称为 <em>箭头语法</em> 。=&gt; expr {return expr;}</p>
<blockquote>
<p>只有 <em>表达式</em> 而非 <em>语句</em> 可以出现在 &quot;=&gt;&quot; 和 &quot;;&quot; 之间。例如，不能在其中放入if语句，但可以使用条件表达式。 <strong>（译者注：也就是类似于其他语言也有的条件判断表达式比如 ? : 和 if语句的区别）</strong></p>
</blockquote>
<p>函数可以有两种类型的参数：必需和可选。首先列出所需的参数，然后列出任何可选参数。命名的可选参数也可以标记为 <em>@required</em> 。有关详细信息，参阅下一节。</p>
<h3>可选参数</h3>
<p>可选参数可以是位置参数，也可以是命名参数，不局限于这些。</p>
<h4>可选命名参数</h4>
<p>调用函数的时候，可以使用 <em>paramName: value</em> 指定的命名参数。例如：</p>
<pre><code class="language-dart">  enableFlags(bold: true, hidden: false);
</code></pre>
<p>定义函数时，使用 <em>{param1, param2, ...}</em> 指定命名参数：</p>
<pre><code class="language-dart">  // 设置[bold]和[hidden]标志flags...
  void enableFlags({bool bold, bool hidden}){...}
</code></pre>
<p><strong>Flutter</strong> 实例创建表达式变得会更复杂，因此窗口小部件构造函数仅使用命名参数，使实例创建表达式更易于阅读。</p>
<p>可以使用 <em>@required</em> 在任何Dart代码（不仅仅是Flutter）中注释命名参数，以指示它是 <em>必需参数</em> 。例如：</p>
<pre><code class="language-dart">  const Scrollbar({Key key, @required Widget child})
</code></pre>
<p>当一个构造Scrollbar，分析器会报错child不存在。</p>
<p><em>必需Required</em> 在 <em>元meta</em> 包中被定义。可以直接导入 <strong>package:meta/meta.dart</strong> ，也可以导入另一个导出的包 <strong>meta</strong>，例如Flutter的包 <strong>package:flutter/material.dart</strong> 。</p>
<h4>可选位置参数</h4>
<p>包装一组函数参数在[]内标记它们作为可选位置参数：</p>
<pre><code class="language-dart">  String say(String from, String msg, [String device]){
    var result = '$from says $msg';
    if (device != null){
      result = '$result with a $device';
    }
    return result;
  }
</code></pre>
<p>下面是一个没有可选参数情况下调用此函数的示例：</p>
<pre><code class="language-dart">  assert(say('Bob', 'Howdy') == 'Bob says Howdy');
</code></pre>
<p>下面是一个带有第三个参数情况下调用此函数的示例：</p>
<pre><code class="language-dart">  assert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');
</code></pre>
<h4>默认参数值</h4>
<p>你的函数可以使用 &quot;=&quot; 给命名或者位置参数定义默认值。默认值必须是编译时常量。如果未设默认值，则默认值为null。</p>
<p>这是一个为命名参数设置默认值的示例：</p>
<pre><code class="language-dart">  // 设置[bold]和[hidden]flag
  void enableFlags({bool bold = false,bool hidden = false}) {...}

  // bold值为true hidden为false
  enableFlags(bold: true);

</code></pre>
<blockquote>
<p>在老代码中使用冒号取代等号设置命名参数，原因是原生的问题。只有冒号支持命名参数。这种支持遭到了反对，建议使用等号设置默认值。</p>
</blockquote>
<p>这个示例演示了如何去给位置参数设置默认值</p>
<pre><code class="language-dart">  String say(String from, String msg, [String device = 'carrier pigeon', String mood]){
    var result = '$from says $msg';
    if (device != null){
      result = '$result with a $device';
    }
    if (mood != null){
      result = '$result (in a $mood mood)';
    }
    return result;
  }

  assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');
</code></pre>
<p>你也可以将列表或者地图作为默认值传递。下面的示例定义了一个doStuff()的函数，为list参数指定了一个默认的列表，为gifts参数指定了一个默认的地图。</p>
<pre><code class="language-dart">  void doStuff(
  {List&lt;int&gt; list = const [1, 2, 3],
    Map&lt;String, String&gt; gifts = const {
      'first': 'paper',
      'second': 'cotton',
      'third': 'leather'
    }
  }){
    print('list: $list');
    print('gifts: $gifts');
  }
</code></pre>
<h3>main()函数</h3>
<p>每一个app都必须有个顶级函数main()，相当于是app的入口。main()函数返回void并且有一个可选的List&lt;String&gt;参数。</p>
<p>这是一个web app的main()函数示例：</p>
<pre><code class="language-dart">  void main(){
    querySeletor('#sample_text_id')
      ..text = 'Click me!'
      ..onClick.listen(reverseText);
  }
</code></pre>
<blockquote>
<p>..这个先于代码的语法称为 <strong>级联</strong> 。使用级联，你可以对单个对象的成员执行多个操作。</p>
</blockquote>
<p>下面是一个带参数的main函数()的命令行app示例：</p>
<pre><code class="language-dart">  // 像这样运行app：dart args.dart 1 test
  void main(List&lt;String&gt; arguments){
    print(arguments);

    assert(arguments.length == 2);
    assert(int.parse(arguments[0]) == 1);
    assert(arguments[1] == 'test');
  }
</code></pre>
<p>你可以使用 <em>args库</em> 去定义和分析命令行参数。</p>
<h3>函数作为第一类对象</h3>
<p>你可以将一个函数作为参数传递给其他函数。比如：</p>
<pre><code class="language-dart">  void printElement(int element){
    print(element);
  }

  var list = [1, 2, 3];

  // printElement作为参数传递
  list.forEach(printElement);
</code></pre>
<p>你也可以将函数分配给一个变量。比如：</p>
<pre><code class="language-dart">  var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
  assert(loudify('hello') == '!!! HELLO !!!');
</code></pre>
<p>这个例子使用了一个匿名函数。想了解更多，请看下节教程。</p>
<h3>匿名函数</h3>
<p>大多的函数都是被命名过的，比如main()或者printElement()。你也可以创建一个无名函数叫做 <em>匿名函数</em> ，有时候也叫做 <em>lambda</em> 或者 <em>closure</em> 。比如你可以给一个变量指定一个匿名函数，以便你可以从一个集合中添加或者删除。</p>
<p>匿名函数和一个命名函数看起来很相似——没有或者数个参数，在逗号和括号之间用逗号和可选类型注释分隔。</p>
<p>下面的代码块包含了函数的主体</p>
<pre><code class="language-dart">  ([Type] param1[, ...]){
    codeBlock;
  };
</code></pre>
<p>下面的例子中定义了一个带有未指定类型参数 <em>item</em> 的匿名函数。为列表中的每个项调用的函数将打印一个字符串，该字符串包含指定索引处的值。</p>
<pre><code class="language-dart">  var list = ['apples', 'bananas', 'oranges'];
  list.forEach((item){
    print('${list.indexOf(item)}: $item');
    });
</code></pre>
<blockquote>
<p>写入程序的输出结果为：</p>
</blockquote>
<ol>
<li>0: apples</li>
<li>1: bananas</li>
<li>2: oranges</li>
</ol>
<p>如果函数只包含了一个语句，你可以使用箭头表示法让代码更短。复制下面的代码到DartPad，然后点击run证明它在功能上是等价的。</p>
<pre><code class="language-dart">  list.forEach(
    (item) =&gt; print('${list.indexOf(item): $item}')
    );
</code></pre>
<h3>词汇作用域Lexical scope</h3>
<p>Dart是一个有词汇作用域的语言，就意味着变量的作用域是静态定义的，只需通过代码的布局。你可以 <em>“顺着花冠向外”</em> （<strong>译者觉得这可能是一个比喻</strong>）去看变量是否在作用域范围内。</p>
<p>以下是在每个范围级别具有变量的嵌套函数的示例：</p>
<pre><code class="language-dart">  bool topLevel = true;

  void main() {
    var insideMain = true;

    void myFunction() {
      var insideFunction = true;

      void nestedFunction() {
        var insideNestedFunction = true;

        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
  }
</code></pre>
<p>注意 nestedFunction()是如何使用每一级的变量，一直到顶级。</p>
<h3>词汇闭包Lexical closures</h3>
<p><em>闭包closure</em> 是一个在它的词汇范围有权访问变量的函数对象，即使函数原来的范围之外。</p>
<p>函数关闭在周围定义的变量。在下面的示例中，makeAdder()捕获变量addBy。无论返回的函数在哪里，它都会记住addBy。</p>
<pre><code class="language-dart">  // 返回一个函数，它为函数的参数添加[addBy]
  Function makeAdder(num addBy){
    return (num i) =&gt; addBy + i;
  }

  void main(){
    // 创造一个函数添加2
    var add2 = makeAdder(2);

    // 创造一个函数添加4
    var add4 = makeAdder(4);

    assert(add2(3) == 5);
    assert(add4(3) == 7);
  }

</code></pre>
<h3>测试函数是否等价</h3>
<p>下面是一个测试顶级函数，静态方法，实例方法等价性的例子：</p>
<pre><code class="language-dart">  void foo() {} // 顶级函数
  class A {
    static void bar() {} // 静态方法
    void baz() {} // 实例方法
  }

  void main() {
    var x;

    // 比较顶级函数
    x = foo;
    assert(foo == x);

    // 比较静态方法
    x = A.bar;
    assert(A.bar == x);

    // 比较实例方法
    var v = A(); // A的实例#1
    var w = A(); // A的实例#2
    var y = w;
    x = w.baz;

    // 这些闭合参照的是一个实例（#2），所以它们是等价的
    assert(y.baz == x);

    // 这些闭合参照的是不同的实例，所以它们不等价
    assert(v.baz != w.baz);
  }
</code></pre>
<h3>返回值</h3>
<p>所有的函数都会返回值。如果没有返回值被指定，表达式返回null；隐式添加到函数体。</p>
<pre><code class="language-dart">  foo() {}
  assert(foo() == null);
</code></pre>
<h2>运算符</h2>
<p>Dart定义了下述表格中的运算符。你可重载部分的运算符，在 <em>重载运算符</em> 中具体介绍。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>一元后缀</td>
<td style="text-align:center">expr++ expr-- () [] . ?.</td>
</tr>
<tr>
<td>一元前缀</td>
<td style="text-align:center">-expr !expr ~expr ++expr --expr</td>
</tr>
<tr>
<td>乘式</td>
<td style="text-align:center">* / % ~/</td>
</tr>
<tr>
<td>和式</td>
<td style="text-align:center">+ -</td>
</tr>
<tr>
<td>移位</td>
<td style="text-align:center">&lt;&lt; &gt;&gt;</td>
</tr>
<tr>
<td>位与</td>
<td style="text-align:center">&amp;</td>
</tr>
<tr>
<td>位异或</td>
<td style="text-align:center">^</td>
</tr>
<tr>
<td>位或</td>
<td style="text-align:center">丨</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><strong>译者注：由于markdown的制表和位或运算的符号发生冲突，故使用的是丨（gun）代替</strong></td>
</tr>
<tr>
<td>关系与类型测试</td>
<td style="text-align:center">&gt;= &gt; &lt;= as is is!</td>
</tr>
<tr>
<td>等价</td>
<td style="text-align:center">== !=</td>
</tr>
<tr>
<td>逻辑与</td>
<td style="text-align:center">&amp;&amp;</td>
</tr>
<tr>
<td>逻辑或</td>
<td style="text-align:center">丨丨</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"><strong>译者注：同上</strong></td>
</tr>
<tr>
<td>如果null</td>
<td style="text-align:center">??</td>
</tr>
<tr>
<td>控制表达式</td>
<td style="text-align:center">expr1 ? expr2 : expr3</td>
</tr>
<tr>
<td>级联</td>
<td style="text-align:center">..</td>
</tr>
<tr>
<td>赋值</td>
<td style="text-align:center">= *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= 丨= ??=</td>
</tr>
</tbody>
</table>
<p>使用运算符可以创建表达式，下面是几个例子：</p>
<pre><code class="language-dart">  a++
  a + b
  a = b
  a == b
  c ? a : b
  a is T
</code></pre>
<p>在 <em>运算符表</em> 中，每个运算符的优先级都高于后一行的优先级。例如 % 高于 == ，而 == 高于 &amp;&amp; 。就意味着下面两行的代码执行方式是相同的。</p>
<pre><code class="language-dart">  // 圆括号提高了可读性
  if ((n % i == 0) &amp;&amp; (d % i == 0)) ...

  // 难读，但是是等价的
  if (n % i == 0 &amp;&amp; d % i == 0)
</code></pre>
<blockquote>
<p>注意：对于处理两个操作数的运算符，最左边的操作数确定运算符。——引用自官网</p>
</blockquote>
<h3>算术运算符</h3>
<p>Dart支持通用的算术运算符，具体如下表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td>-expr</td>
<td style="text-align:center">一元减号，也表示否定（反转表达式符号）</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">除</td>
</tr>
<tr>
<td>~/</td>
<td style="text-align:center">除，返回整数结果</td>
</tr>
<tr>
<td>%</td>
<td style="text-align:center">取余</td>
</tr>
</tbody>
</table>
<pre><code class="language-dart">  // ** 译者在此省略了部分演示代码**
  assert(5 / 2 == 2.5);
  assert(5 ~/ 2 == 2);
  assert(5 % 2 == 1);

  assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');
</code></pre>
<p>Dart也支持带前缀和后缀的自加或自减运算 （<strong>具体的优先级及取值参照其他语言的基础</strong>）</p>
<h3>等价与关系运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td style="text-align:center">等于；看下面讨论</td>
</tr>
<tr>
<td>!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td>&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td style="text-align:center">不小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td style="text-align:center">不大于</td>
</tr>
</tbody>
</table>
<p>去测试两个对象 x、y 代表相同的东西，使用 == 运算符。（在极少数的情况下，你需要知道两个对象是不是同一个对象，使用identical()函数代替。）下面展示了 == 是如何工作的。</p>
<ol>
<li>如果 x 或者 y 为null，如果他俩都是null返回true，不然返回false</li>
<li>返回方法调用的结果 x.==(y)。（这样是正确的，如同 == 的运算符是在第一个操作数上被调用的方法。你可以重载一些运算符，包括 == ，具体参考 <em>重载运算符</em> ）</li>
</ol>
<p>（<strong>举例略</strong>）</p>
<h3>键入测试运算符</h3>
<p>在程序运行的时候，as、is、is!运算符用于检查类型。</p>
<p>| 运算符 |           意义           |<br>
| ------ | :----------------------: | : |<br>
| as     |         类型转换         |<br>
| is     |  如果是指定类型返回true  |<br>
| is!    | 如果不是指定类型返回true |</p>
<p>使用as运算符将对象强制转换为特定的类型。通常，应该使用它作为is对使用该对象的表达式后跟对象的测试的简写。</p>
<pre><code class="language-dart">  if(emp is Person){
    // 检查类型
    emp.firstName = 'Bob';
  }

  // 你可以使用as让代码短一点
  (emp as Person).firstName = 'Bob';

</code></pre>
<blockquote>
<p>这两个写法是不等价的，如果emp为null或者不是Person，第一个例子啥都不干，第二个例子抛出异常。</p>
</blockquote>
<h3>赋值运算符</h3>
<p>（<strong>译者在这一部分省略了大量与其他语言重复的部分，只针对个别特殊的符号加以解析</strong>）</p>
<pre><code class="language-dart">  b ??= value; // 如果b为null，值将会赋给b；如果不为空，b还是原来的值
</code></pre>
<p>（<strong>组合赋值运算符，略</strong>）</p>
<h3>逻辑运算符</h3>
<p>| 运算符 |  意义  |<br>
| ------ | :----: | : |<br>
| !expr  | 非运算 |<br>
| 丨丨   | 或运算 |<br>
| &amp;&amp;     | 与运算 |</p>
<h3>按位和移位运算符</h3>
<p>（<strong>运算之前，将值转化为二进制</strong>）</p>
<p>（<strong>译者按照 1为真，0为假编写解释</strong>）</p>
<p>| 运算符 |            意义            |<br>
| ------ | :------------------------: | : |<br>
| &amp;      |     全真则真，一假则假     |<br>
| 丨     |     一真则真，全假为假     |<br>
| ^      | 位异或运算，同为假，异为真 |<br>
| ~expr  |       假为真，真为假       |<br>
| &lt;&lt;     |           左移位           |<br>
| &gt;&gt;     |           右移位           |</p>
<h3>条件表达式</h3>
<p>Dart有两种运算符，可以简明使用if-else表达式</p>
<blockquote>
<p>condition ? expr1 : expr2</p>
</blockquote>
<p><em><strong>真返回1结果，假返回2结果</strong></em></p>
<blockquote>
<p>expr1 ?? expr2</p>
</blockquote>
<p><em><strong>如果expr1非空，返回它的值；否则，返回2的结果</strong></em></p>
<p><strong>通过布尔表达式控制赋值，考虑?:</strong></p>
<p><strong>如果布尔表达式是用来测试是否为空的，考虑??</strong></p>
<pre><code class="language-dart">  String playerName(String name) =&gt; name ?? 'Guest';
</code></pre>
<p>前面的例子至少可以使用两种方式来编写，但是不简洁：</p>
<pre><code class="language-dart">  // 精简使用?:
  String playerName(String name) =&gt; name != null ? name : 'Guest';

  // 使用if-else表达式写
  String playerName(String name){
    if (name != null){
      return name;
    }else{
      return 'Guest';
    }
  }
</code></pre>
<h3>级联符号（..）</h3>
<p>级联（..）允许你对同一个对象进行一系列的操作。除了函数的调用之外，你还可以访问同一对象上的字段。这通常可以节省创建临时变量的步骤，让代码书写更流畅。</p>
<pre><code class="language-dart">  querySeletor('#confirm') // 获取一个对象
    ..text = 'Confirm' // 使用它的一个成员
    ..classes.add('important')
    ..onClick.listen((e) =&gt; window.alert('Confirmed!'));
</code></pre>
<p>第一个方法调用，querySeletor()，返回一个选择器对象。级联表示法后面的代码对此对象进行操作，忽略可能返回的后续值。</p>
<p>前面的示例相当于：</p>
<pre><code class="language-dart">  var button = querySeletor('#confirm');
  button.text = 'Confirm';
  button.classes.add('import');
  button.onClick.listen((e) =&gt; window.alert('Confirmed!'));
</code></pre>
<p>你也可以嵌套你的级联：</p>
<pre><code class="language-dart">  final addressBook = (AddressBookBuilder()
        ..name = 'jenny'
        ..email = 'jenny@example.com'
        ..phone = (PhoneNumberBuilder()
              ..number = '415-555-0100'
              ..label = 'home')
            .build())
      .build();
</code></pre>
<p>注意在返回实际函数的对象上构造级联。比如，以下代码失败：</p>
<pre><code class="language-dart">  var sb = StringBuffer();
  sb.write('foo')
    ..write('bar'); // error:write方法没有定义为void
</code></pre>
<p>sb.write()调用返回void，你不能在void这一类函数上构造级联。</p>
<blockquote>
<p>注：严格意义上来说，对于级联的两点符号并不是运算符，只是Dart语法的一部分。</p>
</blockquote>
<h3>其他类型运算符</h3>
<p>在其他的示例中，你已经见过大多的剩余的运算符了：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">名称</th>
<th style="text-align:right">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>()</td>
<td style="text-align:center">函数应用</td>
<td style="text-align:right">表示函数的调用</td>
</tr>
<tr>
<td>[]</td>
<td style="text-align:center">列表访问</td>
<td style="text-align:right">引用列表中指定索引处的值</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:center">成员访问权限</td>
<td style="text-align:right">指表达式的属性；示例：fool.bar从表达式foo中选择了属性bar</td>
</tr>
<tr>
<td>?.</td>
<td style="text-align:center">条件成员访问</td>
<td style="text-align:right">跟 '.' 类似，但是运算符的左边可以为null，比如：foo?.bar 从foo中选择了bar属性即使foo为空（在这种情况下，foo?.bar的值为null）</td>
</tr>
</tbody>
</table>
<p>了解更多的信息关于 . ，?. ，和 . 运算符，看 <em>类Classes</em> 。</p>
<h2>流程控制语句</h2>
<p>你可以用下述的Dart代码控制流程：</p>
<ul>
<li>if和else</li>
<li>for循环</li>
<li>while和do-while循环</li>
<li>break和continue</li>
<li>switch和case</li>
<li>assert</li>
</ul>
<p>你也可以使用try-catch和throw影响控制流程，在 <em>异常Exceptions</em> 中介绍。</p>
<h3>if-else语句</h3>
<p>Dart支持带有可选else的if语句，在下个例子中有演示。另见 <em>条件表达式</em> 。</p>
<pre><code class="language-dart">  if (isRaining()){
    you.bringRainCoat();
  } else if (isSnowing()){
    you.wearJacket();
  } else {
    car.putTopDown();
  }
</code></pre>
<p>不像JavaScript，条件必须是布尔值，不能为其他。具体信息看 <em>布尔</em> 。</p>
<h3>for循环</h3>
<p>你可以使用标准的for循环迭代。</p>
<pre><code class="language-dart">  var message = StringBuffer('Dart is fun');
  for (var i = 0; i &lt; 5; i++){
    message.write('!');
  }
</code></pre>
<p>在Dart中for循环内部的闭包捕获了索引的值，避免了JavaScript中常见的陷阱。</p>
<pre><code class="language-dart">  var callbacks = [];
  for (var i = 0; i &lt; 2; i++){
    callbacks.add(() =&gt; print(i));
  }
  callbacks.forEach((c) =&gt; c());
</code></pre>
<p>如预期那样，先输出0后1。相反在JavaScript中这个例子先2后2。</p>
<p>如果迭代的对象是可迭代的，你可以使用forEach()方法。如果你不需要当前的迭代计数器，使用forEach()是个不错的选择。</p>
<pre><code class="language-dart">  candidates.forEach((candidate) =&gt; candidate.interview());
</code></pre>
<p>类似于列表和集合这样的可迭代类也支持迭代的for-in结构：</p>
<pre><code class="language-dart">  var collection = [0, 1, 2];
  for (var x in collection){
    print(x); // 0 1 2
  }
</code></pre>
<h3>while和do-while</h3>
<p>while控制条件在循环之前</p>
<pre><code class="language-dart">  while (!isDone()) {
    doSomething();
  }
</code></pre>
<p>do-while控制条件在循环之后</p>
<pre><code class="language-dart">  do{
    printLine();
  } while(!atEndOfPage());
</code></pre>
<h3>break和continue</h3>
<p>使用break停止循环</p>
<pre><code class="language-dart">  while(true){
    if (shutDownRequested()) break;
    processIncomingRequests();
  }
</code></pre>
<p>使用continue跳到下一个循环迭代</p>
<pre><code class="language-dart">  for (int i = 0; i &lt; candidates.length; i++){
    var candidate = candidates[i];
    if (candidate.yearsExperience &lt; 5){
      continue;
    }
    candidate.interview();
  }
</code></pre>
<p>如果你使用类似于列表、集合的 <em>迭代</em> ，你可以以不同的方式写示例：</p>
<pre><code class="language-dart">  candidates
      .where((c) =&gt; c.yearsExperience &gt;= 5)
      .forEach((c) =&gt; c.interview());
</code></pre>
<h3>switch和case</h3>
<p>（<strong>跟C语言的结构并没有什么本质的区别，略，case内局部变量只在内部有效</strong>）</p>
<h3>断言assert</h3>
<p>如果布尔值为false，使用assert语句将中断程序的正常执行。你可以在这愉快之旅中的例子中感受assert语句的用法。</p>
<pre><code class="language-dart">  // 确认变量有个非空的值
  assert(text != null);

  // 确认值比100小
  assert(number &lt; 100);

  // 确认是个https链接
  assert(urlString.startsWith('https'));

</code></pre>
<blockquote>
<p>注：断言语句对生产代码并没有什么影响；它们只是用于开发。Flutter允许断言在 <em>debug模式</em> 。仅限开发的工具（比如dartdevc）通常默认支持断言。一些工具如dart,dart2js通过命令行标志支持断言：--enable-asserts</p>
</blockquote>
<p>将消息加到断言，添加字符串作为第二参数。</p>
<pre><code class="language-dart">  assert(urlString.startsWith('https'),'URL ($urlString) should start with &quot;https&quot;.');
</code></pre>
<p>第一个参数assert可以是任何解析为布尔值的表达式。如果表达式的值为true，则断言成功并继续执行。如果为false，则断言失败并抛出异常（一个 <em>断言错误</em> ）</p>
<h2>异常Exceptions</h2>
<p>Dart代码可以抛出和捕获异常，异常是指意外事件发生的错误。如果未能捕获异常，则会暂停引发异常的隔离，并且通常会终止隔离和程序。</p>
<p>与Java相比，所有的Dart异常都是未检查的异常。方法不会声明它们会抛出的异常，你也没必要捕获异常。</p>
<p>Dart提供了 <em>异常</em> 和 <em>错误</em> 两种类型，以及许多预定义的子类型，当然也可以自己定义的意外情况。Dart程序可以抛出任何非空对象-不仅仅是异常和错误对象-作为例外。</p>
<h3>抛出throw</h3>
<p>一个抛出或者引发异常的示例：</p>
<pre><code class="language-dart">  throw FormatException('Expected at least 1 section');
</code></pre>
<p>你也可以任意对象：</p>
<pre><code class="language-dart">  throw 'Out of llamas!';
</code></pre>
<blockquote>
<p>注：生成有质量的代码通常会抛出 <em>异常</em> 和 <em>错误</em> 。</p>
</blockquote>
<p>因为抛出异常是一种表达，你可以使用 =&gt; 语句抛出异常，在任何可以表达的地方：</p>
<pre><code class="language-dart">  void distanceTo(Point other) =&gt; throw UnimplementedError();
</code></pre>
<h3>捕获Catch</h3>
<p>捕获，会阻止异常的传播（除非重新抛出异常）。捕获异常使有机会处理它：</p>
<pre><code class="language-dart">  try{
    breedMoreLlamas();
  } on OutOfLlamasException {
    buyMoreLlamas();
  }
</code></pre>
<p>要处理可能抛出多种异常的代码，可以指定多个捕获子句。与抛出对象类型匹配的第一个子句处理异常。如果捕获子句未指定类型，则该子句可以处理任何异常：</p>
<pre><code class="language-dart">  try{
    breedMoreLlamas();
  } on OutOfLlamasException {
    // 一个指定异常
    buyMoreLlamas();
  } on Exception catch (e) {
    // 其他任何异常
    print('Unkown exception: $e');
  } catch (e) {
    // 没有指定类型，可以处理所有
    print('Someting really unkown: $e');
  }
</code></pre>
<p>如上面的代码所示，你可使用on或catch，或者一起用。使用on时需要指定异常的类型。使用catch时，你的异常处理程序需要异常对象。</p>
<p>你可以指定一个或者两个catch()参数。第一个抛出异常，第二个是堆栈跟踪（<em>StackTrace</em> 对象）</p>
<pre><code class="language-dart">  try{
    // ...
  } on Exception catch (e) {
    print('Exception details:\n $e');
  } catch (e, s) {
    print('Exception details:\n $e');
    print('Stack trace:\n $s');
  }
</code></pre>
<p>要处理部分异常，并允许它传播，请使用关键字rethrow。</p>
<pre><code class="language-dart">  void misbehave() {
    try {
      dynamic foo = true;
      print(foo++); // runtime错误
    } catch (e) {
      print('misbehave() partially handled ${e.runtimeType}.');
      rethrow; // 允许调用者查看异常
    }
  }

  void main(){
    try{
      misbehave();
    } catch (e) {
      print('main() finished handling ${e.runtimeType}.');
    }
  }
</code></pre>
<h3>最后Finally</h3>
<p>无论是否抛出异常，要确保某些代码的运行，请使用finally子句。如果没有catch子句匹配该异常，则在finally子句运行后传播异常。</p>
<pre><code class="language-dart">  try{
    breedMoreLlamas();
  } finally {
    // 总是被清理，即使有其他异常
    cleanLlamaStalls();
  }
</code></pre>
<p>finally子句在任何匹配的catch子句之后运行：</p>
<pre><code class="language-dart">  try{
    breedMoreLlamas();
  } catch (e) {
    print('Error: $e'); // 首先处理异常
  } finally {
    cleanLlamaStalls(); // 然后清理
  }
</code></pre>
<p>了解更多，请阅读库之旅的 <em>异常</em> 部分。</p>
<h2>类</h2>
<p>Dart是一门面向对象的语言，具有类以及基于mixin的继承。每个对象都是一个类的实例，所有的类都来自于Object。基于Mixin的继承意味着即使每个类（除了Object）只有一个超类（父类），但是类体可以在多个类层次结构中重用。</p>
<h3>使用类成员</h3>
<p>对象有由函数和数据（分别为方法和实例变量）组成的成员。调用方法时，可以在对象上调用它：该方法可以访问该对象的函数和数据。</p>
<p>使用点（.）来引用实例变量或者方法：</p>
<pre><code class="language-dart">  var p = Point(2, 2);

  // 设置实例变量y的值
  p.y = 3;

  // 获取y的值
  assert(p.y == 3);

  // 在p上调用distanceTo()
  num distance = p.distanceTo(Point(4, 4));
</code></pre>
<p>使用 ?. 代替 . 避免最左边的操作数为空的情况</p>
<pre><code class="language-dart">  // 如果p不为空，把它的y的值设为4
  p?.y = 4;
</code></pre>
<h3>使用构造函数</h3>
<p>你可以使用构造函数来创造对象。构造函数的名称可以是 ClassName 或 ClassName.identifier。举例，下面的代码创建了一个Point对象使用了构造函数 Point() 和 Point.fromJson()：</p>
<pre><code class="language-dart">  var p1 = Point(2, 2);
  var p2 = Point.fromJson({'x': 1, 'y': 2});
</code></pre>
<p>下面的代码的效果是一样的，但是在构造函数之前使用了可选的关键字 <em>new</em></p>
<pre><code class="language-dart">  var p1 = new Point(2, 2);
  var p2 = new Point.fromJson({'x': 1, 'y': 2});
</code></pre>
<blockquote>
<p>版本提示：在Dart2中new才是可选的</p>
</blockquote>
<p>一些类提供了常构造函数。使用常构造函数去创建一个编译时的常量，在构造函数的名称前添加关键词 <em>const</em> 。</p>
<pre><code class="language-dart">  var p = const ImmutablePoint(2, 2);
</code></pre>
<p>构造两个相同的编译时常量会产生一个规范的实例：</p>
<pre><code class="language-dart">  var a = const ImmutablePoint(1, 1);
  var b = const ImmutablePoint(1, 1);

  assert(identical(a, b));// 它们是相同的实例
</code></pre>
<p>在常量的上下文中，你可以省略构造函数或者文字前的 <em>const</em> 关键字，比如，看这段创造一个常地图代码。</p>
<pre><code class="language-dart">  // 这有太多的const关键字

  const pointAndLine = const {
    'point': const [const ImmutablePoint(0, 0)],
    'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
  };
</code></pre>
<p>你可以省略除了第一个const关键字</p>
<pre><code class="language-dart">  // 只用一个const
  const pointAndLine = {
    'point': [ImmutablePoint(0, 0)],
    'line': [ImmutablePoint(1,10), ImmutablePoint(-2, 11)],
  };
</code></pre>
<p>如果一个常构造函数在常上下文外被调用没有const，它创建了一个非 <em>常对象</em>：</p>
<pre><code class="language-dart">  var a = const ImmutablePoint(1, 1);// 创造了一个常对象
  var b = ImmutablePoint(1, 1);// 未创造一个常对象

  assert(!identical(a, b));// 它们不是相同的实例
</code></pre>
<blockquote>
<p>版本提示：在Dart2中在常上下文中const才是可选的。</p>
</blockquote>
<h3>获取一个对象的类型</h3>
<p>在程序执行的过程中获取对象的类型，你可以使用Object的runtimeType属性，返回 <em>类型Type</em> 对象。</p>
<pre><code class="language-dart">  print('The type of a is ${a.runtimeType}');
</code></pre>
<p>到目前为止，你已经了解如何使用类了。本节的其余部分将介绍如何实现类。</p>
<h3>实例变量</h3>
<p>这里展示了如何去声明一个实例变量：</p>
<pre><code class="language-dart">  class Point{
    num x; // 声明实例变量x，初始值为空
    num y; // 声明变量y，初始值为空
    num z=0; // 声明变量，初始值为0
  }
</code></pre>
<p>没有初始化的变量的值为null</p>
<p>所有的实例变量都生成一个隐式的getter方法。非最终实例变量（Non-final）也生成一个setter方法。获取更多的细节，参照 <em>Getters和Setters</em></p>
<pre><code class="language-dart">  class Point {
    num x;
    num y;
  }

  void main(){
    var point = Point();
    point.x = 4; // 对x使用setter方法
    assert(point.x == 4); // 对x使用getter方法
    assert(point.y == null); // 默认值为null
  }
</code></pre>
<p>如果你在实例对象声明的地方初始化对象（而不是在构造函数或者方法中），当实例被创建的时候值就已经被设置了，在构造函数和初始化列表执行之前。</p>
<h3>构造函数</h3>
<p>通过创建一个跟它的类同名的构造函数来实现构造函数的声明。（plus，可选的，还有一个额外的标识符，如同 <em>命名构造函数</em> 所述）</p>
<p>最常见的构造函数形式，即生成构造函数，创造类的一个新实例：</p>
<pre><code class="language-dart">  class Point {
    num x, y;
    Point (num x, num y) {
      // 有更好的方法去做这个

      this.x = x;
      this.y = y;
    }
  }
</code></pre>
<p>this关键字指向现况的实例</p>
<blockquote>
<p>使用this时这会有一个命名冲突。否则，Dart代码将会省略this。</p>
</blockquote>
<p>将构造函数的值赋给实例变量的模式是很常见的。Dart有语法sugar使实现更简单：</p>
<pre><code class="language-dart">  class Point {
    num x, y;

    // 使用语法sugar设置x，y的值
    // 在构造函数体运行之前
    Point(this.x, this.y);
  }
</code></pre>
<h4>默认构造函数</h4>
<p>如果自己没有声明构造函数，它会自己生成一个。默认生成的构造函数没有参数，并在超类（父类）中调用无参构造函数。</p>
<h4>构造函数不是被继承的</h4>
<p>子类不从超类（父类）中继承构造函数。声明没有构造函数的子类只有默认构造函数（无参数，无名称）。</p>
<h4>命名构造函数</h4>
<p>使用命名构造函数为类实现多个构造函数去实现更加的清晰。</p>
<pre><code class="language-dart">  class Point {
    num x, y;

    Point(this.x, this.y);

    // 命名构造函数

    Point.origin() {
      x=0;
      y=0;
    }
  }
</code></pre>
<p>记住构造函数是不能被继承的，就意味着超类（父类的）命名构造函数也不能被子类继承。如果希望使用超类中定义的命名构造函数创建子类，则必须在子类中实现该构造函数。</p>
<h4>调用非默认的超类构造函数</h4>
<p>默认的，在子类调用的超类构造函数是没有命名、没有参数的。超类构造函数在构造函数的开头被调用；如果一个初始化列表也被调用，它将在超类调用之前执行。总之，执行顺序如下：</p>
<ol>
<li>初始化列表</li>
<li>超类无参构造函数</li>
<li>主类无参构造函数</li>
</ol>
<p>如果超类没有未命名的无参构造函数，你必须手动在超类中调用一个构造函数。在冒号后面指定超类的构造函数，在构造函数体的前部。</p>
<p>在下面的示例中，Employee类的构造函数调用它的超类Person的命名构造函数</p>
<pre><code class="language-dart">  class Person {
    String firstName;

    Person.fromJson(Map data) {
      print('in Person');
    }
  }

  class Employee extends Person {
    // Person没有默认的构造函数
    // 你必须调用super.fromJson(data)
    Employee.fromJson(Map data) : super.fromJson(data) {
      print('in Employee');
    }
  }

  main() {
    var emp = new Employee.fromJson({});
  }

  // Prints:
  // in Person
  // in Employee

  if (emp is Person){
    // 类型检查
    emp.firstName = 'Bob';
  }
  (emp as Person).firstName = 'Bob';
</code></pre>
<p>因为在调用构造函数之前会处理超类构造函数的参数，所以参数可以是一个表达式，比如函数调用：</p>
<pre><code class="language-dart">  class Employee extends Person {
    Employee() : super.fromJson(getDefaultData());
    // ...
  }
</code></pre>
<blockquote>
<p>注意：超类构造函数的参数没有this的权限，例如，参数可以调用静态方法但是不能调用实例方法。</p>
</blockquote>
<h4>初始化列表</h4>
<p>除了调用超类的构造函数外，你也可以在构造函数体运行之前，初始化实例变量。用逗号分隔初始化：</p>
<pre><code class="language-dart">  // 初始化列表在构造函数体运行之前设置实例的变量

  Point.fromJson(Map&lt;String, num&gt; json)
    : x = json['x'],
      y = json['y'] {
        print('In Point.fromJson() : ($x, $y)');
      }
</code></pre>
<blockquote>
<p>注意：初始化程序的右侧无权访问this。</p>
</blockquote>
<p>在开发期间，你可以在初始化列表验证输入的值</p>
<pre><code class="language-dart">  Point.withAssert(this.x, this.y) : assert(x &gt;= 0) {
    print('In Point.withAssert() : ($x, $y)');
  }
</code></pre>
<p>设置final字段时，设置初始化列表很方便。在下面的示例中在初始化列表中初始化了三个final字段。</p>
<pre><code class="language-dart">  import 'dart:math';

  class Point {
    final num x;
    final num y;
    final num distanceFromOrigin;

    Point(x, y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
  }

  main() {
    var p = new Point(2, 3);
    print(p.distanceFromOrigin);
  }
</code></pre>
<h4>重定向构造函数</h4>
<p>有时候构造函数只用于在同一个类中重定向到其他的构造函数。重定向构造函数的函数体是空的，构造函数的调用出现在冒号之后。</p>
<pre><code class="language-dart">  class Point {
    num x, y;

    // 这个类的主构造函数
    Point(this.x, this.y);

    // 代表主构造函数
    Point.alongXAxis(num x) : this(x, 0);
  }
</code></pre>
<h4>常构造函数</h4>
<p>如果你的类生成不打算更改的对象，你可以使这些对象为编译时常量。为了去实现，定义一个const构造函数，并保证所有的实例变量都是final型。</p>
<pre><code class="language-dart">  class ImmutablePoint {
    static final ImmutablePoint origin  = const ImmutablePoint(0, 0);

    final num x, y;
    const ImmutablePoint(this.x, this.y);
  }
</code></pre>
<p>常构造函数并不总是创造常量。更多细节，去看 <em>使用构造函数</em> 那一节。</p>
<h4>工厂构造函数</h4>
<p>使用关键字 factory 当实现构造函数不总在它的类中创建新的实例。比如，工厂构造函数可能从缓存（cache）中返回实例，或者返回子类型实例。</p>
<p>下面的示例演示了一个构造函数从缓存中返回了一个对象：</p>
<pre><code class="language-dart">  class Logger {
    final String name;
    bool mute = false;

    // _cache是库私有，因为标识符前面的_
    static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};

    factory Logger(String name) {
      if (_cache.containsKey(name)) {
        return _cache[name];
      } else {
        final logger = Logger._internal(name);
        _cache[name] = logger;
        return logger;
      }
    }
  }

  Logger._internal(this.name);

  void log(String msg) {
    if(!mute) print(msg);
  }
</code></pre>
<blockquote>
<p>工厂构造函数没有this的权限。</p>
</blockquote>
<p>调用工厂构造函数跟调用其他的构造函数一样：</p>
<pre><code class="language-dart">  var logger = Logger('UI');
  logger.log('Button clicked');
</code></pre>
<h3>方法</h3>
<p>方法是赋予对象动作的函数。</p>
<h4>实例方法</h4>
<p>在对象中的实例方法有使用实例对象和this的权限。下面例子中的distanceTo()方法就是一个实例方法的示例：</p>
<pre><code class="language-dart">  import 'dart:math';

  class Point{
    num x, y;

    Point(this.x, this.y);

    num distanceTo(Point other) {
      var dx = x - other.x;
      var dy = y - other.y;
      return sqrt(dx * dx + dy * dy);
    }
  }
</code></pre>
<h4>Getters和Setters</h4>
<p>Getters和Setters是提供了读写对象属性的特殊方法。回想一下，每一个实例变量都有一个隐性的getter，如果合适的话还有一个setter。你可以通过get和set关键字实现创建额外的属性。</p>
<pre><code class="language-dart">  class Rectangle {
    num left, top, width, height;

    Rectangle(this.left, this.top, this.width, this.height);

    // 定义两个计算的属性：right和bottom
    num get right =&gt; left + width;
    set right(num value) =&gt; left = value - width;
    num get bottom =&gt; top + height;
    set bottom(num value) =&gt; top = value - height;
  }

  void main() {
    var rect = Rectangle(3, 4, 20, 15);
    assert(rect.left == 3);
    rect.right = 12;
    assert(rect.left == -8);
  }

</code></pre>
<p>通过getters和setters，你从实例变量开始，稍后使用方法包装它们，无需更改客户端的代码。</p>
<blockquote>
<p>注意：无论是否明确定义了getter，如同++的运算符都会如于其那样工作。去避免任何不可预测的影响，运算发只需要调用一次getter，并将其值保存在临时变量中。</p>
</blockquote>
<h3>抽象类</h3>
<p>使用abstract修饰符定义抽象类——不能被实例化的类，抽象类对于定义接口是非常有用的，通常还有一些实现。如果你想使抽象类初始化，那就定义一个 <em>factory（工厂）构造函数</em> 。</p>
<p>抽象类一般有抽象方法，下面是一个带有抽象方法的抽象类的示例：</p>
<pre><code class="language-dart">  // 这个类被定义为抽象类，不能被实例化
  abstract class AbstractContainer {
    // 定义构造函数，域，方法。。。

    void updateChildren(); // 抽象方法
  }
</code></pre>
<h3>隐式接口</h3>
<p>每个类都隐式定义了一个接口，接口包含所有该类的实例成员及其实现的接口。如果你想在不继承B类的情况下创建支持B类API的A类，A类应该实现B接口。</p>
<p>类通过在implements子句中声明它们，然后提供接口所需的API来实现一个或者多个接口：</p>
<pre><code class="language-dart">  // 一个Person，隐式接口包含greet()
  class Person {
    // 在界面中，仅能在这个库中可见
    final _name;

    // 因为是个构造函数，所以不在界面中
    Person(this._name);

    // 在界面中
    String greet(String who) =&gt; 'Hello, $who.I am &amp;_name.'
  }

  // Person接口的实现
  class Impostor implements Person {
    get _name =&gt; '';

    String greet(String who) =&gt; 'Hi $who . Do you know who I am?'
  }

  String greetBob(Person person) =&gt; person.greet('Bob');

  void main(){
    print(greetBob(Person('Kathy')));
    print(greetBob(Impostor()));
  }

</code></pre>
<p>这是一个指定类实现多个接口的示例：</p>
<pre><code class="language-dart">  class Point implements Comparable, Location {...}
</code></pre>
<h3>扩展类（继承与派生）</h3>
<p>使用extends创造子类，并且使用super指向超类：</p>
<pre><code class="language-dart">  class Television {
    void turnOn() {
      _illuminateDisplay();
      _activateIrSensor();
    }
    // ...
  }

  class SmartTelevision extends Television {
    void turnOn() {
      super.turnOn();
      _bootNetworkInterface();
      _initializeMemory();
      _upgradeApps();
    }
    // ...
  }
</code></pre>
<h4>重载成员</h4>
<p>子类可以重写实例方法，getters，setters。你可以使用 <em>@override</em> 注释来指示你有意重载的成员：</p>
<pre><code class="language-dart">  class SmartTelevision extends Television {
    @override
    void turnOn() {...}
    // ...
  }
</code></pre>
<p>在代码中，去限制方法参数或者实例变量的类型是 <em>类型安全</em> 的，你可以使用 <em>协变关键字covariant keyword</em> 。</p>
<h4>重载运算符</h4>
<p>你可以重载下表中的运算符。举个例子，如果你定义一个Vector类，你可以定义一个 + 方法相加两个vector（<strong>译者注：可以参考C++在这部分的内容</strong>）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">可重载运算符表</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">+</td>
<td style="text-align:center">丨</td>
<td style="text-align:center">[]</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">/</td>
<td style="text-align:center">^</td>
<td style="text-align:center">[]=</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">~/</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">~</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">*</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">==</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">%</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>你可能注意到了!=是不可以重载的运算符，表达式e1 != e2只是!(e1 == e2)的句法糖（<strong>译者注：看到这里，译者觉得所谓句法糖的意思，貌似是等价写法的意思，嘤嘤嘤</strong>）</p>
</blockquote>
<p>下面是类重载运算符的一个例子：</p>
<pre><code class="language-dart">  class Vector {
    final int x, y;

    Vector(this.x, this.y);

    Vector operator + (Vector v) =&gt; Vector(x + v.x, y + v.y);
    Vector operator - (Vector v) =&gt; Vector(x - v.x, y - v.y);

    // 运算符 == 和 哈希码并没有显示。更多的细节在后面的note中。
  }

  void main() {
    final v = Vector(2, 3);
    final w = Vector(2, 2);

    assert(v + w == Vector(4, 5));
    assert(v - w == Vector(0, 1));
  }
</code></pre>
<p>如果你重载了 == ，你也应该重载对象的哈希码getter。举个例子重载 == 和哈希码，参见 <em>实现地图键（在库之旅中）</em> 。</p>
<p>更多关于重载的信息，通常参考 <em>扩展类（继承）</em> 。</p>
<h4>没有这个方法noSuchMethod()</h4>
<p>要在代码中尝试使用不存在的方法或实例变量时，检测或做出反应，你可以重载noSuchMethod()：</p>
<pre><code class="language-dart">  class A {
    // 除非你重载noSuchMethod，否则使用不存在的成员会导致NOSuchMethodError。

    @override
    void noSuchMethod(Invocation invocation) {
      print('You tried to use a non-existent member: ' + '${invocation.memberName}');
    }
  }
</code></pre>
<p>你 <strong>不可以</strong> 调用一个没有实现的方法，除非满足下面的任意一点：</p>
<ul>
<li>
<p>接收器具有静态的类型dynamic</p>
</li>
<li>
<p>接收器具有静态的类型定义了没有实现的方法（抽象是可以的），接收器的dynamic类型有noSuchMethod()的实现，跟类对象是不一样的</p>
</li>
</ul>
<p>更多请参照 <a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/nosuchmethod-forwarding.md">noSuchMethod转发规范noSuchMethod forwarding specification</a></p>
<h3>枚举类型Enumerated types</h3>
<p>枚举类型，通常被称为 <em>enumerations</em> 或者 <em>enums</em> ，是被用来代表常量的固定数字的特殊一类。</p>
<h4>使用枚举</h4>
<p>使用关键字enum声明枚举类型：</p>
<pre><code class="language-dart">  enum Color { red, green, blue }
</code></pre>
<p>每个枚举的值都有一个 <strong>索引index</strong> getter，返回从零开始的索引。</p>
<pre><code class="language-dart">  assert(Color.red.index == 0);
  assert(Color.green.index == 1);
  assert(Color.blue.index == 2);
</code></pre>
<p>去获取枚举中所有值的列表，你可以使用枚举的values常方法</p>
<pre><code class="language-dart">  List&lt;Color&gt; colors = Color.values;
  assert(Color[2] == Color.blue);
</code></pre>
<p>你可以在switch语句使用枚举，如果你不处理枚举的所有的值你将会收到警告。</p>
<pre><code class="language-dart">  var aColor = Color.blue;

  switch (aColor) {
    case Color.red:
      print('Red as roses!');
      break;
    case Color.green:
      print('Green as grass!');
      break;
    default: // 避免警告
      print(aColor);
  }
</code></pre>
<p>枚举类型有下面的限制：</p>
<ul>
<li>你不可以创建子类，混入，或者实现枚举</li>
<li>你不可以明确地实例化枚举</li>
</ul>
<p>了解更多，参见 <em>Dart语言规范</em> 。</p>
<h3>向类添加功能：混入mixins</h3>
<p>Mixins是一种在多个类层次结构中重用类代码的方法。</p>
<p>使用 mixin，请使用with关键字后跟一个或多个mixin名称。以下示例显示了两个使用mixins的类：</p>
<pre><code class="language-dart">  class Musician extends Performer with Musical {
    // ...
  }

  class Maestro extends Person with Musical, Aggressive, Demented {
    Maestro(String maestroName) {
      name = maestroName;
      canConduct = true;
    }
  }
</code></pre>
<p>去实现mixin，创建一个类并扩展对象、不要声明构造函数。除非您希望mixin可用作常规类，否则请使用mixin关键字而不是class。</p>
<pre><code class="language-dart">  mixin Musical {
    bool canPlayPiano = false;
    bool canCompose = false;
    bool canConduct = false;

    void enterainMe() {
      if (canPlayPiano) {
        print('Playing Piano');
      } else if(canConduct) {
        print('Waving hands');
      } else {
        print('Humming to self');
      }
    }
  }
</code></pre>
<p>可以使用mixin指定一个明确的类型，举个例子，你的mixin可以调用一个没有定义的方法——使用on指向调用的超类。</p>
<pre><code class="language-dart">  mixin MusicalPerformer on Musician {
    // ...
  }
</code></pre>
<p>版本提醒：在Dart2.1中介绍了对于mixin的支持。早期版本的代码通常使用抽象类代替。更多关于2.1中mixin变化的信息，参见 <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md">Dart SDK改变日志 Dart SDK changelog</a> 和  <a href="https://github.com/dart-lang/language/blob/master/accepted/2.1/super-mixins/feature-specification.md#dart-2-mixin-declarations">2.1 mixin 规范 2.1 mixin specification</a>。</p>
<h3>类变量和方法</h3>
<p>使用static关键字去实现类范围的变量和方法：</p>
<h4>静态变量</h4>
<p>静态变量（类变量）对类范围的状态和常量是非常实用的：</p>
<pre><code class="language-dart">  class Queue {
    static const initialCapacity = 16;
    //...
  }

  void main(){
    assert(Queue.initialCapacity == 16);
  }
</code></pre>
<p>静态变量直到使用的时候才能被初始化。</p>
<p>此页遵循<a href="https://www.dartlang.org/guides/language/effective-dart/style#identifiers">样式指南建议</a>更偏向为常名称使用lowerCamelCase。</p>
<h4>静态方法</h4>
<p>静态方法（类方法）不在实例中作用，因此无this权限。</p>
<pre><code class="language-dart">  import 'dart:math';

  class Point {
    num x, y;
    Point(this.x, this.y);

    static num distanceBetween(Point s, Point b) {
      var dx = a.x - b.x;
      var dy = a.y - a.y;
      return sqrt(dx * dx + dy * dy);
    }
  }

  void main() {
    var a = Point(2, 2);
    var b = Point(4, 4);
    var distance = Point.distanceBetween(a, b);
    assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);
    print(distance);
  }
</code></pre>
<blockquote>
<p>对于常用或广泛使用的实用程序和功能，请考虑使用顶级函数而不是静态方法。</p>
</blockquote>
<p>你可以使用静态方法作为编译时常量。举个例子，可以将静态方法作为参数传递给常量构造函数。</p>
<h2>泛型Generics</h2>
<p>如果你查看基础API文档数组，列表，你将会看到类型其实是List&lt;E&gt;。&lt;...&gt;将列表标记为泛型（或者参数化）类型——具有正式参数类型的参数。按照惯例，类型变量有单个字母名称，比如E,T,S,K和V。</p>
<h3>为什么要使用泛型</h3>
<p><em><strong>译者注：泛型即为模板</strong></em></p>
<p>泛型常被用于类型安全，然而它们有比仅仅让你的代码运行的更多好处。</p>
<ul>
<li>正确指定泛型类型可以生成更好的代码。</li>
<li>您可以使用泛型来减少代码重复。</li>
</ul>
<p>如果你希望列表只包含字符串，你可以声明它为List&lt;String&gt;（读作“字符串列表”）。这样，你，你的程序和你的工具检测列表中的非字符串参数是个错误。</p>
<pre><code class="language-dart">  var names = List&lt;String&gt;();
  names.addAll(['Seth', 'Kathy', 'Lars']);
  names.add(42); // 错误
</code></pre>
<p>使用泛型的另一个原因是减少代码重复。泛型允许您在多种类型之间共享单个接口和实现，同时仍然利用静态分析。比如创建一个缓存对象的接口</p>
<pre><code class="language-dart">  abstract class ObjectCache {
    Object getByKey(String key);
    void setByKey(String Key, Object value);
  }
</code></pre>
<p>你发现你想创建一个指定字符串版本的接口，你创建另一个接口：</p>
<pre><code class="language-dart">  abstract class StringCache {
    String getByKey(String key);
    void setByKey(String Key, String value);
  }
</code></pre>
<p>然后你又想创建一个指定数字版本的接口。。。</p>
<p>泛型类型可以解决你创建所有的这些接口的问题。取而代之，你可以带有类型参数创建单个接口：</p>
<pre><code class="language-dart">  abstract class Cache&lt;T&gt; {
    T getByKey(String key);
    void setByKey(String key, T value);
  }
</code></pre>
<p>在这段代码中，T是替身类型。它是一个占位符，您可以将其视为开发人员稍后定义的类型。</p>
<h3>使用集合文字</h3>
<p>列表和集合文字可以被参数化。参数化文字除了在括号之前添加类型，其他就像你之前看到的那样。</p>
<pre><code class="language-dart">  var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
  var pages = &lt;String, String&gt;{
    'index.html': 'Homepage',
    'robot.txt': 'Hints for web robots',
    'humans.txt': 'We are people, not machines'
  };
</code></pre>
<h3>使用带有构造函数的参数化类型</h3>
<p>在使用构造函数的时候，指定一个或者多个类型，将类型放在类名后面的尖角括号之中</p>
<pre><code class="language-dart">  var names = List&lt;String&gt;();
  names.addAll(['Seth', 'Kathy', 'Lars']);
  var nameSet = Set&lt;String&gt;.from(names);
</code></pre>
<p>下面的代码创建了一个整型键、View类型的地图</p>
<pre><code class="language-dart">  var views = Map&lt;int, View&gt;();
</code></pre>
<h3>泛型集合和它们包含的类型</h3>
<p>Dart泛型的类型具体化，意味着它们在运行时携带类型信息。</p>
<pre><code class="language-dart">  var names = List&lt;String&gt;();
  names.addAll(['Seth', 'Kathy', 'Lars']);
  print(names is List&lt;String&gt;); // 输出true
</code></pre>
<blockquote>
<p>相反，在Java中泛型擦除，就意味着在运行中删除泛型类型参数。在Java之中，你可以测试对象是否List，但是不能测试它是否是List&lt;String&gt;。</p>
</blockquote>
<h3>限制参数化类型</h3>
<p>当你实现泛型类型之时，你需要去限制参数的类型。你可以使用extends。</p>
<pre><code class="language-dart">  class Foo&lt;T extends SomeBaseClass&gt; {
    String toString() =&gt; &quot;Instance of 'Foo&lt;$T&gt;'&quot;;
  }

  class Extender extends SomeBaseClass {...}
</code></pre>
<p>可以使用SomeBaseClass或其任何子类作为泛型参数：</p>
<pre><code class="language-dart">  var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();
  var extenderFoo = Foo&lt;Extender&gt;();
</code></pre>
<p>也可以不指定泛型参数：</p>
<pre><code class="language-dart">  var foo = Foo();
  print(foo); // Instance of 'Foo&lt;SomeBaseClass&gt;'
</code></pre>
<p>指定非SomeBaseClass会导致错误：</p>
<pre><code class="language-dart">  var foo = Foo&lt;Object&gt;(); // 错误
</code></pre>
<h3>使用泛型方法</h3>
<p>起初，Dart的泛型支持被限制在类。一个更新的语法，叫做泛型方法，允许类型参数在方法或者函数中：</p>
<pre><code class="language-dart">  T first&lt;T&gt;(List&lt;T&gt; ts) {
    // 先做一些初始化工作或者错误检查
    T tmp = ts[0];
    //
  }
</code></pre>
<p>这里在first&lt;T&gt;中泛型类型参数，允许你在一些地方使用类型参数T</p>
<ul>
<li>在函数的返回类型(T)</li>
<li>在参数类型(List&lt;T&gt;)</li>
<li>在局部变量(T tmp)</li>
</ul>
<p>了解关于泛型的更多信息，参考 <a href="https://github.com/dart-lang/sdk/blob/master/pkg/dev_compiler/doc/GENERIC_METHODS.md">使用泛型方法</a></p>
<h2>库与能见度</h2>
<p>import和library指令可以帮助你创建一个模块化的、可分享的代码库。库不仅仅提供API，还有隐私单元：以下划线开头的标识符只在库内可见。每一个Dart APP都是一个库，即使它没有使用library指令。</p>
<p>可以使用包来分发库。在<a href="https://www.dartlang.org/tools/pub">发布包和内容管理</a>中了解关于pub有关的信息，在SDK中包含包管理。</p>
<h3>使用库</h3>
<p>使用import指定如何从一个库中的命名空间在另一个库的范围内使用。</p>
<p>举个例子，Dart web应用通常使用 <a href="https://api.dartlang.org/stable/dart-html">dart:html</a>库。</p>
<pre><code class="language-dart">  import 'dart:html';
</code></pre>
<p>import需要的唯一参数是指定库的URI。对于内置的库，URI有特殊的 <strong>dart:</strong> 方案。对于其他的库，你可以使用文件系统路径或者 <strong>package:</strong> 方案。package方案指定由类似于pub tool的包管理提供的库。</p>
<pre><code class="language-dart">  import 'package:test/test.dart';
</code></pre>
<blockquote>
<p>URI代表了统一资源标识符。URL(uniform resource locators)(统一资源定位符)是一种常见的URI。</p>
</blockquote>
<h4>指定一个库前缀</h4>
<p>如果你输入两个含有冲突的标识符的库，然后你可以为一个或者所有的库指定前缀。举个例子，如果库1和库2都有Element类：</p>
<pre><code class="language-dart">  import 'package:lib1/lib1.dart';
  import 'package:lib2/lib2.dart' as lib2;

  // 使用来自于库1的Element
  Element element1 = Element();

  // 使用来自于库2的Element
  lib2.Element element2 = lib2.Element();
</code></pre>
<h4>输入库的一部分</h4>
<p>如果你只想使用库的一部分，你可以有选择性的输入库。</p>
<pre><code class="language-dart">  // 只输入foo
  import 'package:lib1/lib.dart' show foo;

  // 输入除了foo
  import 'package:lib2/lib2.dart' hide foo;
</code></pre>
<h4>懒加载一个库</h4>
<p><strong>延期加载（或者称为懒加载）</strong> 允许应用在有需要的时候加载一个库。以下是您可能使用延迟加载的一些情况：</p>
<ul>
<li>减少应用程序的初次启动时间</li>
<li>执行A/B测试——尝试算法的替代实现</li>
<li>加载很少使用的功能，例如可选的屏幕和对话框</li>
</ul>
<p>要懒加载一个库，你必须首先使用deferred as。</p>
<pre><code class="language-dart">  import 'package:greetings/hello.dart' deferred as hello;
</code></pre>
<p>当你使用库的使用，使用库的标识符调用loadLibrary()</p>
<pre><code class="language-dart">  Future greet async{
    await hello.loadLibrary();
    hello.printGreeting();
  }
</code></pre>
<p>在前面的代码中，await关键字暂停了执行，直到库被加载。了解关于async和await，参考 <a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support">异步支持asynchrony support</a>。</p>
<p>你可以在一个库中调用loadLibrary()很多次，没有任何问题，库只被加载一次。</p>
<p>使用延时加载的时候，记住以下内容：</p>
<ul>
<li>延迟库的常量不是导入文件中的常量。在加载延迟库之前，这些常量不存在。</li>
<li>不能在导入文件中使用延迟库中的类型，考虑将接口类型移动到由延迟库和导入文件导入的库。</li>
<li>你使用deferred as namespace，Dart将loadLibrary()隐式插入到命名空间。loadLibrary()函数返回一个Future。</li>
</ul>
<blockquote>
<p>DartVM区别：即使在调用之前，Dart VM也允许访问延迟库的成员loadLibrary()。此行为可能会更改，因此 <em>不要依赖于当前的VM行为</em> 。</p>
</blockquote>
<p>详细信息参见 <a href="https://github.com/dart-lang/sdk/issues/33118">issue #33118</a>。</p>
<h3>实现库</h3>
<p>参阅 <a href="https://www.dartlang.org/guides/libraries/create-library-packages">创建库包</a> 需求如何去实现一个库包，包括：</p>
<ul>
<li>如何组织库源代码</li>
<li>如何使用export指令</li>
<li>何时使用part指令</li>
</ul>
<h2>异步支持</h2>
<p>Dart库中包含很多返回 <a href="https://api.dartlang.org/stable/dart-async/Future-class.html">Future</a> 或者 <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html">Stream</a>对象的函数。这些函数是异步的。它们在设置可能耗时的操作后（比如I/O）返回，而不等待操作完成。</p>
<p>async和await关键字支持异步编程，让你写异步代码看起来更像是同步代码。</p>
<h3>处理Futures</h3>
<p>当你需要完成的Future结果时，你有两个选择：</p>
<ul>
<li>使用async和await</li>
<li>使用Future API，在 <a href="https://www.dartlang.org/guides/libraries/library-tour#future">库之旅</a> 中有所描述。</li>
</ul>
<p>代码使用async和await是异步的，但是它看起来很像是同步代码。举个例子，这有一些使用await关键字等待异步函数结果的代码：</p>
<pre><code class="language-dart">  await lookUpVersion();
</code></pre>
<p>去使用await，代码必须是一个异步函数——一个函数被标记为async：</p>
<pre><code class="language-dart">  Future checkVersion() async {
    var version = await lookUpVersion();
  }
</code></pre>
<blockquote>
<p>注意：虽然异步函数可能执行耗时的操作，但它不会等待这些操作。异步函数只有在遇到第一个await表达式（<strong>详情</strong>）时才会执行等待。然后它返回一个Future对象，仅在await表达式完成后才恢复原样执行。</p>
</blockquote>
<p><a href="https://github.com/dart-lang/sdk/blob/master/docs/newsletter/20170915.md#synchronous-async-start">详情</a></p>
<p>使用try,catch,finally去处理和清除使用await代码的错误：</p>
<pre><code class="language-dart">  try {
    version = await lookUpVersion();
  } catch(e) {
    // 无法查找版本
  }
</code></pre>
<p>你可以在异步函数中多次使用await。举个例子，下面的代码等待了三次函数结果：</p>
<pre><code class="language-dart">  var entrypoint = await findEntryPoint();
  var exitCode = await runExecutable(entrypoint, args);
  await flushThenExit(exitCode);
</code></pre>
<p>在await表达式中，通常结果都是Future；如果不是，那么值自动包含在了Future中。这个Future对象表示返回一个对象的承诺，await表达式的值是返回一个对象。await表达式使执行暂停直到对象可用。</p>
<p><strong>如果使用await的时候出现了编译时错误，请确保await是在一个异步函数之中(async function)。</strong> 举个例子，在app中的main()函数中使用await，main()的函数体必须被标记为async：</p>
<pre><code class="language-dart">  Future main() async {
    checkVersion();
    print('In main: version is ${await lookUpVersion()}');
  }
</code></pre>
<h3>声明异步函数</h3>
<p>异步函数是通过标记async修改函数体的函数。</p>
<p>将async关键字加到函数上，使它返回一个Future。举个例子，考虑一个返回String的同步函数：</p>
<pre><code class="language-dart">  String lookUpVersion() =&gt; '1.0.0';
</code></pre>
<p>如果将它改为异步函数——举个例子，future表现执行起来会非常耗时——返回值是一个Future。</p>
<pre><code class="language-dart">  Future&lt;String&gt; lookUpVersion() async =&gt; '1.0.0';
</code></pre>
<p>注意这个函数体不需要使用Future的API。在必要的情况下，Dart创造一个Future对象。</p>
<p>如果你的函数不返回任何有用的值，让它的返回类型为Future&lt;void&gt;。</p>
<h3>处理流(Streams)</h3>
<p>如果你想从流中获取值，你有两种方法：</p>
<ul>
<li>使用async和一个异步for循环(await for)。</li>
<li>使用Stream API，在 <a href="https://www.dartlang.org/guides/libraries/library-tour#stream">库之旅</a> 中有阐述。</li>
</ul>
<blockquote>
<p>注意：在使用await for之前，请确保它使代码更清晰并且你确实想去等待流的所有的值。例如，你通常不应该为UI事件侦听器使用await for，因为UI框架发送无穷尽的事件流。</p>
</blockquote>
<p>异步for循环有以下的形式：</p>
<pre><code class="language-dart">  await for (var或者类型 标识符 in 表达式) {
    // 在每一次流发射值的时候执行
  }
</code></pre>
<p>表达式的值必须有流类型。执行过程如下：</p>
<ol>
<li>等待直到流发射一个值</li>
<li>执行函数体中的for循环，变量值为被射出的值</li>
<li>重复1和2直到流被关闭</li>
</ol>
<p>停止对流的监听，你可以使用一个break或者return语句，退出for循环和从流中退订。</p>
<p><strong>如果在表现异步for循环的时候出现编译时错误，确保await for在asyn函数内。</strong> 举个例子，你在你的app的main()函数使用异步for循环，main()的函数体必须被标记为async。</p>
<pre><code class="language-dart">  Future main() async {
    // ...
    await for (var request in requestServer) {
      handleRequest(requset);
    }
    // ...
  }
</code></pre>
<p>获取更多关于异步编程的信息，通常上，在库之旅中参考<a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:async</a>章节。</p>
<p>也可以看文章<a href="https://www.dartlang.org/articles/language/await-async">Dart异步支持：1</a>、<a href="https://www.dartlang.org/articles/language/beyond-async">Dart异步支持：2</a> 和 <a href="https://www.dartlang.org/guides/language/spec">Dart语言指向</a> 。</p>
<h2>发生器Generators</h2>
<p>当你需要懒生成一连串的值时，考虑使用发生器函数。Dart内置两种发生器函数：</p>
<ul>
<li>同步发生器：返回一个<a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html">可迭代</a>对象</li>
<li>异步发生器：返回一个<a href="https://api.dartlang.org/stable/dart-async/Stream-class.html">流</a>对象</li>
</ul>
<p>表现一个同步发生器，用sync*标记函数体，用yield传递值：</p>
<pre><code class="language-dart">  Iterable&lt;int&gt; naturalsTo(int n) sync* {
    int k = 0;
    while (k &lt; n) yield k++;
  }
</code></pre>
<p>表现一个异步发生器，用async*标记函数体，用yield传递值：</p>
<pre><code class="language-dart">  Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* {
    int k = 0;
    while (k &lt; n) yield k++;
  }
</code></pre>
<p>如果你的生成器是递归，你可以使用yield*提高其性能：</p>
<pre><code class="language-dart">  Iterable&lt;int&gt; naturalsDownFrom(int n) sync* {
    if (n &gt; 0){
      yield n;
      yield* naturalsDownFrom(n - 1);
    }
  }
</code></pre>
<p>了解更多关于发生器，参考文章<a href="https://www.dartlang.org/articles/language/beyond-async">Dart异步支持：2</a></p>
<h2>可调用的类</h2>
<p>允许你的类像函数一样被调用，使用call()方法。</p>
<p>在下面的示例中，WannabeFunction类定义了一个call()函数，接受三个字符串并连接它们，用空格分隔每个字符串，并附加一个感叹号。</p>
<pre><code class="language-dart">  class WannabeFunction {
    call(String a, String b, String c) =&gt; '$a $b $c!';
  }
  main() {
    var wf = WannabeFunction();
    var out = wf(&quot;Hi&quot;, &quot;there&quot;, &quot;gang&quot;);
    print('$out');
  }
</code></pre>
<p>了解更多关于将类如同函数一样对待的信息，请参考<a href="https://www.dartlang.org/articles/language/emulating-functions">在Dart中模拟函数</a> 。</p>
<h2>分离Isolates</h2>
<p>大多的计算机，甚至一些移动设备上，都有多核CPU。为了利用所有的核心，开发人员传统上使用并发运行的共享内存线程。但是，共享状态并发容易出错，并且可能导致代码复杂化。所有Dart代码都在隔离区内运行，而不是线程。每个隔离区都有自己的内存堆，确保不会从任何其他隔离区访问隔离区的状态。有关更多信息，请参阅 <a href="https://api.dartlang.org/stable/dart-isolate">dart:isolate库文档</a></p>
<h2>类型定义Typedefs</h2>
<p>在Dart中，函数是对象，就如同字符串和数字是对象那样。一个类型定义，或者一个功能型的别名，给予了函数一个名字，你可以在声明的时候和返回类型的时候使用它。当函数类型分配给变量时，typedef会保留类型信息。</p>
<p>下面是没有使用typedef的代码：</p>
<pre><code class="language-dart">  class SortedCollection {
    Function compare;

    SortedCollection(int f(Object a, Object b)) {
      compare = f;
    }
  }

  // 初始化

  int sort(Object a, Object b) =&gt; 0;

  void main() {
    SortedCollection coll = SortedCollection(sort);

    // 我们都知道compare是一个函数，但是什么类型的函数呢？

    assert(coll.compare is Function);
  }
</code></pre>
<p>当把f的值赋给compare时，类型信息就丢失了。f的类型是(Object, Object) -&gt; int(其中 -&gt; 表示返回)，但是compare的类型是Function。如果我们将代码更改为使用显式名称并保留类型信息，则开发人员和工具都可以使用该信息。</p>
<pre><code class="language-dart">  typedef Compare = int Function(Object a, Object b);

  class SortedCollection {
    Compare compare;

    SortedCollection(this.compare);
  }

  // 初始化

  int sort(Object a, Object b) =&gt; 0;

  void main() {
    SortedCollection coll = SortedCollection(sort);
    assert(coll.compare is Function);
    assert(coll.compare is Compare);
  }
</code></pre>
<blockquote>
<p>目前，typedef仅限于函数类型，开发者希望改变这一点。</p>
</blockquote>
<p>因为类型定义只是别名，它们提供了检查函数类型的方法。</p>
<pre><code class="language-dart">  typedef Compare&lt;T&gt; = int Function(T a, T b);

  int sort(int a, int b) =&gt; a - b;
  void main() {
    assert(sort is Compare&lt;int&gt;);       // True
  }
</code></pre>
<h2>元数据Metadata</h2>
<p>使用元数据给关于你的代码额外的信息。元数据注释以字符@开头，后跟对编译时常量（如deprecated）的引用或对常量构造函数的调用。</p>
<p>所有的Dart代码都有两个注释：@deprecated和@override，有关使用@override的示例，参阅<a href="https://www.dartlang.org/guides/language/language-tour#extending-a-class">扩展类</a>，以下是使用@deprecated的示例：</p>
<pre><code class="language-dart">  class Television {
    /// _Deprecated:使用[turnOn]代替_
    @deprecated
    void actvate() {
      turnOn();
    }

    /// 打开TV的电源
    void turnOn(){...}
  }
</code></pre>
<p>你可以定义你自己的元数据注释。下面的例子中定义了一个@todo注释并带有两个参数。</p>
<pre><code class="language-dart">  library todo;
  class Todo {
    final String who;
    final String what;

    const Todo(this.who, this.what);
  }
</code></pre>
<p>下面是使用@todo的一个示例：</p>
<pre><code class="language-dart">  import 'todo.dart';

  @Todo('seth', 'make this do something')
  void doSomething() {
    print('do something');
  }
</code></pre>
<p>元数据可以在库、类、类型定义、类型参数、工厂、字段、参数、或变量声明以及导入或导出指令之前出现，可以使用反射在运行时检索元数据。</p>
<h2>评论（代码注释）</h2>
<p>Dart支持单行、多行、文档评论。</p>
<h3>单行（以&quot;//&quot;开头，忽略后面内容）</h3>
<h3>多行（介于/* */之间，可以嵌套）</h3>
<h3>文档</h3>
<p>文档评论是以///或者/**开头的多行或者单行评论，在连续的行使用///的效果与多行评论的效果相同。</p>
<p>在文档评论中，Dart编译器忽略所有的文本，除非它在括号之中。使用括号，可以引用类、方法、字段、顶级变量、函数和参数。括号中的名称在已记录的程序元素的词法范围内得到解析。</p>
<p>以下是文档注释的示例，包含对其他的类和参数的引用：</p>
<pre><code class="language-dart">  /// A domesticated South American camelid (Lama glama).
  ///
  /// Andean cultures have used llamas as meat and pack
  /// animals since pre-Hispanic times.
  class Llama {
    String name;

    /// Feeds your llama [Food].
    ///
    /// The typical llama eats one bale of hay per week.
    void feed(Food food) {
      // ...
    }

    /// Exercises your llama with an [activity] for
    /// [timeLimit] minutes.
    void exercise(Activity activity, int timeLimit) {
      // ...
    }
  }
</code></pre>
<p>在生成的文档之中，[Food]成为了Food类API文档的链接。</p>
<p>要解析并生成HTML文档，你可以使用SDK的 <a href="https://github.com/dart-lang/dartdoc#dartdoc">文档生成工具</a> 。有关生成文档的示例，参阅 <a href="https://api.dartlang.org/stable">Dart API文档</a> 。有关如何构建评论的建议，请参阅 <a href="https://www.dartlang.org/guides/language/effective-dart/documentation">Dart Doc评论指南</a> 。</p>
<h2>总结</h2>
<p>本教程概述了Dart语言中的常用功能。正在实施更多功能，设计者不希望破坏现有的代码体系。更多信息参阅 <a href="https://www.dartlang.org/guides/language/spec">Dart语言规范</a> 和 <a href="https://www.dartlang.org/guides/language/effective-dart">有效Dart</a> 。</p>
<p>学习更多Dart的核心库，参见 <a href="https://www.dartlang.org/guides/libraries/library-tour">Dart库之旅</a> 。</p>
]]></content>
        <author>
            <name>Herbert He</name>
            <email>hi@ibert.me</email>
            <uri>https://ibert.me</uri>
        </author>
    </entry>
</feed>