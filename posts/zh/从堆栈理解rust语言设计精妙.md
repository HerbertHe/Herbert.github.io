---
title: 从堆栈理解rust语言设计精妙
date: 2023-11-20 17:28
toc: true
draft: true
tags: [ Rust, Rust语言圣经, 堆栈, 内存分配, 所有权, 借用, 引用 ]
---

## 写在前面的 ✍️

本篇是对 Rust 语言学习经验的总结，使用电子书为 [《Rust 语言圣经》](https://course.rs)。

Rust 的入门是反反复复且艰难的，这对尝试去 **“学习”** rust 语言的同学来说，都是一段刻骨铭心并且痛苦的回忆。因为失去了 GC 的支持，对于 rust 语言的新的概念和深刻认知，会感觉很艰难。所以，Rust 的入门总是反反复复的，放弃是最容易做到的事情。

在通过菜鸟教程做 Overview 和看视频看语法都失败之后，才知道 《Rust 语言圣经》 这本书。

🙅 不要去学 Rust，因为永远都学不会，对于任何一门语言来说，向来都是如此。

Rust 的难正是在于对计算机基础的掌握不深，熟练掌握这门语言对于工作可能毫无正向收益，但对计算机基础的原理，包括堆栈结构、内存分配、作用域范围等有深刻的思考和理解。从怀疑 Rust、学习 Rust、理解 Rust，到 **“生锈”**，Rust 的设计实属是非常精妙的，也是在不断进行修正发展的。这是我第一次深刻感受到，或许 Rust 真的在绝大程度上可以取代 C/C++。

[所有权——一段不安全的代码](https://course.rs/basic/ownership/ownership.html#%E4%B8%80%E6%AE%B5%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81)

## 栈与堆

- [栈(Stack)与堆(Heap)](https://course.rs/basic/ownership/ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap)

### 栈 Stack

栈，这一数据结构，对熟悉数据结构的人来说并不陌生，遵循 **LIFO** 的原则。但受制于栈中所有的数据必须占用已知且固定大小的内存空间，在数据大小未知的情况下，就没有办法获取到想要的数据。对于基本数据类型，比如 `u8` `u16` `u32` 等整数类型，`char` 字符、 `bool` 布尔等，他们在内存中占用的大小是固定的，所以获取他们的值并进行操作完全可以进行数据栈操作。

但，如果是字符串呢？我们无法保证存储的字符串长度是一致且不变的，不能使用栈来进行实现。

### 堆 Heap

所以，我们把这些大小未知、可能变化的数据放在堆上。操作系统在堆上找到一块足够大的地方，把我们的数据放上去，返回地址的指针，即为我们分配好了内存。

因为指针大小是已知且固定的，所以可以把这一个堆的对应指针推入栈中，通过获取栈的指针就可以进一步获取堆上的数据。

## 所有权

当理解上面通过堆栈来存取数据之后，我更愿意将所谓的 **“所有权”** 这一概念，引伸为 **“堆内存所有权”**。**即：所定义变量对于这一段堆内存的操作权限。**

对于内存分配的理解，对 rust 学习和使用是至关重要的。

当可以深刻理解上面所述，这才算是真正开始入门 rust。rust 并没有那么的反人类，他的 “反人类” 都是在适当增加心智负担的情况下，让开发者实时注意并保证内存的安全。

Rust 没有 **“赋值”** 的概念，只有 **“绑定”**，即不断的分配内存和使用内存，并且 rust 对于数据的操作都可以认为是指针操作。充分理解这句话，对于避免那些烦人的编译器 bug 非常有帮助。
