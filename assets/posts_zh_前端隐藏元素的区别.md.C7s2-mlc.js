import{_ as e,c as o,o as a,a6 as c}from"./chunks/framework.BDSt01_6.js";const b=JSON.parse('{"title":"前端隐藏元素的区别","description":"","frontmatter":{"title":"前端隐藏元素的区别","date":"2020-07-14T10:45:13.000Z","toc":true,"tags":["前端","CSS"]},"headers":[],"relativePath":"posts/zh/前端隐藏元素的区别.md","filePath":"posts/zh/前端隐藏元素的区别.md"}'),t={name:"posts/zh/前端隐藏元素的区别.md"},i=c('<h2 id="隐藏元素的方法" tabindex="-1">隐藏元素的方法 <a class="header-anchor" href="#隐藏元素的方法" aria-label="Permalink to &quot;隐藏元素的方法&quot;">​</a></h2><p>前端如果设置元素不可见，可以使用<code>display: none</code> <code>visibility:hidden</code> <code>opacity: 0</code></p><h2 id="空间占据" tabindex="-1">空间占据 <a class="header-anchor" href="#空间占据" aria-label="Permalink to &quot;空间占据&quot;">​</a></h2><ul><li><code>display: none</code>隐藏是不占用空间的，会产生回流和重绘</li><li><code>visibility: hidden</code>和<code>opacity: 0</code>隐藏了元素，但是仍然占据着空间，只会引起页面的重绘</li></ul><blockquote><p>回流(Layout): 根据生成的渲染树进行回流，得到节点的几何信息； 重绘(Painting): 根据渲染树得到的几何信息，得到节点的绝对像素</p></blockquote><h2 id="子元素继承" tabindex="-1">子元素继承 <a class="header-anchor" href="#子元素继承" aria-label="Permalink to &quot;子元素继承&quot;">​</a></h2><ul><li><code>display: none</code>这个父元素都不存在了</li><li><code>visibility: hidden</code>会被继承，通过对子元素设置<code>visibility: visible</code></li><li><code>opacity: 0</code>会被继承，子元素不能设置<code>opacity: 1</code>显示，因为<code>opacity</code>这个本就是设置透明度的！</li></ul><h2 id="事件触发" tabindex="-1">事件触发 <a class="header-anchor" href="#事件触发" aria-label="Permalink to &quot;事件触发&quot;">​</a></h2><ul><li><code>display: none</code>元素不存在，无法触发绑定事件</li><li><code>visibility: hidden</code>绑定事件无法触发</li><li><code>opacity: 0</code>绑定事件是可以触发的</li></ul><h2 id="过渡动画" tabindex="-1">过渡动画 <a class="header-anchor" href="#过渡动画" aria-label="Permalink to &quot;过渡动画&quot;">​</a></h2><p><code>transition</code>只对可数值化的属性有效，因此只有<code>opacity</code>有效</p><h2 id="一个需求" tabindex="-1">一个需求 <a class="header-anchor" href="#一个需求" aria-label="Permalink to &quot;一个需求&quot;">​</a></h2><p>建立一个搜索框，当<code>hover</code>搜索框的时候，<code>搜索提示元素</code>通过过渡动画展示；当仅<code>focus</code>搜索框时，<code>搜索提示元素</code>不展示，但搜索框长度通过过渡动画使宽度拉长；要求点击搜索提示框的内容时，可以跳转其他页面。</p><p>需求分析:</p><ul><li>定位问题：输入框和搜索提示的节点拥有父节点，并且父节点的<code>position</code>为<code>relative</code>，这样就可以设置<code>搜索提示框</code>的绝对定位来设置位置</li><li>事件处理问题：使用父元素的<code>hover</code>伪类控制子元素<code>搜索提示框</code>的<code>opacity</code>和<code>高度</code>；使用输入框的<code>focus</code>伪类撑起父元素的宽度；这样当整体被<code>hover</code>时，<code>搜索提示框</code>可以被展示，并且当点击<code>搜索提示框</code>里面的内容那一瞬间，输入框焦点失去，但事件可以被触发，也不用担心会被误触的情况</li></ul><blockquote><p>示例代码 <a href="https://github.com/NUCOSC/Nucers/blob/dev/site/components/common/NavBar.tsx#L173" target="_blank" rel="noreferrer">NavBar</a>和<a href="https://github.com/NUCOSC/Nucers/blob/dev/site/styles/components/common/NavBar.css#L32" target="_blank" rel="noreferrer">样式</a></p></blockquote><h2 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h2><ul><li><a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noreferrer">你真的了解回流和重绘吗</a></li><li><a href="https://blog.csdn.net/github_39673115/article/details/77926351" target="_blank" rel="noreferrer">~之间的区别</a></li></ul>',18),d=[i];function l(r,s,n,h,p,u){return a(),o("div",null,d)}const f=e(t,[["render",l]]);export{b as __pageData,f as default};
