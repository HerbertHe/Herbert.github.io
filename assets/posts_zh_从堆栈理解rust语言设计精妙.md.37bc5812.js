import{_ as t,o as e,c as r,Q as a}from"./chunks/framework.9818e7a8.js";const g=JSON.parse('{"title":"从堆栈理解rust语言设计精妙","description":"","frontmatter":{"title":"从堆栈理解rust语言设计精妙","date":"2023-11-20 17:28","toc":true,"draft":true,"tags":["Rust","Rust语言圣经","堆栈","内存分配","所有权","借用","引用"]},"headers":[],"relativePath":"posts/zh/从堆栈理解rust语言设计精妙.md","filePath":"posts/zh/从堆栈理解rust语言设计精妙.md"}'),s={name:"posts/zh/从堆栈理解rust语言设计精妙.md"},o=a('<h2 id="写在前面的-✍️" tabindex="-1">写在前面的 ✍️ <a class="header-anchor" href="#写在前面的-✍️" aria-label="Permalink to &quot;写在前面的 ✍️&quot;">​</a></h2><p>本篇是对 Rust 语言学习经验的总结，使用电子书为 <a href="https://course.rs" target="_blank" rel="noreferrer">《Rust 语言圣经》</a>。</p><p>Rust 的入门是反反复复且艰难的，这对尝试去 <strong>“学习”</strong> rust 语言的同学来说，都是一段刻骨铭心并且痛苦的回忆。因为失去了 GC 的支持，对于 rust 语言的新的概念和深刻认知，会感觉很艰难。所以，Rust 的入门总是反反复复的，放弃是最容易做到的事情。</p><p>在通过菜鸟教程做 Overview 和看视频看语法都失败之后，才知道 《Rust 语言圣经》 这本书。</p><p>🙅 不要去学 Rust，因为永远都学不会，对于任何一门语言来说，向来都是如此。</p><p>Rust 的难正是在于对计算机基础的掌握不深，熟练掌握这门语言对于工作可能毫无正向收益，但对计算机基础的原理，包括堆栈结构、内存分配、作用域范围等有深刻的思考和理解。从怀疑 Rust、学习 Rust、理解 Rust，到 <strong>“生锈”</strong>，Rust 的设计实属是非常精妙的，也是在不断进行修正发展的。这是我第一次深刻感受到，或许 Rust 真的在绝大程度上可以取代 C/C++。</p><p><a href="https://course.rs/basic/ownership/ownership.html#%E4%B8%80%E6%AE%B5%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81" target="_blank" rel="noreferrer">所有权——一段不安全的代码</a></p><h2 id="栈与堆" tabindex="-1">栈与堆 <a class="header-anchor" href="#栈与堆" aria-label="Permalink to &quot;栈与堆&quot;">​</a></h2><ul><li><a href="https://course.rs/basic/ownership/ownership.html#%E6%A0%88stack%E4%B8%8E%E5%A0%86heap" target="_blank" rel="noreferrer">栈(Stack)与堆(Heap)</a></li></ul><h3 id="栈-stack" tabindex="-1">栈 Stack <a class="header-anchor" href="#栈-stack" aria-label="Permalink to &quot;栈 Stack&quot;">​</a></h3><p>栈，这一数据结构，对熟悉数据结构的人来说并不陌生，遵循 <strong>LIFO</strong> 的原则。但受制于栈中所有的数据必须占用已知且固定大小的内存空间，在数据大小未知的情况下，就没有办法获取到想要的数据。对于基本数据类型，比如 <code>u8</code> <code>u16</code> <code>u32</code> 等整数类型，<code>char</code> 字符、 <code>bool</code> 布尔等，他们在内存中占用的大小是固定的，所以获取他们的值并进行操作完全可以进行数据栈操作。</p><p>但，如果是字符串呢？我们无法保证存储的字符串长度是一致且不变的，不能使用栈来进行实现。</p><h3 id="堆-heap" tabindex="-1">堆 Heap <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆 Heap&quot;">​</a></h3><p>所以，我们把这些大小未知、可能变化的数据放在堆上。操作系统在堆上找到一块足够大的地方，把我们的数据放上去，返回地址的指针，即为我们分配好了内存。</p><p>因为指针大小是已知且固定的，所以可以把这一个堆的对应指针推入栈中，通过获取栈的指针就可以进一步获取堆上的数据。</p><h2 id="所有权" tabindex="-1">所有权 <a class="header-anchor" href="#所有权" aria-label="Permalink to &quot;所有权&quot;">​</a></h2><p>当理解上面通过堆栈来存取数据之后，我更愿意将所谓的 <strong>“所有权”</strong> 这一概念，引伸为 <strong>“堆内存所有权”</strong>。<strong>即：所定义变量对于这一段堆内存的操作权限。</strong></p><p>对于内存分配的理解，对 rust 学习和使用是至关重要的。</p><p>当可以深刻理解上面所述，这才算是真正开始入门 rust。rust 并没有那么的反人类，他的 “反人类” 都是在适当增加心智负担的情况下，让开发者实时注意并保证内存的安全。</p><p>Rust 没有 <strong>“赋值”</strong> 的概念，只有 <strong>“绑定”</strong>，即不断的分配内存和使用内存，并且 rust 对于数据的操作都可以认为是指针操作。充分理解这句话，对于避免那些烦人的编译器 bug 非常有帮助。</p>',20),n=[o];function p(u,c,h,i,l,_){return e(),r("div",null,n)}const f=t(s,[["render",p]]);export{g as __pageData,f as default};
