import{_ as e,o,c as d,Q as r}from"./chunks/framework.9818e7a8.js";const k=JSON.parse('{"title":"关于for-editor的扩展开发及markedjs语法扩展的心得","description":"","frontmatter":{"title":"关于for-editor的扩展开发及markedjs语法扩展的心得","date":"2020-04-14T17:24:14.000Z","toc":true,"tags":["JavaScript","TypeScript","React","marked","markdown","npm"]},"headers":[],"relativePath":"posts/zh/关于for-editor的扩展开发及markedjs语法扩展的心得.md","filePath":"posts/zh/关于for-editor的扩展开发及markedjs语法扩展的心得.md"}'),a={name:"posts/zh/关于for-editor的扩展开发及markedjs语法扩展的心得.md"},c=r('<h2 id="关于for-editor" tabindex="-1">关于<code>for-editor</code> <a class="header-anchor" href="#关于for-editor" aria-label="Permalink to &quot;关于`for-editor`&quot;">​</a></h2><p>开始接触<code>for-editor</code>是因为想自己写一个基于Git的支持markdown的笔记本PC应用，常用开发框架是React、在PC端的开发工具的选择上选择了吃内存狂魔electron，就这样抱着能不造轮子就不造轮子的原则开始使用了<code>for-editor</code>（虽然之后没有打算继续开发）。<code>for-editor</code>如果对于语法的支持没有太高的要求的话，是一个非常优秀、简洁的编辑器组件。支持Tex渲染插入、mermaid流程图的支持、高级markdown或者扩展的markdown语法，随着需求的提升就准备了开始自己扩展语法之路，当然其中发现了很多需要优化和修改的地方。</p><h2 id="开发之路" tabindex="-1">开发之路 <a class="header-anchor" href="#开发之路" aria-label="Permalink to &quot;开发之路&quot;">​</a></h2><h3 id="通读源码" tabindex="-1">通读源码 <a class="header-anchor" href="#通读源码" aria-label="Permalink to &quot;通读源码&quot;">​</a></h3><p>源码可以从<a href="https://github.com/kkfor/for-editor" target="_blank" rel="noreferrer">for-editor</a>中查看。</p><p>首先，阅读<code>package.json</code>。<code>package.json</code>是所有React组件开发必不可少的环节，在此之前还是需要足够了解工程的<code>README.md</code>的。在<code>package.json</code>里，源工程对于markdown解析所用的引擎为<code>marked.js</code>和<code>highlight.js</code>。在之前了解<code>markdown</code> --&gt; <code>HTML</code>的渲染学习的时候所用的是<code>marked.js</code>，好处是足够简洁，坏处是语法很少并且扩展要求并不低。</p><p>其次，对于源码结构的解读。<code>dist</code>为生成产物，<code>doc</code>为相关文档，<code>example</code>为演示文档，<code>src</code>为源码目录，<code>webpack</code>为配置项。在<code>src</code>下有<code>components</code>、<code>lib</code>和<code>index.tsx</code>，<code>components</code>为工具栏的组件，<code>lib</code>是开发的依赖和功能源码，<code>index.tsx</code>为整体的页面结构。</p><h3 id="发现的问题" tabindex="-1">发现的问题 <a class="header-anchor" href="#发现的问题" aria-label="Permalink to &quot;发现的问题&quot;">​</a></h3><blockquote><p>这里提到的问题其实有一些是还没有完全修复的，有些问题真的存在了很多年了，至今我也没能想到比较好的解决办法。</p></blockquote><h4 id="响应式布局" tabindex="-1">响应式布局 <a class="header-anchor" href="#响应式布局" aria-label="Permalink to &quot;响应式布局&quot;">​</a></h4><p>在现代web开发中，响应式布局对于用户体验来说是非常好的，但是在访问速度上相比加载速度会稍微慢一些。针对于高标准的用户体验，我选择了牺牲掉一些访问速度，当然对于纯的通过CSS实现响应式布局在某些时候根本达不到好的效果，是需要JavaScript来加buff的，这也为之后的开发其实还挖了一个坑，对此我不得不做出妥协，完全的响应式目前看来是做不到的。在下面，我也会阐述具体的坑到底是什么。</p><p>响应式布局方面我做出的优化是针对<code>900px</code>这个标准进行的分割，随着工具栏功能的拓展，原本工具栏的布局会溢出。因此对于没有二级菜单的工具栏button，我选择写在了more里，并且另开了<code>for-mobile</code>，<code>for-pc</code>，使用了<code>flex</code>布局来处理宽度不够换行处理的优化措施。在下一个坑没有遇到之前，这个方案我觉得解决的还算不错。（当然开了新得分支，还是被提了issue，主要是他遇到的浏览器尺寸在我测试的时候真的没有发现任何问题，很迷惑）</p><h4 id="mermaid的引入" tabindex="-1"><code>mermaid</code>的引入 <a class="header-anchor" href="#mermaid的引入" aria-label="Permalink to &quot;`mermaid`的引入&quot;">​</a></h4><p>这是我几个月都没有解决的问题，可能是打开方式不太对吧。。。参考了<code>mermaidAPI</code>和与<code>mermaid</code>开发者交流提了<code>issue</code>但是始终没有解决。难道mermaid真的是只能用已存在DOM节点来做渲染的吗？希望能有大佬带我深入了解一下。mermaid的渲染要写在主组件的生命周期里面，但是就我刚刚说的，如果已知存在，在什么时候插进去来触发渲染？最后我选择了原样插入，然后再触发渲染的方式，当我满心欢喜觉得一切都能如愿的时候。我发现真的能不能渲染出来都是薛定谔的猫:(然后不得不放弃，想想也真的可能跟后面那个深坑有关系，总有办法能解决这个问题，然后参考过CSDN的HTML代码，也就是我后来的考虑的深坑。对此，我移除了<code>mermaid</code>的渲染支持。</p><h4 id="修复js对于二级菜单的控制" tabindex="-1">修复js对于二级菜单的控制 <a class="header-anchor" href="#修复js对于二级菜单的控制" aria-label="Permalink to &quot;修复js对于二级菜单的控制&quot;">​</a></h4><p>感谢<a href="https://github.com/ivanandonov" target="_blank" rel="noreferrer">@ivanandonov</a>的issue，之前我并不太觉得点击关掉二级菜单很重要，其实也就是添加个关掉二级菜单的事件，问题不大。</p><h4 id="拓展marked-js的语法" tabindex="-1">拓展<code>marked.js</code>的语法 <a class="header-anchor" href="#拓展marked-js的语法" aria-label="Permalink to &quot;拓展`marked.js`的语法&quot;">​</a></h4><p>这是本部分最核心的内容了。如何去扩展<code>marked.js</code>的语法？？？我看到网上有很多小伙伴尝试去扩展语法，但是也有不少选择了放弃。</p><p>如果你想尝试去扩展语法，熟读<code>marked.js</code>的<a href="https://marked.js.org/#/README.md#README.md" target="_blank" rel="noreferrer">使用指南</a>、<code>marked.js</code>的<a href="https://github.com/markedjs/marked" target="_blank" rel="noreferrer">源码</a>和实现逻辑，当然还需要写正则表达式:)</p><p><code>marked.js</code>最牛逼的部分就在于正则表达式，就不重复匹配的问题，如何去用正则表达式去表示？因此重写renderer的时候我参考了很多源码部分的内容，这里就不针对<code>marked.js</code>详细展开介绍了，我只写一写我到底做了哪些事。</p><ul><li>抽离<code>highlight.js</code>。在原项目发现的问题之一就是——我如何去让使用者自行决定高亮的代码类型？我总不能把所有的语言都注册一遍吧？！不但增加了代码量，还需求不是很大，所以我选择了把<code>highlight.js</code>依赖给移除掉。让使用者传入<code>Hljs.highlightAuto</code>这个函数，其他的自己引入<code>highlight.js</code>然后自己注册就完事了。</li><li>引入<code>emoji</code>、<code>Tex</code>、<code>diff</code>语法、<code>mark</code>做行内高亮。这就涉及了不少的正则表达式，尤其是在<code>mark</code>这个渲染上，你总不能把每一句都拿正则循环跑吧，根本不实际。所以得先把高亮块抽离出来然后再排回去，并且不能涉及需要使用的非特殊字符。感兴趣的小伙伴可以参考<a href="https://github.com/HerbertHe/for-editor-herb/blob/master/src/lib/helpers/marked.ts" target="_blank" rel="noreferrer">marked.ts</a>这个部分的源码。对于类似```这种就是对于code块的解析，如果是行内嵌入或者自定义渲染块呢就在<code>paragraph</code>的部分进行重写renderer就好了，但是记得一定要看源码对应的<code>html</code>的标签。</li></ul><h4 id="扩展渲染的锚点和大纲" tabindex="-1">扩展渲染的锚点和大纲 <a class="header-anchor" href="#扩展渲染的锚点和大纲" aria-label="Permalink to &quot;扩展渲染的锚点和大纲&quot;">​</a></h4><p>渲染的锚点就是重写<code>heading</code>部分的HTML，不赘述了就是添加一个a标签就能解决的事情。大纲、目录、TOC，一个东西需要用到<code>marked.js</code>提供的解析器<code>lexer</code>，提取heading部分和深度，然后来写样式部分。</p><h4 id="深坑——如何去调整textarea的高度" tabindex="-1">深坑——如何去调整<code>textarea</code>的高度 <a class="header-anchor" href="#深坑——如何去调整textarea的高度" aria-label="Permalink to &quot;深坑——如何去调整`textarea`的高度&quot;">​</a></h4><p>这一切的问题还是来源于，当我使用分栏的功能。我发现记行号并不正确，并且<code>textarea</code>的部分并不能很好的解决高度问题，因为高度不足以显示全部的内容。为什么<code>overflow: hidden</code>其实我在不断优化这个问题的时候也能体会到，因为外部的滚动条需要与行号对齐。</p><ul><li>修改一：换掉计算行号的方式。源代码的计算方式是通过计算<code>\\n</code>来实现的，貌似<code>vscode</code>的markdown也是这么实现的，但是就优化而言<code>textarea</code>对于行号样式能有<code>vscode</code>这样的调整我是没有发现能有什么办法可以做到的。因此我也考虑了很多办法去优化这个问题，甚至重构编辑器。在目前<code>2.x.x</code>的版本中，我已经换成了根据textarea的高度来计算行号了。</li><li>修改二：自适应调整textarea的高度。认真地说，这个坑都坑了多少年了，不知道坑过多少人，知乎还有很多的讨论。其实改起来也不算难，就是把<code>height: auto</code>，然后动态调整高度等于<code>scrollHeight</code>。然后我选择了把计算行号在重新计算高度的函数中进行了调用。看起来，<code>everything is ok</code>了是吧？：）惊喜的是当分栏激活的时候<code>scrollHeight</code>并不是会增大，是会减小的，没想到吧。然后我只能选择目前来说我能提供的最优的解决方案，仅当分栏关掉的时候计算高度，然后通过修改值就可以做到精确计算。原作者还提供了fontSize这个可选项，为此我去了解了<code>line-height</code>和<code>font-size</code>之间的关系，具体的源码请参考<code>index.tsx</code>的<code>reHeight</code>部分的源码。其实我还考虑过，根据上一时刻的面积除当前时刻的宽度来计算高度的，听起来是真的很美好。实际情况是，当你切换过快的时候，读取到的面积并不准确，因此这个方法就是<code>理想很丰满，现实很骨感</code>的问题。</li><li>为什么不考虑去用可编辑div重写？下次一定，我是准备在<code>3.x.x</code>的版本重构的，但是我目前没有这么多时间去考虑这个问题了，是真的很麻烦。</li></ul><h2 id="心得感悟" tabindex="-1">心得感悟 <a class="header-anchor" href="#心得感悟" aria-label="Permalink to &quot;心得感悟&quot;">​</a></h2><p>小小的富文本编辑器竟然如此复杂，我突然发现我是想慢慢尝试去实现word的最基础的功能。在拓展<code>for-editor</code>的过程中我学到了很多根据教程根本是不可能学到的实际开发问题，为此我付出了很长的事件去研究源码，当然也去开始适应TypeScript来做开发。使用开源项目不是减少工作量，很大程度上其实增加了不少学习成本。</p><p>如果喜欢<a href="https://github.com/HerbertHe/for-editor-herb" target="_blank" rel="noreferrer">for-editor-herb</a>我这个分支呢，请给<a href="https://github.com/kkfor/for-editor" target="_blank" rel="noreferrer">原项目</a>一个star。</p>',29),t=[c];function i(h,s,l,n,m,p){return o(),d("div",null,t)}const b=e(a,[["render",i]]);export{k as __pageData,b as default};
