import{_ as t,c as e,o as r,a6 as o}from"./chunks/framework.CRmoCaTl.js";const y=JSON.parse('{"title":"ECMAScript 中的 Symbol 类型","description":"","frontmatter":{"title":"ECMAScript 中的 Symbol 类型","date":"2024-04-14T18:09:01.000Z","toc":true,"tags":["ECMAScript","规范","symbol","javascript"]},"headers":[],"relativePath":"posts/zh/ECMAScript 中的 Symbol 类型.md","filePath":"posts/zh/ECMAScript 中的 Symbol 类型.md"}'),a={name:"posts/zh/ECMAScript 中的 Symbol 类型.md"},c=o('<h2 id="写在前面的" tabindex="-1">写在前面的 <a class="header-anchor" href="#写在前面的" aria-label="Permalink to &quot;写在前面的&quot;">​</a></h2><p>ECMAScript 是当前最主流的 JavaScript 语言规范，在日常的开发之中，可能完全不需要去了解规范本身的内容，但了解并理解规范本身的内容对写更好的 javascript 代码有更深远的意义。</p><p>本文将基于 ECMAScript-262 语言规范（第14版，2023年6月）的内容，从官方文档中了解自 ECMAScript 2015版(ES6) 开始引入的 Symbol 类型。</p><blockquote><p>规范原文：<a href="https://262.ecma-international.org/14.0/#sec-ecmascript-language-types-symbol-type" target="_blank" rel="noreferrer">https://262.ecma-international.org/14.0/#sec-ecmascript-language-types-symbol-type</a></p></blockquote><h2 id="symbol-类型" tabindex="-1">Symbol 类型 <a class="header-anchor" href="#symbol-类型" aria-label="Permalink to &quot;Symbol 类型&quot;">​</a></h2><p><em>Symbol 类型</em> 是所有可被用于 Object 属性键的非字符串值的集合。(<a href="https://262.ecma-international.org/14.0/#sec-object-type" target="_blank" rel="noreferrer">6.1.7</a>)</p><p>每一个可能的 Symbol 值都是唯一的，并且不可变的。</p><p>每一个 Symbol 值不可变拥有一个相关联被称为 <code>[[Description]]</code> 的值，该值是 <strong>undefined</strong> 或一个字符串。</p><h3 id="知名的-symbols" tabindex="-1">知名的 Symbols <a class="header-anchor" href="#知名的-symbols" aria-label="Permalink to &quot;知名的 Symbols&quot;">​</a></h3><p>知名的 Symbols 是由 ECMAScript 规范的算法明确引用的内置 Symbol 值。它们通常被用作属性的键，其值作为规范的算法扩展点。除非另有说明，否则这些知名的 symbols 值由所有的 <a href="https://262.ecma-international.org/14.0/#realm" target="_blank" rel="noreferrer">realms</a> (<a href="https://262.ecma-international.org/14.0/#sec-code-realms" target="_blank" rel="noreferrer">9.3</a>) 所共享。</p><p>在本篇规范中，知名的 symbols 使用 <code>@@name</code> 的形式进行表示，“name” 的值是 表1 中所列出的其中之一。</p><p>表 1：知名的 Symbols</p><table><thead><tr><th>规范名称</th><th><code>[[Decription]]</code></th><th>值和目的</th></tr></thead><tbody><tr><td><code>@@asyncIterator</code></td><td><code>&quot;Symbol.asyncIterator&quot;</code></td><td>一个从对象中返回默认的 AsyncIterator 的方法。由 <strong>for-await-of</strong> 语句调用。</td></tr><tr><td><code>@@hasInstance</code></td><td><code>&quot;Symbol.hasInstance&quot;</code></td><td>一个用于确定 <a href="https://262.ecma-international.org/14.0/#constructor" target="_blank" rel="noreferrer">构造函数</a> 对象是否将对象识别为 <a href="https://262.ecma-international.org/14.0/#constructor" target="_blank" rel="noreferrer">构造函数</a> 的实例之一的方法。由 <strong>instanceof</strong> 运算符调用。</td></tr><tr><td><code>@@isConcatSpreadable</code></td><td><code>&quot;Symbol.isConcatSpreadable&quot;</code></td><td>一个布尔值属性，如果为 true 表明对象应该通过 <a href="https://262.ecma-international.org/14.0/#sec-array.prototype.concat" target="_blank" rel="noreferrer">Array.prototype.concat</a> 扁平化到它的数组元素</td></tr><tr><td><code>@@iterator</code></td><td><code>&quot;Symbol.iterator&quot;</code></td><td>一个为对象返回默认迭代器的方法。由 <strong>for-of</strong> 语句调用。</td></tr><tr><td><code>@@match</code></td><td><code>&quot;Symbol.match&quot;</code></td><td>一个将正则表达式与字符串匹配的正则表达式方法。由 <a href="https://262.ecma-international.org/14.0/#sec-string.prototype.match" target="_blank" rel="noreferrer">String.prototype.match</a> 方法调用。</td></tr><tr><td><code>@@matchAll</code></td><td><code>&quot;Symbol.matchAll&quot;</code></td><td>一个返回迭代器的正则表达式方法，用于生成正则表达式与字符串的匹配项。由 <a href="https://262.ecma-international.org/14.0/#sec-string.prototype.matchall" target="_blank" rel="noreferrer">String.prototype.matchAll</a> 方法调用。</td></tr><tr><td><code>@@replace</code></td><td><code>&quot;Symbol.replace&quot;</code></td><td>一个用于替换与正则表达式匹配字符串的子串的正则表达式方法。由 <a href="https://262.ecma-international.org/14.0/#sec-string.prototype.replace" target="_blank" rel="noreferrer">String.prototype.replace</a> 方法调用。</td></tr><tr><td><code>@@search</code></td><td><code>&quot;Symbol.search&quot;</code></td><td>一个返回与正则表达式匹配的索引值的正则表达式方法。由 <a href="https://262.ecma-international.org/14.0/#sec-string.prototype.search" target="_blank" rel="noreferrer">String.prototype.search</a> 方法调用。</td></tr><tr><td><code>@@species</code></td><td><code>&quot;Symbol.species&quot;</code></td><td>一个函数值属性，该属性是用于创建派生对象的构造函数。</td></tr><tr><td><code>@@split</code></td><td><code>&quot;Symbol.split&quot;</code></td><td>一个正则表达式方法用于在与正则表达式匹配的索引处拆分字符串。由 <a href="https://262.ecma-international.org/14.0/#sec-string.prototype.split" target="_blank" rel="noreferrer">String.prototype.split</a> 方法调用。</td></tr><tr><td><code>@@toPrimitive</code></td><td><code>&quot;Symbol.toPrimitive&quot;</code></td><td>一个将对象转化为原始值的方法。由 <a href="https://262.ecma-international.org/14.0/#sec-toprimitive" target="_blank" rel="noreferrer">ToPrimitive</a> 抽象操作调用。</td></tr><tr><td><code>@@toStringTag</code></td><td><code>&quot;Symbol.toStringTag&quot;</code></td><td>一个被用于为对象创建默认字符串描述的字符串值属性。由内置的 <a href="https://262.ecma-international.org/14.0/#sec-object.prototype.tostring" target="_blank" rel="noreferrer">Object.prototype.toString</a> 方法访问。</td></tr><tr><td><code>@@unscopables</code></td><td><code>&quot;Symbol.unscopables&quot;</code></td><td>一个对象值属性，其自己的属性名称和继承的属性名称是从关联对象的 <strong>与</strong> 环境绑定中排除的属性名称。</td></tr></tbody></table><h2 id="写在后面的" tabindex="-1">写在后面的 <a class="header-anchor" href="#写在后面的" aria-label="Permalink to &quot;写在后面的&quot;">​</a></h2><p>关于 realms 可以参考 Stack Overflow 上面的一篇讨论 <a href="https://stackoverflow.com/questions/49832187/how-to-understand-js-realms" target="_blank" rel="noreferrer">如何理解js的realms</a>。</p>',15),d=[c];function n(l,s,i,p,m,h){return r(),e("div",null,d)}const g=t(a,[["render",n]]);export{y as __pageData,g as default};
