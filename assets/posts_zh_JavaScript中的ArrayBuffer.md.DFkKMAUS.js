import{_ as e,c as r,o as a,a6 as t}from"./chunks/framework.BDSt01_6.js";const y=JSON.parse('{"title":"JavaScript中的ArrayBuffer","description":"","frontmatter":{"title":"JavaScript中的ArrayBuffer","toc":true,"tags":["ArrayBuffer","JavaScript","ES6"],"categories":[],"date":"2021-11-16T17:16:10.000Z"},"headers":[],"relativePath":"posts/zh/JavaScript中的ArrayBuffer.md","filePath":"posts/zh/JavaScript中的ArrayBuffer.md"}'),o={name:"posts/zh/JavaScript中的ArrayBuffer.md"},l=t('<h2 id="写在前面的" tabindex="-1">写在前面的 <a class="header-anchor" href="#写在前面的" aria-label="Permalink to &quot;写在前面的&quot;">​</a></h2><p>在尝试用国密算法实现 jwt 的时候, 发现可以使用的库很少, 便根据 jwt 的生成规则和国密 SM3 算法自行参考实现。SM3 是国密算法中的哈希散列算法, 生成单向指纹校验数据有着重要的意义。在生成 jwt 的指纹部分, 尝试使用 HMACSM3 替代掉 HMACSHA256算法。</p><p>HMACSM3 可用的 JavaScript 库确实没发现, 参考了 Java 版本进行自行实现。其中涉及到了二进制数据的位运算, 并且 <a href="https://github.com/byte-fe/gm-crypto" target="_blank" rel="noreferrer">byte-fe/gm-crypto</a> 中的 SM3 的返回值类型为 <code>ArrayBuffer</code>, 因此觉得研究此 ES6 的新内置对象很有意义。</p><h2 id="关于-arraybuffer" tabindex="-1">关于 ArrayBuffer <a class="header-anchor" href="#关于-arraybuffer" aria-label="Permalink to &quot;关于 ArrayBuffer&quot;">​</a></h2><p>在 MDN 中, 对于 <code>ArrayBuffer</code> 对象表述为表示通用的、固定长度的原市二进制数据缓冲区, <strong>在其他语言中被称为&quot;byte array(字节数组)&quot;</strong></p><p>在 golang 中, byte array 和 string 的类型转化很常见。byte array在不同语言中均有用处, 可以提高程序计算的性能。</p><p>JavaScript 的 <code>ArrayBuffer</code> 设计目的也同样如此, 需要注意的这又是一个 <em>array-like</em> object, 使用 TypedArray or DataView 对象进行操作。</p><h2 id="语法" tabindex="-1">语法 <a class="header-anchor" href="#语法" aria-label="Permalink to &quot;语法&quot;">​</a></h2><blockquote><p>new ArrayBuffer(length)</p></blockquote><ul><li>参数</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>length</code></td><td>要创建的 <code>ArrayBuffer</code> 的大小, 单位为字节</td></tr></tbody></table><ul><li>返回值</li></ul><p>一个指定大小的 <code>ArrayBuffer</code> 对象, 其内容被初始化为 0</p><ul><li>异常</li></ul><p>如果 <code>length</code> ＞ <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" target="_blank" rel="noreferrer">Number.MAX_SAFE_INTEGER</a> (≥2**53) 或为 负数, 会抛 RangeError 异常。</p><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><ul><li><code>ArrayBuffer,length</code></li></ul><p>ArrayBuffer 构造函数的 length 属性, 其值为 1</p><ul><li><code>ArrayBuffer.prototype.byteLength</code></li></ul><p>只读, 表示 <code>ArrayBuffer</code> 的 byte 大小, 在 ArrayBuffer 构造完成时生成, 不可更改。</p><h2 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h2><ul><li><code>ArrayBuffer.isView(arg)</code></li></ul><p>如果参数是 ArrayBuffer 的视图实例则返回 <code>true</code>, 例如 TypedArray or DataView 对象；否则返回 <code>false</code></p><ul><li><code>ArrayBuffer.transfer(oldBuffer [, newByteLength])</code> <em><strong>实验性</strong></em></li></ul><p>返回一个新的 ArrayBuffer 对象, 其内容取自 <code>oldBuffer</code> 中的数据, 并根据 <code>newByteLength</code> 的大小对数据进行截取或补 0</p><h2 id="兼容性" tabindex="-1">兼容性 <a class="header-anchor" href="#兼容性" aria-label="Permalink to &quot;兼容性&quot;">​</a></h2><p>就让 IE 消失于世间吧~</p>',27),c=[l];function f(d,i,u,n,h,p){return a(),r("div",null,c)}const A=e(o,[["render",f]]);export{y as __pageData,A as default};
